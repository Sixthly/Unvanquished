diff --git a/Makefile b/Makefile
index 5689005..e0ddba5 100644
--- a/Makefile
+++ b/Makefile
@@ -153,6 +153,10 @@ ifndef DEBUG_CFLAGS
 DEBUG_CFLAGS=-g -O0
 endif
 
+ifndef USE_FREETYPE
+USE_FREETYPE=1
+endif
+
 #############################################################################
 
 BD=$(BUILD_DIR)/debug-$(PLATFORM)-$(ARCH)
@@ -257,6 +261,10 @@ ifeq ($(PLATFORM),linux)
     endif
   endif
 
+  ifeq ($(USE_FREETYPE),1)
+    BASE_CFLAGS += -DBUILD_FREETYPE $(shell freetype-config --cflags)
+  endif
+
   ifeq ($(USE_CURL),1)
     CLIENT_CFLAGS += -DUSE_CURL
     ifeq ($(USE_CURL_DLOPEN),1)
@@ -338,6 +346,10 @@ ifeq ($(PLATFORM),linux)
     CLIENT_CFLAGS += -I$(SDLHDIR)/include
   endif
 
+  ifeq ($(USE_FREETYPE),1)
+    CLIENT_LDFLAGS += -lfreetype
+  endif
+
   ifeq ($(ARCH),x86)
     # linux32 make ...
     BASE_CFLAGS += -m32
@@ -377,6 +389,10 @@ ifeq ($(PLATFORM),darwin)
 
   BASE_CFLAGS += -fno-strict-aliasing -DMACOS_X -fno-common -pipe
 
+  ifeq ($(USE_FREETYPE),1)
+    BASE_CFLAGS += -DBUILD_FREETYPE $(shell freetype-config --cflags)
+  endif
+
   ifeq ($(USE_OPENAL),1)
     BASE_CFLAGS += -DUSE_OPENAL
     ifneq ($(USE_OPENAL_DLOPEN),1)
@@ -395,6 +411,10 @@ ifeq ($(PLATFORM),darwin)
     endif
   endif
 
+  ifeq ($(USE_FREETYPE),1)
+    CLIENT_LDFLAGS += $(shell freetype-config --libs)
+  endif
+
   ifeq ($(USE_CODEC_VORBIS),1)
     CLIENT_CFLAGS += -DUSE_CODEC_VORBIS
     CLIENT_LIBS += -lvorbisfile -lvorbis -logg
@@ -469,6 +489,11 @@ ifeq ($(PLATFORM),mingw32)
     endif
   endif
 
+  ifeq ($(USE_FREETYPE),1)
+    BASE_CFLAGS += -DBUILD_FREETYPE
+    BASE_CFLAGS += -I/include/freetype2
+  endif
+
   ifeq ($(USE_CODEC_VORBIS),1)
     CLIENT_CFLAGS += -DUSE_CODEC_VORBIS
   endif
@@ -490,6 +515,10 @@ ifeq ($(PLATFORM),mingw32)
   CLIENT_LDFLAGS = -mwindows
   CLIENT_LIBS = -lgdi32 -lole32 -lopengl32
 
+  ifeq ($(USE_FREETYPE),1)
+    CLIENT_LDFLAGS += -lfreetype
+  endif
+
   ifeq ($(USE_CURL),1)
     CLIENT_CFLAGS += -DUSE_CURL
     CLIENT_CFLAGS += $(CURL_CFLAGS)
diff --git a/assets/ttf/DejaVuSans-Bold.ttf b/assets/ttf/DejaVuSans-Bold.ttf
new file mode 100644
index 0000000..c0d8e5e
Binary files /dev/null and b/assets/ttf/DejaVuSans-Bold.ttf differ
diff --git a/assets/ui/help-jbo.txt b/assets/ui/help-jbo.txt
new file mode 100644
index 0000000..bd4c6a3
--- /dev/null
+++ b/assets/ui/help-jbo.txt
@@ -0,0 +1,135 @@
+{
+  "^3Welcome^7"
+  {
+    "In this section you will find a summary of major changes since 1.1. It is "
+    "not a complete list. In general, all things have been tweaked for balance in "
+    "some way.\n\n"
+    "We hope you enjoy playing. Your support gives us valuable data and "
+    "feedback as we work to bring you Tremulous 1.2. Please report all bugs. Thank "
+    "you."
+  }
+  "Alien Healing"
+  {
+    "The most important change for Alien players to know is that their healing "
+    "rate is slower away from creep. To counter this, healing near Boosters "
+    "and Basilisks is greatly accelerated.\n\n"
+    "Watch the health cross icon on your "
+    "HUD to see what your healing rate is. If the icon glows, you are on "
+    "creep. If you are near a booster or basilisk, you will see two "
+    "(2X healing) or four (3X healing) barbs around the health cross."
+  }
+  "Build-point Changes"
+  {
+    "Structures destroyed by enemy players will not immediately become available "
+    "for reuse, but instead enter a queue. Build points will gradually leave the "
+    "queue to become available again, at a rate proportional to the amount of "
+    "points in the queue.\n\n Repeaters can be built at any stage and come with 20 "
+    "BP that can only be used nearby to facilitate making small outposts. Aliens "
+    "do not have a structure that provides additional buildpoints, but they have 150 "
+    "overall BP to compensate."
+  }
+  "Marked Deconstruction"
+  {
+    "The deconstruction method has changed. Buildables are no longer instantly "
+    "deconstructed. Instead, a deconstruct mark appears on the health bar. "
+    "Go ahead and build a new buildable somewhere else and the old one will "
+    "be removed automatically. Buildables that are about to be removed by "
+    "constructing the selected buildable glow red."
+  }
+  "Alien Buildables"
+  {
+    "Nearly useless in 1.1, Barricades now have more health, are cheaper to "
+    "build, and will shrink to allow Aliens to pass over them. Acid tubes "
+    "will fire from behind barricades, providing a formidable defense. "
+    "Experiment with blocking off hallways and building staged defenses, but "
+    "keep in mind that low ceilings will prevent Tyrants from returning inside "
+    "the base. Hives are also much improved to become worth building in stage 3."
+  }
+  "Human Buildables"
+  {
+    "Turrets now have a small spin up delay before firing, but they have "
+    "increased range and damage output.\n\n"
+    "To protect against small Aliens getting inside "
+    "the base, build Tesla Generators at Stage 3. Tesla Generators no longer "
+    "require the Defense Computer to function. Instead, the Defense Computer "
+    "will automatically repair Human buildables. Tesla Generators can fire "
+    "over turrets. "
+  }
+  "Human Weapons"
+  {
+    "Most of the human projeciles have a small volume now, making them more "
+    "effective against smaller targets.\n"
+    "The Lucifer Cannon projectile can be fired faster but now takes longer "
+    "to charge. You will be able to hear your teammates overcharge "
+    "their Lucifer Cannon.\n"
+    "The Flamer projectile now gains more of the velocity of its wielder, "
+    "making it easier to chase down aliens without burning yourself to a "
+    "crisp. Other weapons also have smaller changes."
+  }
+  "Lag Correction"
+  {
+    "While the Tremulous implementation of Neil Toronto's unlagged is "
+    "becoming widely accepted, we also implement client-side improvements "
+    "not possible in 1.1 servers. For those who insist on leading their "
+    "attacks, setting cg_unlagged to 0 will disable backward reconcilliation "
+    "on your hitscan weapons."
+  }
+  "Sprint"
+  {
+    "The sprint bind has changed from \"boost\" to \"+button8\"; you can bind it "
+    "in the options menu or in the console (\\bind shift +button8). Now, instead "
+    "of tapping the button while moving to start sprinting, just hold it down "
+    "and let go to stop. Alternately, you can change this to a toggle behavior "
+    "with cg_sprintToggle. \n\n"
+  }
+  "Dodge"
+  {
+    "Humans also have a new movement ability: dodge. You can bind it in the "
+    "options menu or the console (\\bind shift +button6). When strafing or "
+    "walking backwards, press the dodge key to make a quick, low jump. You "
+    "can bind this to the same key as sprint in the console with \\bind shift "
+    "\"+button8; +button6\""
+  }
+  "Headshots"
+  {
+    "Headshots on unarmored humans only cause 150% damage. Battlesuit and "
+    "helmet protection have been reduced so headshot damage remains the same."
+  }
+  "Dretch"
+  {
+    "Dretches are slightly faster and can now damage any human structure while it "
+    "is still building, but can no longer damage turrets and teslas that "
+    "have been completed."
+  }
+  "Basilisk"
+  {
+    "Basilisks provide regeneration boosting auras to nearby teammates: 2x "
+    "from regular and 3x from advanced basilisks. Their footsteps are also "
+    "silent for greater stealth."
+  }
+  "Marauder"
+  {
+    "The Adv. Marauder's electric shock damage is no longer split between its "
+    "targets, making it more effective against large groups of humans and "
+    "buildables. Targets are now chosen slightly differently: instead of "
+    "each new chain section originating from the previous target, it will "
+    "originate from the first target."
+  }
+  "Dragoon"
+  {
+    "Advanced dragoons are now available at stage 2. Both dragoons have the "
+    "range of their chomp attacks lowered, but their pounce attacks are much "
+    "more useful. Try to use pounce to pin a human to the wall before chomping."
+  }
+  "Tyrant"
+  {
+    "The Tyrant is now a weaker class as its health has been lowered and "
+    "turret damage is greater. To counter this, Tyrants can charge for longer "
+    "periods of time, hit targets multiple times in a single charge, "
+    "and crush any Humans they land on top of. Trample charge does not "
+    "instantly release when full but can be held for two seconds. Trample "
+    "attacks on a human pinned against a wall are VERY powerful. Use this to "
+    "your advantage. The Tyrant's healing aura has been removed; find a "
+    "booster or a basilisk to heal faster."
+  }
+}
diff --git a/assets/ui/ingame.menu b/assets/ui/ingame.menu
index 808287e..f2744a5 100644
--- a/assets/ui/ingame.menu
+++ b/assets/ui/ingame.menu
@@ -14,6 +14,9 @@
     font "fonts/font" 26        // font
     smallFont "fonts/smallfont" 20        // font
     bigFont "fonts/bigfont" 34        // font
+    dynFont "ttf/DejaVuSans-Bold.ttf" 26        // font
+    smallDynFont "ttf/DejaVuSans-Bold.ttf" 20      // font
+    bigDynFont "ttf/DejaVuSans-Bold.ttf" 34      // font
     cursor "ui/assets/3_cursor3"      // cursor
     gradientBar "ui/assets/gradientbar2.tga"  // gradient bar
     itemFocusSound "sound/misc/menu2.wav"   // sound for item getting focus (via keyboard or mouse )
diff --git a/assets/ui/loading.menu b/assets/ui/loading.menu
index b877ce9..5d22a90 100644
--- a/assets/ui/loading.menu
+++ b/assets/ui/loading.menu
@@ -46,6 +46,9 @@
     font "fonts/font" 26        // font
     smallFont "fonts/smallfont" 20      // font
     bigFont "fonts/bigfont" 34      // font
+    dynFont "ttf/DejaVuSans-Bold.ttf" 26        // font
+    smallDynFont "ttf/DejaVuSans-Bold.ttf" 20      // font
+    bigDynFont "ttf/DejaVuSans-Bold.ttf" 34      // font
   }
 
   menuDef
diff --git a/assets/ui/main.menu b/assets/ui/main.menu
index 0c2a400..4be9998 100644
--- a/assets/ui/main.menu
+++ b/assets/ui/main.menu
@@ -6,6 +6,9 @@
     font "fonts/font" 26        // font
     smallFont "fonts/smallfont" 20        // font
     bigFont "fonts/bigfont" 34        // font
+    dynFont "ttf/DejaVuSans-Bold.ttf" 26        // font
+    smallDynFont "ttf/DejaVuSans-Bold.ttf" 20      // font
+    bigDynFont "ttf/DejaVuSans-Bold.ttf" 34      // font
     cursor "ui/assets/3_cursor3"      // cursor
     gradientBar "ui/assets/gradientbar2.tga"  // gradient bar
     itemFocusSound "sound/misc/menu2.wav"   // sound for item getting focus (via keyboard or mouse )
diff --git a/po/jbo.po b/po/jbo.po
new file mode 100644
index 0000000..f4d7748
--- /dev/null
+++ b/po/jbo.po
@@ -0,0 +1,4263 @@
+# Lojban translation for Tremulous.
+# Copyright (C) 2010 Byron James Johnson
+# This file is distributed under the same license as the Tremulous package.
+# Byron James Johnson <krabbykrap@gmail.com>, 2010.
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: Tremulous 1.2\n"
+"Report-Msgid-Bugs-To: krabbykrap@gmail.com\n"
+"POT-Creation-Date: 2010-10-16 01:18+0000\n"
+"PO-Revision-Date: 2010-10-16 01:18+000\n"
+"Last-Translator: Byron James Johnson <krabbykrap@gmail.com>\n"
+"Language-Team: Lojban\n"
+"Language: \n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+
+#: src/cgame/cg_attachment.c:93 src/cgame/cg_attachment.c:156
+#: src/cgame/cg_attachment.c:204
+msgid "ERROR: Invalid attachmentType_t in attachment\n"
+msgstr ""
+
+#: src/cgame/cg_buildable.c:178 src/cgame/cg_buildable.c:269
+#: src/cgame/cg_players.c:115 src/cgame/cg_weapons.c:111
+#: src/cgame/cg_weapons.c:547
+#, possible-c-format
+msgid "File %s is %s\n"
+msgstr ""
+
+#: src/cgame/cg_buildable.c:234 src/cgame/cg_weapons.c:173
+#, possible-c-format
+msgid "Error parsing animation file: %s\n"
+msgstr ""
+
+#: src/cgame/cg_buildable.c:300
+#, possible-c-format
+msgid "Error parsing sound file: %s\n"
+msgstr ""
+
+#: src/cgame/cg_buildable.c:346
+#, possible-c-format
+msgid "WARNING: failed to load animation file %s\n"
+msgstr ""
+
+#: src/cgame/cg_buildable.c:351
+#, possible-c-format
+msgid "WARNING: failed to load sound file %s\n"
+msgstr ""
+
+#: src/cgame/cg_buildable.c:408 src/cgame/cg_players.c:845
+#: src/cgame/cg_weapons.c:813
+#, possible-c-format
+msgid "Bad animation number: %i"
+msgstr ""
+
+#: src/cgame/cg_buildable.c:420 src/cgame/cg_players.c:853
+#: src/cgame/cg_weapons.c:821
+#, possible-c-format
+msgid "Anim: %i\n"
+msgstr ""
+
+#: src/cgame/cg_buildable.c:441
+#, possible-c-format
+msgid "newAnimation: %d lf->animationNumber: %d lf->animation: %d\n"
+msgstr ""
+
+#: src/cgame/cg_buildable.c:450
+#, possible-c-format
+msgid "Sound for animation %d for a %s\n"
+msgstr ""
+
+#: src/cgame/cg_buildable.c:823
+#, possible-c-format
+msgid "CG_BuildableStatusParse: unknown token %s in %s\n"
+msgstr ""
+
+#: src/cgame/cg_consolecmds.c:180
+#, possible-c-format
+msgid "Listed %2d clients\n"
+msgstr ""
+
+#: src/cgame/cg_draw.c:1384 src/cgame/cg_draw.c:1390
+#, possible-c-format
+msgid "(Stage %d)"
+msgstr ""
+
+#: src/cgame/cg_draw.c:1438 src/cgame/cg_draw.c:1454
+#, possible-c-format
+msgid "Stage %d"
+msgstr ""
+
+#: src/cgame/cg_draw.c:1440
+#, possible-c-format
+msgid "Stage %d, 1 frag for next stage"
+msgstr ""
+
+#: src/cgame/cg_draw.c:1443
+#, possible-c-format
+msgid "Stage %d, %d frags for next stage"
+msgstr ""
+
+#: src/cgame/cg_draw.c:1456
+#, possible-c-format
+msgid "Stage %d, 1 credit for next stage"
+msgstr ""
+
+#: src/cgame/cg_draw.c:3201
+#, possible-c-format
+msgid "You are %d%s in the spawn queue"
+msgstr ""
+
+#: src/cgame/cg_draw.c:3208
+msgid "There are no spawns remaining"
+msgstr ""
+
+#: src/cgame/cg_draw.c:3210
+msgid "There is 1 spawn remaining"
+msgstr ""
+
+#: src/cgame/cg_draw.c:3212
+#, possible-c-format
+msgid "There are %d spawns remaining"
+msgstr ""
+
+#: src/cgame/cg_draw.c:3295
+msgid "Default HUD could not be found"
+msgstr ""
+
+#: src/cgame/cg_draw.c:3479
+msgid "CG_DrawActive: Undefined stereoView"
+msgstr ""
+
+#: src/cgame/cg_ents.c:903
+msgid "CG_InterpoateEntityPosition: cg.nextSnap == NULL"
+msgstr ""
+
+#: src/cgame/cg_ents.c:1012
+#, possible-c-format
+msgid "Entity %d entered PVS\n"
+msgstr ""
+
+#: src/cgame/cg_ents.c:1053
+#, possible-c-format
+msgid "Entity %d left PVS\n"
+msgstr ""
+
+#: src/cgame/cg_ents.c:1088
+#, possible-c-format
+msgid "Bad entity type: %i\n"
+msgstr ""
+
+#: src/cgame/cg_event.c:54
+msgid "CG_Obituary: target out of range"
+msgstr ""
+
+#: src/cgame/cg_event.c:199 src/cgame/cg_event.c:364
+#: src/cgame/cg_players.c:708 src/cgame/cg_players.c:713
+#: src/cgame/cg_players.c:716 src/cgame/cg_players.c:719
+#, possible-c-format
+msgid "%s"
+msgstr ""
+
+#: src/cgame/cg_event.c:222
+msgid "was sawn by"
+msgstr ""
+
+#: src/cgame/cg_event.c:225
+msgid "was blasted by"
+msgstr ""
+
+#: src/cgame/cg_event.c:228
+msgid "was machinegunned by"
+msgstr ""
+
+#: src/cgame/cg_event.c:231
+msgid "was chaingunned by"
+msgstr ""
+
+#: src/cgame/cg_event.c:234
+msgid "was gunned down by"
+msgstr ""
+
+#: src/cgame/cg_event.c:237
+msgid "was pulse rifled by"
+msgstr ""
+
+#: src/cgame/cg_event.c:240
+msgid "was mass driven by"
+msgstr ""
+
+#: src/cgame/cg_event.c:243
+msgid "was lasgunned by"
+msgstr ""
+
+#: src/cgame/cg_event.c:246
+msgid "was grilled by"
+msgstr ""
+
+#: src/cgame/cg_event.c:247 src/cgame/cg_event.c:251
+msgid "'s flamer"
+msgstr ""
+
+#: src/cgame/cg_event.c:250
+msgid "was toasted by"
+msgstr ""
+
+#: src/cgame/cg_event.c:254
+msgid "felt the full force of"
+msgstr ""
+
+#: src/cgame/cg_event.c:255 src/cgame/cg_event.c:259
+msgid "'s lucifer cannon"
+msgstr ""
+
+#: src/cgame/cg_event.c:258
+msgid "was caught in the fallout of"
+msgstr ""
+
+#: src/cgame/cg_event.c:262
+msgid "couldn't escape"
+msgstr ""
+
+#: src/cgame/cg_event.c:263
+msgid "'s grenade"
+msgstr ""
+
+#: src/cgame/cg_event.c:267
+msgid "should leave"
+msgstr ""
+
+#: src/cgame/cg_event.c:268
+msgid "'s buildings alone"
+msgstr ""
+
+#: src/cgame/cg_event.c:271
+msgid "was bitten by"
+msgstr ""
+
+#: src/cgame/cg_event.c:274
+msgid "was swiped by"
+msgstr ""
+
+#: src/cgame/cg_event.c:275 src/cgame/cg_event.c:281 src/cgame/cg_event.c:287
+#: src/cgame/cg_event.c:293 src/cgame/cg_event.c:299 src/cgame/cg_event.c:305
+#: src/cgame/cg_event.c:311 src/cgame/cg_event.c:317 src/cgame/cg_event.c:332
+#, possible-c-format
+msgid "'s %s"
+msgstr ""
+
+#: src/cgame/cg_event.c:280
+msgid "was clawed by"
+msgstr ""
+
+#: src/cgame/cg_event.c:286
+msgid "was zapped by"
+msgstr ""
+
+#: src/cgame/cg_event.c:292
+msgid "was chomped by"
+msgstr ""
+
+#: src/cgame/cg_event.c:298
+msgid "was pounced upon by"
+msgstr ""
+
+#: src/cgame/cg_event.c:304
+msgid "was sniped by"
+msgstr ""
+
+#: src/cgame/cg_event.c:310
+msgid "was mauled by"
+msgstr ""
+
+#: src/cgame/cg_event.c:316
+msgid "should have gotten out of the way of"
+msgstr ""
+
+#: src/cgame/cg_event.c:322
+msgid "was crushed under"
+msgstr ""
+
+#: src/cgame/cg_event.c:323
+msgid "'s weight"
+msgstr ""
+
+#: src/cgame/cg_event.c:327
+msgid "should have used a medkit against"
+msgstr ""
+
+#: src/cgame/cg_event.c:328
+msgid "'s poison"
+msgstr ""
+
+#: src/cgame/cg_event.c:331
+msgid "was gassed by"
+msgstr ""
+
+#: src/cgame/cg_event.c:339
+msgid "tried to invade"
+msgstr ""
+
+#: src/cgame/cg_event.c:340
+msgid "'s personal space"
+msgstr ""
+
+#: src/cgame/cg_event.c:343
+msgid "was killed by"
+msgstr ""
+
+#: src/cgame/cg_event.c:351
+msgid "TEAMMATE "
+msgstr ""
+
+#: src/cgame/cg_event.c:355
+msgid "You killed "
+msgstr ""
+
+#: src/cgame/cg_event.c:484
+#, possible-c-format
+msgid "ent:%3i  event:%3i %s\n"
+msgstr ""
+
+#: src/cgame/cg_event.c:904
+msgid "The Overmind is under attack!"
+msgstr ""
+
+#: src/cgame/cg_event.c:912
+msgid "The Overmind is dying!"
+msgstr ""
+
+#: src/cgame/cg_event.c:920
+msgid "Our base is under attack!"
+msgstr ""
+
+#: src/cgame/cg_event.c:932
+msgid "The Overmind needs spawns!"
+msgstr ""
+
+#: src/cgame/cg_event.c:992
+#, possible-c-format
+msgid "Unknown event: %i"
+msgstr ""
+
+#: src/cgame/cg_main.c:963
+#, possible-c-format
+msgid "CG_ConfigString: bad index: %i"
+msgstr ""
+
+#: src/cgame/cg_main.c:1025 src/cgame/cg_main.c:1301
+#, possible-c-format
+msgid "menu file not found: %s, using default\n"
+msgstr ""
+
+#: src/cgame/cg_main.c:1031 src/cgame/cg_main.c:1310
+#, possible-c-format
+msgid "menu file too large: %s is %i, max allowed is %i"
+msgstr ""
+
+#: src/cgame/cg_main.c:1305
+msgid "default menu file not found: ui/hud.txt, unable to continue!\n"
+msgstr ""
+
+#: src/cgame/cg_main.c:1345
+#, possible-c-format
+msgid "UI menu load time = %d milli seconds\n"
+msgstr ""
+
+#: src/cgame/cg_main.c:1510
+msgid "Ready"
+msgstr ""
+
+#: src/cgame/cg_main.c:1791
+#, possible-c-format
+msgid "Client/Server game mismatch: %s/%s"
+msgstr ""
+
+#: src/cgame/cg_main.c:1886
+msgid "WARNING: voipString overflowed\n"
+msgstr ""
+
+#: src/cgame/cg_marks.c:73
+msgid "CG_FreeLocalEntity: not active"
+msgstr ""
+
+#: src/cgame/cg_marks.c:153
+msgid "CG_ImpactMark called with <= 0 radius"
+msgstr ""
+
+#: src/cgame/cg_particles.c:253
+msgid "ERROR: a particle with velocityType normal has no normal\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:427
+#, possible-c-format
+msgid "PE %s created\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:452
+msgid "ERROR: a particle system has not been registered yet\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:474
+#, possible-c-format
+msgid "PS %s created\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:548
+#, possible-c-format
+msgid "Registered particle system %s\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:557
+#, possible-c-format
+msgid "ERROR: failed to register particle system %s\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:734
+msgid "ERROR: 'shader' not allowed in conjunction with 'model'\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:764
+msgid "ERROR: 'model' not allowed in conjunction with 'shader'\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:1126 src/cgame/cg_particles.c:1248
+#: src/cgame/cg_particles.c:1270 src/cgame/cg_trails.c:769
+#: src/cgame/cg_trails.c:791
+msgid "ERROR: missing '}'\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:1276 src/cgame/cg_particles.c:1282
+#: src/cgame/cg_trails.c:797 src/cgame/cg_trails.c:803
+msgid "ERROR: missing '{'\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:1384
+#, possible-c-format
+msgid "ERROR: unknown token '%s' in particle\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:1434
+msgid "ERROR: failed to parse particle\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:1440
+#, possible-c-format
+msgid "ERROR: ejector has > %d particles\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:1445
+#, possible-c-format
+msgid "ERROR: maximum number of particles (%d) reached\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:1522
+#, possible-c-format
+msgid "ERROR: unknown token '%s' in particle ejector\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:1558
+msgid "ERROR: failed to parse particle ejector\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:1568
+msgid "ERROR: ejector with 'count infinite' potentially has zero period\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:1574
+#, possible-c-format
+msgid "ERROR: particle system has > %d ejectors\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:1579
+#, possible-c-format
+msgid "ERROR: maximum number of particle ejectors (%d) reached\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:1599
+#, possible-c-format
+msgid "Parsed particle system %s\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:1605
+#, possible-c-format
+msgid "ERROR: unknown token '%s' in particle system %s\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:1639
+#, possible-c-format
+msgid "ERROR: particle file %s is %s\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:1668
+#, possible-c-format
+msgid "ERROR: a particle system is already named %s\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:1677
+#, possible-c-format
+msgid "ERROR: %s: failed to parse particle system %s\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:1686
+#, possible-c-format
+msgid "ERROR: maximum number of particle systems (%d) reached\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:1697
+msgid "ERROR: unamed particle system\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:1709
+msgid "ERROR: particle system already named\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:1766 src/cgame/cg_trails.c:1184
+#, possible-c-format
+msgid "...loading '%s'\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:1795
+#, possible-c-format
+msgid "WARNING: failed to find child %s\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:1820
+#, possible-c-format
+msgid "WARNING: failed to find onDeath system %s\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:1836
+msgid "WARNING: tried to modify a NULL particle system\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:1866
+msgid "WARNING: tried to destroy a NULL particle system\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:1871
+msgid "PS destroyed\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:1898
+msgid "WARNING: tried to test a NULL particle system\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:1904
+msgid "WARNING: tried to test an invalid particle system\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:1990
+#, possible-c-format
+msgid "PS %s garbage collected\n"
+msgstr ""
+
+#: src/cgame/cg_players.c:72
+#, possible-c-format
+msgid "Unknown custom sound: %s"
+msgstr ""
+
+#: src/cgame/cg_players.c:115 src/cgame/cg_trails.c:1067
+#: src/cgame/cg_weapons.c:111 src/cgame/cg_weapons.c:547
+msgid "empty"
+msgstr ""
+
+#: src/cgame/cg_players.c:115 src/cgame/cg_trails.c:1067
+#: src/cgame/cg_weapons.c:111 src/cgame/cg_weapons.c:547
+msgid "too long"
+msgstr ""
+
+#: src/cgame/cg_players.c:159
+#, possible-c-format
+msgid "Bad footsteps parm in %s: %s\n"
+msgstr ""
+
+#: src/cgame/cg_players.c:215
+#, possible-c-format
+msgid "unknown token '%s' is %s\n"
+msgstr ""
+
+#: src/cgame/cg_players.c:288 src/cgame/cg_players.c:368
+#, possible-c-format
+msgid "Error parsing animation file: %s"
+msgstr ""
+
+#: src/cgame/cg_players.c:394
+#, possible-c-format
+msgid "Leg skin load failure: %s\n"
+msgstr ""
+
+#: src/cgame/cg_players.c:399
+#, possible-c-format
+msgid "Torso skin load failure: %s\n"
+msgstr ""
+
+#: src/cgame/cg_players.c:404
+#, possible-c-format
+msgid "Head skin load failure: %s\n"
+msgstr ""
+
+#: src/cgame/cg_players.c:414
+#, possible-c-format
+msgid "Non-segmented skin load failure: %s\n"
+msgstr ""
+
+#: src/cgame/cg_players.c:437
+#, possible-c-format
+msgid "Failed to load animation file %s\n"
+msgstr ""
+
+#: src/cgame/cg_players.c:449 src/cgame/cg_players.c:457
+#: src/cgame/cg_players.c:465 src/cgame/cg_players.c:475
+#, possible-c-format
+msgid "Failed to load model file %s\n"
+msgstr ""
+
+#: src/cgame/cg_players.c:483
+#, possible-c-format
+msgid "Failed to load skin file: %s : %s\n"
+msgstr ""
+
+#: src/cgame/cg_players.c:506
+#, possible-c-format
+msgid "CG_RegisterClientModelname( %s, %s ) failed"
+msgstr ""
+
+#: src/cgame/cg_players.c:1113 src/cgame/cg_players.c:1360
+msgid "Bad player movement angle"
+msgstr ""
+
+#: src/cgame/cg_players.c:1895
+msgid "Bad clientNum on player entity"
+msgstr ""
+
+#: src/cgame/cg_players.c:2169
+#, possible-c-format
+msgid "Bad corpseNum on corpse entity: %d"
+msgstr ""
+
+#: src/cgame/cg_playerstate.c:235
+msgid "WARNING: changed predicted event\n"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:94
+#, possible-c-format
+msgid "[skipnotify]CG_ParseTeamInfo: bad client number: %d\n"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:238
+msgid "We have evolved!"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:252
+msgid "Reinforcements have arrived!"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:473
+msgid "Unknown item"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:478
+msgid ""
+"The alien team has too many players. Please wait until slots become "
+"available or join the human team."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:480
+msgid "The alien team has too many players"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:485
+msgid ""
+"The human team has too many players. Please wait until slots become "
+"available or join the alien team."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:487
+msgid "The human team has too many players"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:492
+msgid "The alien team is locked. You cannot join the aliens at this time."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:494
+msgid "The alien team is locked"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:499
+msgid "The human team is locked. You cannot join the humans at this time."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:501
+msgid "The human team is locked"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:506
+msgid ""
+"The maximum number of playing clients has been reached. Please wait until "
+"slots become available."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:508
+msgid "No free player slots"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:513
+msgid "You must wait until the warmup time is finished before joining a team. "
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:515
+msgid "You cannot join a team during warmup."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:520
+msgid "You cannot leave the Alien team until your build timer has expired."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:522 src/cgame/cg_servercmds.c:529
+msgid "You cannot change teams until your build timer expires"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:527
+msgid "You cannot leave the Human team until your build timer has expired."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:541
+msgid "Cheats are not enabled on this server"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:546
+msgid ""
+"Cheats are not enabled on this server, so you may not use this command while "
+"on a team"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:554
+msgid "Join a team first"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:561
+msgid "You can only use this command when spectating"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:567
+msgid "Must be alien to use this command"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:573
+msgid "Must be human to use this command"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:579
+msgid "Must be living to use this command"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:587
+msgid ""
+"There is no room to build here. Move until the structure turns translucent "
+"green, indicating a valid build location."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:589
+msgid "There is no room to build here"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:594
+msgid ""
+"Cannot build on this surface. The surface is too steep or unsuitable for "
+"building. Please choose another site for this structure."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:597
+msgid "Cannot build on this surface"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:603
+msgid "You cannot build that structure"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:609
+msgid ""
+"This action would remove your team's last spawn point, which often quickly "
+"results in a loss. Try building more spawns."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:612
+msgid "You may not deconstruct the last spawn"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:616
+msgid ""
+"Neither team has prevailed after a certain time and the game has entered "
+"Sudden Death. During Sudden Death building is not allowed."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:619
+msgid "Cannot build during Sudden Death"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:624
+msgid ""
+"Your teammates have lost faith in your ability to build for the team. You "
+"will not be allowed to build until your team votes to reinstate your "
+"building rights."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:627
+msgid "Your building rights have been revoked"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:632
+msgid ""
+"Your team has decided to admit defeat and concede the game:traitors and "
+"cowards are not allowed to build."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:635
+msgid "Building is denied to traitorous cowards"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:642
+msgid ""
+"There is no power remaining. Free up power by marking existing buildable "
+"objects."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:645
+msgid ""
+"There is no power remaining. Free up power by deconstructing existing "
+"buildable objects."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:647
+msgid "There is no power remaining"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:652
+msgid ""
+"This buildable is not powered. Build a Reactor and/or Repeater in order to "
+"power it."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:654
+msgid "This buildable is not powered"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:659
+msgid ""
+"There can only be one Reactor. Deconstruct the existing one if you wish to "
+"move it."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:661
+msgid "There can only be one Reactor"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:666
+msgid ""
+"There is no power here. If available, a Repeater may be used to transmit "
+"power to this location."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:668
+msgid "There is no power here"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:673
+msgid ""
+"There is no Defense Computer. A Defense Computer is needed to build this."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:675
+msgid "There is no Defense Computer"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:680
+msgid "This area already has power. A Repeater is not required here."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:681
+msgid "This area already has power"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:686
+msgid ""
+"You have no room to carry this. Please sell any conflicting upgrades before "
+"purchasing this item."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:688
+msgid "You have no room to carry this"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:693
+msgid ""
+"Insufficient funds. You do not have enough credits to perform this action."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:695
+msgid "Insufficient funds"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:700
+msgid ""
+"You already hold this item. It is not possible to carry multiple items of "
+"the same type."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:702
+msgid "You already hold this item"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:707
+msgid ""
+"You must be near a powered Armoury in order to purchase weapons, upgrades or "
+"ammunition."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:709
+msgid "You must be near a powered Armoury"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:714
+msgid ""
+"You must be near a Reactor or a powered Armoury or Repeater in order to "
+"purchase energy ammunition."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:716
+msgid "You must be near a Reactor or a powered Armoury or Repeater"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:721
+msgid ""
+"There is not enough room here to put on a Battle Suit. Make sure you have "
+"enough head room to climb in."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:723
+msgid "Not enough room here to put on a Battle Suit"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:728
+msgid ""
+"There is not enough room here to take off your Battle Suit. Make sure you "
+"have enough head room to climb out."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:730
+msgid "Not enough room here to take off your Battle Suit"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:735
+msgid ""
+"You are not allowed to buy or sell weapons until your build timer has "
+"expired."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:737
+msgid "You can not buy or sell weapons until your build timer expires"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:743
+msgid "You must be dead to use the class command"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:748
+msgid "Unknown starting item"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:755
+msgid ""
+"There is no creep here. You must build near existing Eggs or the Overmind. "
+"Alien structures will not support themselves."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:757
+msgid "There is no creep here"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:762
+msgid ""
+"There is no Overmind. An Overmind must be built to control the structure you "
+"tried to place."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:764 src/cgame/cg_servercmds.c:799
+msgid "There is no Overmind"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:769
+msgid ""
+"There can only be one Overmind. Deconstruct the existing one if you wish to "
+"move it."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:771
+msgid "There can only be one Overmind"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:776
+msgid ""
+"The Overmind cannot control any more structures. Deconstruct existing "
+"structures to build more."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:778
+msgid "The Overmind cannot control any more structures"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:783
+msgid ""
+"There is no room to evolve here. Move away from walls or other nearby "
+"objects and try again."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:785
+msgid "There is no room to evolve here"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:790
+msgid ""
+"This location is too close to the enemy to evolve. Move away from the "
+"enemy's presence and try again."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:792
+msgid "This location is too close to the enemy to evolve"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:797
+msgid ""
+"There is no Overmind. An Overmind must be built to allow you to upgrade."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:804
+msgid "You cannot evolve until your build timer has expired."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:805
+msgid "You cannot evolve until your build timer expires"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:819
+#, possible-c-format
+msgid "You cannot evolve into a %s"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:825
+msgid "You cannot evolve while wallwalking"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:830
+msgid "Unknown class"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:835
+#, possible-c-format
+msgid "You cannot spawn as a %s"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:841
+#, possible-c-format
+msgid "The %s is not allowed"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:847
+#, possible-c-format
+msgid "The %s is not allowed at Stage %d"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:854
+#, possible-c-format
+msgid "cgame: debug: no such menu %d\n"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:986
+#, possible-c-format
+msgid "%sPrivate message from: "
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:1032
+#, possible-c-format
+msgid "[skipnotify]WARNING: could not find voice \"%s\"\n"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:1038
+#, possible-c-format
+msgid "[skipnotify]WARNING: could not find command %d in voice \"%s\"\n"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:1045
+#, possible-c-format
+msgid ""
+"[skipnotify]WARNING: could not find track %d for command %d in voice \"%s\"\n"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:1295
+#, possible-c-format
+msgid "Unknown client game command: %s\n"
+msgstr ""
+
+#: src/cgame/cg_snapshot.c:137
+msgid "CG_TransitionSnapshot: NULL cg.snap"
+msgstr ""
+
+#: src/cgame/cg_snapshot.c:140
+msgid "CG_TransitionSnapshot: NULL cg.nextSnap"
+msgstr ""
+
+#: src/cgame/cg_snapshot.c:262
+#, possible-c-format
+msgid "WARNING: CG_ReadNextSnapshot: way out of range, %i > %i"
+msgstr ""
+
+#: src/cgame/cg_snapshot.c:340
+msgid "CG_ProcessSnapshots: n < cg.latestSnapshotNum"
+msgstr ""
+
+#: src/cgame/cg_snapshot.c:384
+msgid "CG_ProcessSnapshots: Server time went backwards"
+msgstr ""
+
+#: src/cgame/cg_snapshot.c:397
+msgid "CG_ProcessSnapshots: cg.snap == NULL"
+msgstr ""
+
+#: src/cgame/cg_snapshot.c:406
+msgid "CG_ProcessSnapshots: cg.nextSnap->serverTime <= cg.time"
+msgstr ""
+
+#: src/cgame/cg_trails.c:715
+msgid "WARNING: too many segments in trail beam\n"
+msgstr ""
+
+#: src/cgame/cg_trails.c:873
+#, possible-c-format
+msgid "ERROR: unknown textureType clamp \"%s\"\n"
+msgstr ""
+
+#: src/cgame/cg_trails.c:885
+#, possible-c-format
+msgid "ERROR: unknown textureType \"%s\"\n"
+msgstr ""
+
+#: src/cgame/cg_trails.c:901
+msgid "ERROR: too many jitters\n"
+msgstr ""
+
+#: src/cgame/cg_trails.c:931
+#, possible-c-format
+msgid "ERROR: unknown token '%s' in trail beam\n"
+msgstr ""
+
+#: src/cgame/cg_trails.c:986
+msgid "ERROR: failed to parse trail beam\n"
+msgstr ""
+
+#: src/cgame/cg_trails.c:992
+#, possible-c-format
+msgid "ERROR: trail system has > %d beams\n"
+msgstr ""
+
+#: src/cgame/cg_trails.c:997
+#, possible-c-format
+msgid "ERROR: maximum number of trail beams (%d) reached\n"
+msgstr ""
+
+#: src/cgame/cg_trails.c:1026
+#, possible-c-format
+msgid "Parsed trail system %s\n"
+msgstr ""
+
+#: src/cgame/cg_trails.c:1032
+#, possible-c-format
+msgid "ERROR: unknown token '%s' in trail system %s\n"
+msgstr ""
+
+#: src/cgame/cg_trails.c:1066
+#, possible-c-format
+msgid "ERROR: trail file %s is %s\n"
+msgstr ""
+
+#: src/cgame/cg_trails.c:1095
+#, possible-c-format
+msgid "ERROR: a trail system is already named %s\n"
+msgstr ""
+
+#: src/cgame/cg_trails.c:1104
+#, possible-c-format
+msgid "ERROR: %s: failed to parse trail system %s\n"
+msgstr ""
+
+#: src/cgame/cg_trails.c:1113
+#, possible-c-format
+msgid "ERROR: maximum number of trail systems (%d) reached\n"
+msgstr ""
+
+#: src/cgame/cg_trails.c:1124
+msgid "ERROR: unamed trail system\n"
+msgstr ""
+
+#: src/cgame/cg_trails.c:1136
+msgid "ERROR: trail system already named\n"
+msgstr ""
+
+#: src/cgame/cg_trails.c:1220
+#, possible-c-format
+msgid "Registered trail system %s\n"
+msgstr ""
+
+#: src/cgame/cg_trails.c:1229
+#, possible-c-format
+msgid "ERROR: failed to register trail system %s\n"
+msgstr ""
+
+#: src/cgame/cg_trails.c:1263
+#, possible-c-format
+msgid "TB %s created\n"
+msgstr ""
+
+#: src/cgame/cg_trails.c:1270
+msgid "MAX_TRAIL_BEAMS\n"
+msgstr ""
+
+#: src/cgame/cg_trails.c:1291
+msgid "ERROR: a trail system has not been registered yet\n"
+msgstr ""
+
+#: src/cgame/cg_trails.c:1314
+#, possible-c-format
+msgid "TS %s created\n"
+msgstr ""
+
+#: src/cgame/cg_trails.c:1321
+msgid "MAX_TRAIL_SYSTEMS\n"
+msgstr ""
+
+#: src/cgame/cg_trails.c:1435
+#, possible-c-format
+msgid "TS %s expired (born %d, lives %d, now %d)\n"
+msgstr ""
+
+#: src/cgame/cg_trails.c:1441
+#, possible-c-format
+msgid "TS %s garbage collected\n"
+msgstr ""
+
+#: src/cgame/cg_trails.c:1482
+#, possible-c-format
+msgid "TS: %d  TB: %d\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:117
+msgid " or "
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:124
+#, possible-c-format
+msgid "^K^E^Y^7%s or %s"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:128
+#, possible-c-format
+msgid "^K^E^Y^7%s"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:133
+#, possible-c-format
+msgid "\"%s\" (unbound)"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:191 src/cgame/cg_tutorial.c:367
+#, possible-c-format
+msgid "Press %s to place the %s\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:196 src/cgame/cg_tutorial.c:372
+#, possible-c-format
+msgid "Press %s to cancel placing the %s\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:203 src/cgame/cg_tutorial.c:379
+#, possible-c-format
+msgid "Press %s to build a structure\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:214 src/cgame/cg_tutorial.c:390
+#, possible-c-format
+msgid "Press %s to unmark this structure\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:220 src/cgame/cg_tutorial.c:396
+#, possible-c-format
+msgid "Press %s to mark this structure\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:227 src/cgame/cg_tutorial.c:403
+#, possible-c-format
+msgid "Press %s to destroy this structure\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:235 src/cgame/cg_tutorial.c:277
+#: src/cgame/cg_tutorial.c:346
+#, possible-c-format
+msgid "Press %s to swipe\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:242 src/cgame/cg_tutorial.c:329
+#, possible-c-format
+msgid "Press %s to launch a projectile\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:246 src/cgame/cg_tutorial.c:262
+#: src/cgame/cg_tutorial.c:288
+#, possible-c-format
+msgid "Press %s to walk on walls\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:259
+msgid "Touch humans to damage them\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:274
+msgid "Touch humans to grab them\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:283
+#, possible-c-format
+msgid "Press %s to spray poisonous gas\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:300 src/cgame/cg_tutorial.c:323
+#, possible-c-format
+msgid "Press %s to bite\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:306
+#, possible-c-format
+msgid "Press %s to invoke an electrical attack\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:311
+#, possible-c-format
+msgid "Hold down %s then touch a wall to wall jump\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:334
+#, possible-c-format
+msgid "Hold down and release %s to pounce\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:350
+#, possible-c-format
+msgid "Hold down and release %s to trample\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:437
+#, possible-c-format
+msgid "Find an Armoury and press %s for more ammo\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:446
+#, possible-c-format
+msgid "Find a Reactor or Repeater and press %s for more ammo\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:466 src/cgame/cg_tutorial.c:473
+#: src/cgame/cg_tutorial.c:495
+#, possible-c-format
+msgid "Press %s to fire the %s\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:478
+#, possible-c-format
+msgid "Hold %s to zoom\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:484
+#, possible-c-format
+msgid "Hold %s to activate the %s\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:491
+#, possible-c-format
+msgid "Hold and release %s to fire a charged shot\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:510
+#, possible-c-format
+msgid "Press %s and "
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:513
+#, possible-c-format
+msgid "%s to select an upgrade\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:520
+#, possible-c-format
+msgid "Press %s to use the %s\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:529
+#, possible-c-format
+msgid "Press %s to use your %s\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:537
+msgid "You are blacking out. Stop sprinting to recover stamina.\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:542
+msgid "Your stamina is low. Stop sprinting to recover.\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:548
+#, possible-c-format
+msgid "Press %s to use this structure\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:553
+#, possible-c-format
+msgid "Press %s and any direction to sprint\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:557
+#, possible-c-format
+msgid "Press %s and back or strafe to dodge\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:572
+#, possible-c-format
+msgid "Press %s to leave spawn queue\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:576
+#, possible-c-format
+msgid "Press %s to spawn\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:582
+#, possible-c-format
+msgid "Press %s to join a team\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:590
+#, possible-c-format
+msgid "Press %s to switch to chase-cam spectator mode\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:594
+#, possible-c-format
+msgid "Press %s to return to free spectator mode\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:598
+#, possible-c-format
+msgid "Press %s or "
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:601
+#, possible-c-format
+msgid "%s to change player\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:607
+#, possible-c-format
+msgid "Press %s to follow a player\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:684
+#, possible-c-format
+msgid "Press %s to evolve\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:690
+msgid "Press ESC for the menu"
+msgstr ""
+
+#: src/cgame/cg_view.c:101 src/cgame/cg_view.c:180
+msgid "Can't register model\n"
+msgstr ""
+
+#: src/cgame/cg_view.c:1500
+#, possible-c-format
+msgid "cg.clientFrame:%i\n"
+msgstr ""
+
+#: src/cgame/cg_weapons.c:53
+#, possible-c-format
+msgid "Couldn't find upgrade %i"
+msgstr ""
+
+#: src/cgame/cg_weapons.c:213
+#, possible-c-format
+msgid "ERROR: missile model not found %s\n"
+msgstr ""
+
+#: src/cgame/cg_weapons.c:239
+#, possible-c-format
+msgid "ERROR: missile sprite not found %s\n"
+msgstr ""
+
+#: src/cgame/cg_weapons.c:298
+#, possible-c-format
+msgid "ERROR: missile particle system not found %s\n"
+msgstr ""
+
+#: src/cgame/cg_weapons.c:311
+#, possible-c-format
+msgid "ERROR: missile trail system not found %s\n"
+msgstr ""
+
+#: src/cgame/cg_weapons.c:324
+#, possible-c-format
+msgid "ERROR: muzzle particle system not found %s\n"
+msgstr ""
+
+#: src/cgame/cg_weapons.c:337
+#, possible-c-format
+msgid "ERROR: impact particle system not found %s\n"
+msgstr ""
+
+#: src/cgame/cg_weapons.c:362
+#, possible-c-format
+msgid "ERROR: impact mark shader not found %s\n"
+msgstr ""
+
+#: src/cgame/cg_weapons.c:514
+#, possible-c-format
+msgid "ERROR: unknown token '%s' in weapon section\n"
+msgstr ""
+
+#: src/cgame/cg_weapons.c:573
+msgid "ERROR: weapon mode section started without a declaration\n"
+msgstr ""
+
+#: src/cgame/cg_weapons.c:578
+msgid "ERROR: failed to parse weapon mode section\n"
+msgstr ""
+
+#: src/cgame/cg_weapons.c:613
+#, possible-c-format
+msgid "ERROR: weapon model not found %s\n"
+msgstr ""
+
+#: src/cgame/cg_weapons.c:644
+#, possible-c-format
+msgid "ERROR: 3rd person weapon model not found %s\n"
+msgstr ""
+
+#: src/cgame/cg_weapons.c:679
+#, possible-c-format
+msgid "ERROR: weapon icon not found %s\n"
+msgstr ""
+
+#: src/cgame/cg_weapons.c:704
+#, possible-c-format
+msgid "ERROR: weapon crosshair not found %s\n"
+msgstr ""
+
+#: src/cgame/cg_weapons.c:715
+#, possible-c-format
+msgid "ERROR: unknown token '%s'\n"
+msgstr ""
+
+#: src/cgame/cg_weapons.c:746
+#, possible-c-format
+msgid "Couldn't find weapon %i"
+msgstr ""
+
+#: src/cgame/cg_weapons.c:753 src/cgame/cg_weapons.c:758
+#, possible-c-format
+msgid "ERROR: failed to parse %s\n"
+msgstr ""
+
+#: src/cgame/cg_weapons.c:1701
+msgid "CG_FireWeapon: ent->weapon >= WP_NUM_WEAPONS"
+msgstr ""
+
+#: src/client/cl_avi.c:85
+msgid "Failed to write avi file\n"
+msgstr ""
+
+#: src/client/cl_avi.c:145
+msgid "ERROR: Top of chunkstack breached\n"
+msgstr ""
+
+#: src/client/cl_avi.c:165
+msgid "ERROR: Bottom of chunkstack breached\n"
+msgstr ""
+
+#: src/client/cl_avi.c:387
+#, possible-c-format
+msgid ""
+"WARNING: cl_aviFrameRate is not a divisor of the audio rate, suggest %d\n"
+msgstr ""
+
+#: src/client/cl_avi.c:399
+#, possible-c-format
+msgid "WARNING: Audio format of %d bit/%d channels not supported"
+msgstr ""
+
+#: src/client/cl_avi.c:409
+msgid ""
+"WARNING: Audio capture is not supported with OpenAL. Set s_useOpenAL to 0 "
+"for audio capture\n"
+msgstr ""
+
+#: src/client/cl_avi.c:531
+msgid "WARNING: Audio capture buffer overflow -- truncating\n"
+msgstr ""
+
+#: src/client/cl_avi.c:658
+#, possible-c-format
+msgid "Wrote %d:%d frames to %s\n"
+msgstr ""
+
+#: src/client/cl_cgame.c:151
+#, possible-c-format
+msgid "CL_GetSnapshot: truncated %i entities to %i\n"
+msgstr ""
+
+#: src/client/cl_cgame.c:239 src/client/cl_parse.c:494
+msgid "MAX_GAMESTATE_CHARS exceeded"
+msgstr ""
+
+#: src/client/cl_cgame.c:275
+msgid "CL_GetServerCommand: a reliable command was cycled out"
+msgstr ""
+
+#: src/client/cl_cgame.c:280
+msgid "CL_GetServerCommand: requested a command not received"
+msgstr ""
+
+#: src/client/cl_cgame.c:298
+#, possible-c-format
+msgid "Server disconnected - %s"
+msgstr ""
+
+#: src/client/cl_cgame.c:300
+msgid "Server disconnected\n"
+msgstr ""
+
+#: src/client/cl_cgame.c:311 src/client/cl_cgame.c:320
+msgid "bcs exceeded BIG_INFO_STRING"
+msgstr ""
+
+#: src/client/cl_cgame.c:746
+#, possible-c-format
+msgid "Bad cgame system trap: %ld"
+msgstr ""
+
+#: src/client/cl_cgame.c:785
+msgid "VM_Create on cgame failed"
+msgstr ""
+
+#: src/client/cl_cgame.c:804
+#, possible-c-format
+msgid "CL_InitCGame: %5.2f seconds\n"
+msgstr ""
+
+#: src/client/cl_cgame.c:970
+#, possible-c-format
+msgid "Mumble: Linking to Mumble application %s\n"
+msgstr ""
+
+#: src/client/cl_cin.c:160
+msgid "CIN_HandleForVideo: none free"
+msgstr ""
+
+#: src/client/cl_cin.c:1007
+msgid "HACK: approxmimating cinematic for Rage Pro or Voodoo\n"
+msgstr ""
+
+#: src/client/cl_cin.c:1274
+msgid "finished cinematic\n"
+msgstr ""
+
+#: src/client/cl_console.c:115
+msgid "usage: condump <filename>\n"
+msgstr ""
+
+#: src/client/cl_console.c:119
+#, possible-c-format
+msgid "Dumped console text to %s.\n"
+msgstr ""
+
+#: src/client/cl_console.c:124 src/client/cl_main.c:698
+msgid "ERROR: couldn't open.\n"
+msgstr ""
+
+#: src/client/cl_curl.c:73
+#, possible-c-format
+msgid "Can't load symbol %s\n"
+msgstr ""
+
+#: src/client/cl_curl.c:79
+#, possible-c-format
+msgid "Loaded symbol %s (0x%p)\n"
+msgstr ""
+
+#: src/client/cl_curl.c:97
+#, possible-c-format
+msgid "Loading \"%s\"..."
+msgstr ""
+
+#: src/client/cl_curl.c:149
+msgid "FAIL One or more symbols not found\n"
+msgstr ""
+
+#: src/client/cl_curl.c:152
+msgid "OK\n"
+msgstr ""
+
+#: src/client/cl_curl.c:232
+#, possible-c-format
+msgid "URL: %s\n"
+msgstr ""
+
+#: src/client/cl_curl.c:260
+#, possible-c-format
+msgid "CL_cURL_BeginDownload: failed to open %s for writing\n"
+msgstr ""
+
+#: src/client/cl_curl.c:287
+msgid "CL_cURL_BeginDownload: qcurl_multi_init() failed\n"
+msgstr ""
+
+#: src/client/cl_curl.c:332
+#, possible-c-format
+msgid "Download Error: %s Code: %ld URL: %s"
+msgstr ""
+
+#: src/client/cl_input.c:97
+msgid "Three keys down for a button!\n"
+msgstr ""
+
+#: src/client/cl_input.c:392
+#, possible-c-format
+msgid "CL_JoystickEvent: bad axis %i"
+msgstr ""
+
+#: src/client/cl_keys.c:888
+msgid "unbind <key> : remove commands from a key\n"
+msgstr ""
+
+#: src/client/cl_keys.c:895 src/client/cl_keys.c:937
+#, possible-c-format
+msgid "\"%s\" isn't a valid key\n"
+msgstr ""
+
+#: src/client/cl_keys.c:931
+msgid "bind <key> [command] : attach a command to a key\n"
+msgstr ""
+
+#: src/client/cl_keys.c:946
+#, possible-c-format
+msgid "\"%s\" is not bound\n"
+msgstr ""
+
+#: src/client/cl_keys.c:1373 src/client/cl_keys.c:1420
+#, possible-c-format
+msgid "Couldn't read %s.\n"
+msgstr ""
+
+#: src/client/cl_keys.c:1401
+msgid "WARNING: probable corrupt history\n"
+msgstr ""
+
+#: src/client/cl_keys.c:1473 src/client/cl_keys.c:1478
+#, possible-c-format
+msgid "Couldn't write %s.\n"
+msgstr ""
+
+#: src/client/cl_main.c:202 src/client/cl_main.c:301
+msgid "VoIP: invalid player ID#\n"
+msgstr ""
+
+#: src/client/cl_main.c:214
+#, possible-c-format
+msgid "VoIP: player #%d gain now set to %f\n"
+msgstr ""
+
+#: src/client/cl_main.c:258
+#, possible-c-format
+msgid "WARNING: VoIP target %d is not a valid client number\n"
+msgstr ""
+
+#: src/client/cl_main.c:284
+#, possible-c-format
+msgid "VoIP: command ignored: %s\n"
+msgstr ""
+
+#: src/client/cl_main.c:298
+#, possible-c-format
+msgid "VoIP: current gain for player #%d is %f\n"
+msgstr ""
+
+#: src/client/cl_main.c:304
+msgid "usage: voip gain <playerID#> [value]\n"
+msgstr ""
+
+#: src/client/cl_main.c:307
+msgid "VoIP: muting incoming voice\n"
+msgstr ""
+
+#: src/client/cl_main.c:311
+msgid "VoIP: unmuting incoming voice\n"
+msgstr ""
+
+#: src/client/cl_main.c:315
+msgid ""
+"usage: voip [un]ignore <playerID#>\n"
+"       voip [un]muteall\n"
+"       voip gain <playerID#> [value]\n"
+msgstr ""
+
+#: src/client/cl_main.c:474
+#, possible-c-format
+msgid "VoIP: Send %d frames, %d bytes, %f power\n"
+msgstr ""
+
+#: src/client/cl_main.c:529
+msgid "Client command overflow"
+msgstr ""
+
+#: src/client/cl_main.c:596
+msgid "Not recording a demo.\n"
+msgstr ""
+
+#: src/client/cl_main.c:608
+msgid "Stopped demo.\n"
+msgstr ""
+
+#: src/client/cl_main.c:661
+msgid "Already recording.\n"
+msgstr ""
+
+#: src/client/cl_main.c:667
+msgid "You must be in a level to record.\n"
+msgstr ""
+
+#: src/client/cl_main.c:673
+msgid ""
+"WARNING: You should set 'g_synchronousClients 1' for smoother demo "
+"recording\n"
+msgstr ""
+
+#: src/client/cl_main.c:695
+#, possible-c-format
+msgid "recording to %s.\n"
+msgstr ""
+
+#: src/client/cl_main.c:863
+#, possible-c-format
+msgid "Couldn't open %s for writing\n"
+msgstr ""
+
+#: src/client/cl_main.c:917
+msgid "Demo file was truncated.\n"
+msgstr ""
+
+#: src/client/cl_main.c:1015
+#, possible-c-format
+msgid "Protocol %d not supported for demos\n"
+msgstr ""
+
+#: src/client/cl_main.c:1025
+#, possible-c-format
+msgid "couldn't open %s"
+msgstr ""
+
+#: src/client/cl_main.c:1302
+msgid "Mumble: Unlinking from Mumble application\n"
+msgstr ""
+
+#: src/client/cl_main.c:1402
+#, possible-c-format
+msgid "Unknown command \"%s"
+msgstr ""
+
+#: src/client/cl_main.c:1425
+#, possible-c-format
+msgid "Resolving %s\n"
+msgstr ""
+
+#: src/client/cl_main.c:1431
+msgid "Couldn't resolve master address\n"
+msgstr ""
+
+#: src/client/cl_main.c:1440 src/client/cl_main.c:1573
+#, possible-c-format
+msgid "%s resolved to %s\n"
+msgstr ""
+
+#: src/client/cl_main.c:1470 src/client/cl_main.c:1818
+msgid "Not connected to a server.\n"
+msgstr ""
+
+#: src/client/cl_main.c:1489
+msgid "Disconnected from server"
+msgstr ""
+
+#: src/client/cl_main.c:1502
+msgid "Can't reconnect to localhost.\n"
+msgstr ""
+
+#: src/client/cl_main.c:1535 src/client/cl_main.c:4193
+#: src/client/cl_main.c:4359
+msgid "warning: only -4 or -6 as address type understood.\n"
+msgstr ""
+
+#: src/client/cl_main.c:1563
+msgid "Bad server address\n"
+msgstr ""
+
+#: src/client/cl_main.c:1632
+msgid ""
+"You must set 'rconpassword' before\n"
+"issuing an rcon command.\n"
+msgstr ""
+
+#: src/client/cl_main.c:1655
+msgid ""
+"You must either be connected,\n"
+"or set the 'rconAddress' cvar\n"
+"to issue rcon commands\n"
+msgstr ""
+
+#: src/client/cl_main.c:1796
+#, possible-c-format
+msgid "Opened PK3 Names: %s\n"
+msgstr ""
+
+#: src/client/cl_main.c:1805
+#, possible-c-format
+msgid "Referenced PK3 Names: %s\n"
+msgstr ""
+
+#: src/client/cl_main.c:1837
+msgid "--------- Client Information ---------\n"
+msgstr ""
+
+#: src/client/cl_main.c:1838
+#, possible-c-format
+msgid "state: %i\n"
+msgstr ""
+
+#: src/client/cl_main.c:1839
+#, possible-c-format
+msgid "Server: %s\n"
+msgstr ""
+
+#: src/client/cl_main.c:1840
+msgid "User info settings:\n"
+msgstr ""
+
+#: src/client/cl_main.c:1842
+msgid "--------------------------------------\n"
+msgstr ""
+
+#: src/client/cl_main.c:1856
+msgid "Downloads complete\n"
+msgstr ""
+
+#: src/client/cl_main.c:1934
+#, possible-c-format
+msgid ""
+"***** CL_BeginDownload *****\n"
+"Localname: %s\n"
+"Remotename: %s\n"
+"****************************\n"
+msgstr ""
+
+#: src/client/cl_main.c:1978
+#, possible-c-format
+msgid "Incorrect checksum for file: %s"
+msgstr ""
+
+#: src/client/cl_main.c:2096
+#, possible-c-format
+msgid "Trying CURL download: %s; %s\n"
+msgstr ""
+
+#: src/client/cl_main.c:2098
+#, possible-c-format
+msgid ""
+"WARNING: server does not allow download redirection (sv_allowDownload is "
+"%d)\n"
+msgstr ""
+
+#: src/client/cl_main.c:2104
+msgid ""
+"WARNING: server allows download redirection, but does not have sv_dlURL set\n"
+msgstr ""
+
+#: src/client/cl_main.c:2109
+msgid "WARNING: could not load cURL library\n"
+msgstr ""
+
+#: src/client/cl_main.c:2119
+#, possible-c-format
+msgid ""
+"WARNING: server allows download redirection, but it disabled by client "
+"configuration (cl_allowDownload is %d)\n"
+msgstr ""
+
+#: src/client/cl_main.c:2126
+#, possible-c-format
+msgid "Trying UDP download: %s; %s\n"
+msgstr ""
+
+#: src/client/cl_main.c:2132
+#, possible-c-format
+msgid ""
+"Automatic downloads are disabled on your client (cl_allowDownload is %d). "
+"You can enable automatic downloads in the Options menu."
+msgstr ""
+
+#: src/client/cl_main.c:2140
+msgid "WARNING: UDP downloads are disabled.\n"
+msgstr ""
+
+#: src/client/cl_main.c:2169
+#, possible-c-format
+msgid "Need paks: %s\n"
+msgstr ""
+
+#: src/client/cl_main.c:2283 src/client/cl_main.c:2284
+msgid "Server disconnected for unknown reason\n"
+msgstr ""
+
+#: src/client/cl_main.c:2300
+msgid "MOTD packet from unexpected source\n"
+msgstr ""
+
+#: src/client/cl_main.c:2311
+#, possible-c-format
+msgid "MOTD packet mismatched challenge: '%s' != '%s'\n"
+msgstr ""
+
+#: src/client/cl_main.c:2377
+msgid "Master changed its mind about packet count!\n"
+msgstr ""
+
+#: src/client/cl_main.c:2410
+msgid "Warning: CL_GSRFeaturedLabel: overflow\n"
+msgstr ""
+
+#: src/client/cl_main.c:2470
+#, possible-c-format
+msgid "CL_ServersResponsePacket: received packet %d again, ignoring\n"
+msgstr ""
+
+#: src/client/cl_main.c:2477
+#, possible-c-format
+msgid "CL_ServersResponsePacket: packet %d of %d\n"
+msgstr ""
+
+#: src/client/cl_main.c:2561
+#, possible-c-format
+msgid "%d servers parsed (total %d)\n"
+msgstr ""
+
+#: src/client/cl_main.c:2591
+msgid "Unwanted challenge response received.  Ignored.\n"
+msgstr ""
+
+#: src/client/cl_main.c:2605
+msgid "Challenge response received from unexpected source. Ignored.\n"
+msgstr ""
+
+#: src/client/cl_main.c:2626
+msgid "Dup connect received.  Ignored.\n"
+msgstr ""
+
+#: src/client/cl_main.c:2630
+msgid "connectResponse packet while not connecting. Ignored.\n"
+msgstr ""
+
+#: src/client/cl_main.c:2634
+msgid "connectResponse from wrong address. Ignored.\n"
+msgstr ""
+
+#: src/client/cl_main.c:2699
+msgid "Unknown connectionless packet command.\n"
+msgstr ""
+
+#: src/client/cl_main.c:2725
+#, possible-c-format
+msgid "%s: Runt packet\n"
+msgstr ""
+
+#: src/client/cl_main.c:2733
+#, possible-c-format
+msgid "%s:sequenced packet without connection\n"
+msgstr ""
+
+#: src/client/cl_main.c:2777
+msgid ""
+"\n"
+"Server connection timed out.\n"
+msgstr ""
+
+#: src/client/cl_main.c:2843
+#, possible-c-format
+msgid "Download prompt returned %d\n"
+msgstr ""
+
+#: src/client/cl_main.c:2853
+msgid "WARNING: UI VM does not support download prompt\n"
+msgstr ""
+
+#: src/client/cl_main.c:3117
+msgid "----- Initializing Renderer ----\n"
+msgstr ""
+
+#: src/client/cl_main.c:3162
+msgid "-------------------------------\n"
+msgstr ""
+
+#: src/client/cl_main.c:3165
+msgid "Couldn't initialize refresh"
+msgstr ""
+
+#: src/client/cl_main.c:3188
+#, possible-c-format
+msgid "model is set to %s\n"
+msgstr ""
+
+#: src/client/cl_main.c:3211
+msgid "The video command can only be used when playing back demos\n"
+msgstr ""
+
+#: src/client/cl_main.c:3246
+msgid "ERROR: no free file names to create video\n"
+msgstr ""
+
+#: src/client/cl_main.c:3281
+msgid "QKEY found.\n"
+msgstr ""
+
+#: src/client/cl_main.c:3286
+#, possible-c-format
+msgid "QKEY file size != %d, regenerating\n"
+msgstr ""
+
+#: src/client/cl_main.c:3290
+msgid "QKEY building random string\n"
+msgstr ""
+
+#: src/client/cl_main.c:3295
+#, possible-c-format
+msgid "QKEY could not open %s for write\n"
+msgstr ""
+
+#: src/client/cl_main.c:3301
+msgid "QKEY generated\n"
+msgstr ""
+
+#: src/client/cl_main.c:3311
+msgid "----- Client Initialization -----\n"
+msgstr ""
+
+#: src/client/cl_main.c:3446
+msgid "Your network rate is too slow for VoIP.\n"
+msgstr ""
+
+#: src/client/cl_main.c:3447
+msgid ""
+"Set 'Data Rate' to 'LAN/Cable/xDSL' in 'Setup/System/Network' and restart.\n"
+msgstr ""
+
+#: src/client/cl_main.c:3448
+msgid "Until then, VoIP is disabled.\n"
+msgstr ""
+
+#: src/client/cl_main.c:3499
+msgid "----- Client Initialization Complete -----\n"
+msgstr ""
+
+#: src/client/cl_main.c:3516
+msgid "----- CL_Shutdown -----\n"
+msgstr ""
+
+#: src/client/cl_main.c:3519
+msgid "WARNING: Recursive shutdown\n"
+msgstr ""
+
+#: src/client/cl_main.c:3559
+msgid "-----------------------\n"
+msgstr ""
+
+#: src/client/cl_main.c:3619
+#, possible-c-format
+msgid "Different protocol info packet: %s\n"
+msgstr ""
+
+#: src/client/cl_main.c:3630
+#, possible-c-format
+msgid "ping time %dms from %s\n"
+msgstr ""
+
+#: src/client/cl_main.c:3675
+msgid "MAX_OTHER_SERVERS hit, dropping infoResponse\n"
+msgstr ""
+
+#: src/client/cl_main.c:3830
+msgid "Server settings:\n"
+msgstr ""
+
+#: src/client/cl_main.c:3861
+msgid ""
+"\n"
+"Players:\n"
+msgstr ""
+
+#: src/client/cl_main.c:3862
+msgid "num: score: ping: name:\n"
+msgstr ""
+
+#: src/client/cl_main.c:3903
+msgid "Scanning for servers on the local network...\n"
+msgstr ""
+
+#: src/client/cl_main.c:3949
+msgid "usage: globalservers <master# 0-4> <protocol> [keywords]\n"
+msgstr ""
+
+#: src/client/cl_main.c:3958
+msgid "CL_GlobalServers_f: Error: No master server address given.\n"
+msgstr ""
+
+#: src/client/cl_main.c:3969
+#, possible-c-format
+msgid "CL_GlobalServers_f: Error: could not resolve address of master %s\n"
+msgstr ""
+
+#: src/client/cl_main.c:3975
+#, possible-c-format
+msgid "Requesting servers from master %s...\n"
+msgstr ""
+
+#: src/client/cl_parse.c:124
+msgid "CL_ParsePacketEntities: end of message"
+msgstr ""
+
+#: src/client/cl_parse.c:252
+msgid "Delta from invalid frame (not supposed to happen!).\n"
+msgstr ""
+
+#: src/client/cl_parse.c:256
+msgid "Delta frame too old.\n"
+msgstr ""
+
+#: src/client/cl_parse.c:258
+msgid "Delta parseEntitiesNum too old.\n"
+msgstr ""
+
+#: src/client/cl_parse.c:269
+#, possible-c-format
+msgid "CL_ParseSnapshot: Invalid size %d for areamask."
+msgstr ""
+
+#: src/client/cl_parse.c:404
+#, possible-c-format
+msgid "WARNING: Server sent invalid fs_game value %s\n"
+msgstr ""
+
+#: src/client/cl_parse.c:418
+#, possible-c-format
+msgid "WARNING: server is not allowed to set %s=%s\n"
+msgstr ""
+
+#: src/client/cl_parse.c:488
+msgid "configstring > MAX_CONFIGSTRINGS"
+msgstr ""
+
+#: src/client/cl_parse.c:504
+#, possible-c-format
+msgid "Baseline number out of range: %i"
+msgstr ""
+
+#: src/client/cl_parse.c:510
+msgid "CL_ParseGamestate: bad command byte"
+msgstr ""
+
+#: src/client/cl_parse.c:555
+msgid "Server sending download, but no download was requested\n"
+msgstr ""
+
+#: src/client/cl_parse.c:580
+#, possible-c-format
+msgid "CL_ParseDownload: Invalid size %d for download chunk."
+msgstr ""
+
+#: src/client/cl_parse.c:587
+#, possible-c-format
+msgid "CL_ParseDownload: Expected block %d, got %d\n"
+msgstr ""
+
+#: src/client/cl_parse.c:597
+#, possible-c-format
+msgid "Could not create %s\n"
+msgstr ""
+
+#: src/client/cl_parse.c:676
+#, possible-c-format
+msgid "VoIP: %d-byte packet from client %d\n"
+msgstr ""
+
+#: src/client/cl_parse.c:714
+msgid "VoIP: packet accepted!\n"
+msgstr ""
+
+#: src/client/cl_parse.c:718
+#, possible-c-format
+msgid "VoIP: new generation %d!\n"
+msgstr ""
+
+#: src/client/cl_parse.c:724
+#, possible-c-format
+msgid "VoIP: misordered sequence! %d < %d!\n"
+msgstr ""
+
+#: src/client/cl_parse.c:731
+#, possible-c-format
+msgid "VoIP: Dropped way too many (%d) frames from client #%d\n"
+msgstr ""
+
+#: src/client/cl_parse.c:738
+#, possible-c-format
+msgid "VoIP: Dropped %d frames from client #%d\n"
+msgstr ""
+
+#: src/client/cl_parse.c:752
+msgid "VoIP: Short packet!\n"
+msgstr ""
+
+#: src/client/cl_parse.c:759 src/client/cl_parse.c:782
+#, possible-c-format
+msgid "VoIP: playback %d bytes, %d samples, %d frames\n"
+msgstr ""
+
+#: src/client/cl_parse.c:833
+msgid "------------------\n"
+msgstr ""
+
+#: src/client/cl_parse.c:850
+msgid "CL_ParseServerMessage: read past end of server message"
+msgstr ""
+
+#: src/client/cl_parse.c:885
+msgid "CL_ParseServerMessage: Illegible server message\n"
+msgstr ""
+
+#: src/client/cl_scrn.c:481
+msgid "SCR_DrawScreenField: bad cls.state"
+msgstr ""
+
+#: src/client/cl_scrn.c:544
+msgid "SCR_UpdateScreen: recursively called"
+msgstr ""
+
+#: src/client/cl_ui.c:99
+msgid "^1Error: Could not load cURL library"
+msgstr ""
+
+#: src/client/cl_ui.c:763
+#, possible-c-format
+msgid "turning EXEC_NOW '%.11s' into EXEC_INSERT\n"
+msgstr ""
+
+#: src/client/cl_ui.c:1050
+#, possible-c-format
+msgid "Bad UI system trap: %ld"
+msgstr ""
+
+#: src/client/cl_ui.c:1094
+msgid "Failed to find a valid UI vm. The following paths were searched:\n"
+msgstr ""
+
+#: src/client/cl_ui.c:1096
+msgid "VM_Create on UI failed"
+msgstr ""
+
+#: src/client/cl_ui.c:1106
+#, possible-c-format
+msgid "User Interface is version %d, expected %d"
+msgstr ""
+
+#: src/client/qal.c:129
+#, possible-c-format
+msgid " Can't load symbol %s\n"
+msgstr ""
+
+#: src/client/qal.c:135
+#, possible-c-format
+msgid " Loaded symbol %s (%p)\n"
+msgstr ""
+
+#: src/client/qal.c:150
+#, possible-c-format
+msgid "Loading \"%s\"...\n"
+msgstr ""
+
+#: src/client/qal.c:249
+msgid " One or more symbols not found\n"
+msgstr ""
+
+#: src/client/snd_codec.c:148 src/client/snd_codec.c:171
+#, possible-c-format
+msgid "Unknown extension for %s\n"
+msgstr ""
+
+#: src/client/snd_codec.c:209
+#, possible-c-format
+msgid "Can't read sound file %s\n"
+msgstr ""
+
+#: src/client/snd_codec_wav.c:71
+msgid "WARNING: Negative chunk length\n"
+msgstr ""
+
+#: src/client/snd_codec_wav.c:145
+msgid "ERROR: Couldn't find \"fmt\" chunk\n"
+msgstr ""
+
+#: src/client/snd_codec_wav.c:159
+msgid "ERROR: Less than 8 bit sound is not supported\n"
+msgstr ""
+
+#: src/client/snd_codec_wav.c:176
+msgid "ERROR: Couldn't find \"data\" chunk\n"
+msgstr ""
+
+#: src/client/snd_codec_wav.c:209
+#, possible-c-format
+msgid "ERROR: Could not open \"%s\"\n"
+msgstr ""
+
+#: src/client/snd_codec_wav.c:218
+#, possible-c-format
+msgid "ERROR: Incorrect/unsupported format in \"%s\"\n"
+msgstr ""
+
+#: src/client/snd_codec_wav.c:228
+#, possible-c-format
+msgid "ERROR: Out of memory reading \"%s\"\n"
+msgstr ""
+
+#: src/client/snd_dma.c:99
+msgid "----- Sound Info -----\n"
+msgstr ""
+
+#: src/client/snd_dma.c:101
+msgid "sound system not started\n"
+msgstr ""
+
+#: src/client/snd_dma.c:103
+#, possible-c-format
+msgid "%5d stereo\n"
+msgstr ""
+
+#: src/client/snd_dma.c:104
+#, possible-c-format
+msgid "%5d samples\n"
+msgstr ""
+
+#: src/client/snd_dma.c:105
+#, possible-c-format
+msgid "%5d samplebits\n"
+msgstr ""
+
+#: src/client/snd_dma.c:106
+#, possible-c-format
+msgid "%5d submission_chunk\n"
+msgstr ""
+
+#: src/client/snd_dma.c:107
+#, possible-c-format
+msgid "%5d speed\n"
+msgstr ""
+
+#: src/client/snd_dma.c:108
+#, possible-c-format
+msgid "%p dma buffer\n"
+msgstr ""
+
+#: src/client/snd_dma.c:110
+#, possible-c-format
+msgid "Background file: %s\n"
+msgstr ""
+
+#: src/client/snd_dma.c:112
+msgid "No background file.\n"
+msgstr ""
+
+#: src/client/snd_dma.c:116
+msgid "----------------------\n"
+msgstr ""
+
+#: src/client/snd_dma.c:180
+#, possible-c-format
+msgid "Total resident: %i\n"
+msgstr ""
+
+#: src/client/snd_dma.c:217
+msgid "Channel memory manager started\n"
+msgstr ""
+
+#: src/client/snd_dma.c:263
+msgid "S_FindName: NULL\n"
+msgstr ""
+
+#: src/client/snd_dma.c:266
+msgid "S_FindName: empty name\n"
+msgstr ""
+
+#: src/client/snd_dma.c:270
+#, possible-c-format
+msgid "Sound name too long: %s"
+msgstr ""
+
+#: src/client/snd_dma.c:293
+msgid "S_FindName: out of sfx_t"
+msgstr ""
+
+#: src/client/snd_dma.c:357
+msgid "Sound name exceeds MAX_QPATH\n"
+msgstr ""
+
+#: src/client/snd_dma.c:364 src/client/snd_dma.c:376
+#, possible-c-format
+msgid "WARNING: could not find %s - using default\n"
+msgstr ""
+
+#: src/client/snd_dma.c:390
+#, possible-c-format
+msgid "S_Base_SoundDuration: handle %i out of range\n"
+msgstr ""
+
+#: src/client/snd_dma.c:512
+#, possible-c-format
+msgid "S_StartSound: bad entitynum %i"
+msgstr ""
+
+#: src/client/snd_dma.c:516
+#, possible-c-format
+msgid "S_StartSound: handle %i out of range\n"
+msgstr ""
+
+#: src/client/snd_dma.c:591
+msgid "dropping sound\n"
+msgstr ""
+
+#: src/client/snd_dma.c:629
+#, possible-c-format
+msgid "S_StartLocalSound: handle %i out of range\n"
+msgstr ""
+
+#: src/client/snd_dma.c:734
+#, possible-c-format
+msgid "S_AddLoopingSound: handle %i out of range\n"
+msgstr ""
+
+#: src/client/snd_dma.c:745 src/client/snd_dma.c:808
+#, possible-c-format
+msgid "%s has length 0"
+msgstr ""
+
+#: src/client/snd_dma.c:797
+#, possible-c-format
+msgid "S_AddRealLoopingSound: handle %i out of range\n"
+msgstr ""
+
+#: src/client/snd_dma.c:958
+#, possible-c-format
+msgid "S_Base_RawSamples: resetting minimum: %i < %i\n"
+msgstr ""
+
+#: src/client/snd_dma.c:1036
+#, possible-c-format
+msgid "S_Base_RawSamples: overflowed %i > %i\n"
+msgstr ""
+
+#: src/client/snd_dma.c:1051 src/client/snd_openal.c:1127
+#, possible-c-format
+msgid "S_UpdateEntityPosition: bad entitynum %i"
+msgstr ""
+
+#: src/client/snd_dma.c:1172
+#, possible-c-format
+msgid "----(%i)---- painted: %i\n"
+msgstr ""
+
+#: src/client/snd_dma.c:1219
+msgid "S_Update_ : overflow\n"
+msgstr ""
+
+#: src/client/snd_dma.c:1328
+#, possible-c-format
+msgid "S_StartBackgroundTrack( %s, %s )\n"
+msgstr ""
+
+#: src/client/snd_dma.c:1353
+#, possible-c-format
+msgid "WARNING: couldn't open music file %s\n"
+msgstr ""
+
+#: src/client/snd_dma.c:1358
+#, possible-c-format
+msgid "WARNING: music file %s is not 22k stereo\n"
+msgstr ""
+
+#: src/client/snd_dma.c:1464
+#, possible-c-format
+msgid "S_FreeOldestSound: freeing sound %s\n"
+msgstr ""
+
+#: src/client/snd_main.c:492
+msgid "------ Initializing Sound ------\n"
+msgstr ""
+
+#: src/client/snd_main.c:504
+msgid "Sound disabled.\n"
+msgstr ""
+
+#: src/client/snd_main.c:530
+msgid "Sound interface invalid."
+msgstr ""
+
+#: src/client/snd_main.c:534
+msgid "Sound initialization successful.\n"
+msgstr ""
+
+#: src/client/snd_main.c:536
+msgid "Sound initialization failed.\n"
+msgstr ""
+
+#: src/client/snd_main.c:540
+msgid "--------------------------------\n"
+msgstr ""
+
+#: src/client/snd_mem.c:101
+msgid "Sound memory manager started\n"
+msgstr ""
+
+#: src/client/snd_mem.c:221
+#, possible-c-format
+msgid "WARNING: %s is a 8 bit wav file\n"
+msgstr ""
+
+#: src/client/snd_mem.c:225
+#, possible-c-format
+msgid "WARNING: %s is not a 22kHz wav file\n"
+msgstr ""
+
+#: src/client/snd_mem.c:269
+#, possible-c-format
+msgid "%d bytes free sound buffer memory, %d total used\n"
+msgstr ""
+
+#: src/client/snd_openal.c:86
+msgid "No error"
+msgstr ""
+
+#: src/client/snd_openal.c:88
+msgid "Invalid name"
+msgstr ""
+
+#: src/client/snd_openal.c:90
+msgid "Invalid enumerator"
+msgstr ""
+
+#: src/client/snd_openal.c:92
+msgid "Invalid value"
+msgstr ""
+
+#: src/client/snd_openal.c:94
+msgid "Invalid operation"
+msgstr ""
+
+#: src/client/snd_openal.c:96
+msgid "Out of memory"
+msgstr ""
+
+#: src/client/snd_openal.c:98
+msgid "Unknown error"
+msgstr ""
+
+#: src/client/snd_openal.c:115
+#, possible-c-format
+msgid "WARNING: unhandled AL error: %s\n"
+msgstr ""
+
+#: src/client/snd_openal.c:174
+msgid "S_AL_BufferFindFree: No free sound handles"
+msgstr ""
+
+#: src/client/snd_openal.c:226
+#, possible-c-format
+msgid "Can't load default sound effect %s\n"
+msgstr ""
+
+#: src/client/snd_openal.c:228
+#, possible-c-format
+msgid "WARNING: Using default sound for %s\n"
+msgstr ""
+
+#: src/client/snd_openal.c:252
+#, possible-c-format
+msgid "ERROR: Can't delete sound buffer for %s\n"
+msgstr ""
+
+#: src/client/snd_openal.c:340
+#, possible-c-format
+msgid "ERROR: Can't create a sound buffer for %s - %s\n"
+msgstr ""
+
+#: src/client/snd_openal.c:365
+#, possible-c-format
+msgid "ERROR: Out of memory loading %s\n"
+msgstr ""
+
+#: src/client/snd_openal.c:379
+#, possible-c-format
+msgid "ERROR: Can't fill sound buffer for %s - %s\n"
+msgstr ""
+
+#: src/client/snd_openal.c:488
+#, possible-c-format
+msgid "ERROR: S_AL_SoundDuration: handle %i out of range\n"
+msgstr ""
+
+#: src/client/snd_openal.c:573
+#, possible-c-format
+msgid ""
+"WARNING: vector with one or more NaN components being passed to OpenAL at %s:"
+"%d -- zeroing\n"
+msgstr ""
+
+#: src/client/snd_openal.c:702
+#, possible-c-format
+msgid "Allocated %d sources.\n"
+msgstr ""
+
+#: src/client/snd_openal.c:727
+#, possible-c-format
+msgid "WARNING: Source %d is locked\n"
+msgstr ""
+
+#: src/client/snd_openal.c:813
+#, possible-c-format
+msgid "WARNING: Could not get time offset for alSource %d: %s\n"
+msgstr ""
+
+#: src/client/snd_openal.c:1141
+#, possible-c-format
+msgid "ERROR: S_AL_CheckInput: bad entitynum %i"
+msgstr ""
+
+#: src/client/snd_openal.c:1145
+#, possible-c-format
+msgid "ERROR: S_AL_CheckInput: handle %i out of range\n"
+msgstr ""
+
+#: src/client/snd_openal.c:1284
+#, possible-c-format
+msgid "WARNING: Failed to allocate source for loop sfx %d on entity %d\n"
+msgstr ""
+
+#: src/client/snd_openal.c:1487
+#, possible-c-format
+msgid "WARNING: Cannot get sample offset from source %d: %s\n"
+msgstr ""
+
+#: src/client/snd_openal.c:1687
+msgid "ERROR: Can't allocate streaming streamSource\n"
+msgstr ""
+
+#: src/client/snd_openal.c:1951
+#, possible-c-format
+msgid "ERROR: while buffering data for music stream - %s\n"
+msgstr ""
+
+#: src/client/snd_openal.c:2059
+msgid "Restarted OpenAL music\n"
+msgstr ""
+
+#: src/client/snd_openal.c:2283
+msgid "OpenAL info:\n"
+msgstr ""
+
+#: src/client/snd_openal.c:2284
+#, possible-c-format
+msgid "  Vendor:     %s\n"
+msgstr ""
+
+#: src/client/snd_openal.c:2285
+#, possible-c-format
+msgid "  Version:    %s\n"
+msgstr ""
+
+#: src/client/snd_openal.c:2286
+#, possible-c-format
+msgid "  Renderer:   %s\n"
+msgstr ""
+
+#: src/client/snd_openal.c:2287
+#, possible-c-format
+msgid "  AL Extensions: %s\n"
+msgstr ""
+
+#: src/client/snd_openal.c:2288
+#, possible-c-format
+msgid "  ALC Extensions: %s\n"
+msgstr ""
+
+#: src/client/snd_openal.c:2291
+#, possible-c-format
+msgid "  Device:     %s\n"
+msgstr ""
+
+#: src/client/snd_openal.c:2292
+#, possible-c-format
+msgid ""
+"Available Devices:\n"
+"%s"
+msgstr ""
+
+#: src/client/snd_openal.c:2320
+msgid "OpenAL capture device closed.\n"
+msgstr ""
+
+#: src/client/snd_openal.c:2374
+#, possible-c-format
+msgid "Failed to load library: \"%s\".\n"
+msgstr ""
+
+#: src/client/snd_openal.c:2418
+#, possible-c-format
+msgid "Failed to open OpenAL device '%s', trying default.\n"
+msgstr ""
+
+#: src/client/snd_openal.c:2425
+msgid "Failed to open OpenAL device.\n"
+msgstr ""
+
+#: src/client/snd_openal.c:2435
+msgid "Failed to create OpenAL context.\n"
+msgstr ""
+
+#: src/client/snd_openal.c:2456
+msgid ""
+"OpenAL capture support disabled by user ('+set s_alCapture 1' to enable)\n"
+msgstr ""
+
+#: src/client/snd_openal.c:2461
+msgid "OpenAL capture support disabled for Mumble support\n"
+msgstr ""
+
+#: src/client/snd_openal.c:2477
+msgid "No ALC_EXT_capture support, can't record audio.\n"
+msgstr ""
+
+#: src/client/snd_openal.c:2485
+#, possible-c-format
+msgid "OpenAL default capture device is '%s'\n"
+msgstr ""
+
+#: src/client/snd_openal.c:2488
+#, possible-c-format
+msgid "OpenAL capture device %s.\n"
+msgstr ""
+
+#: src/sys/con_tty.c:288
+msgid "tty console mode disabled\n"
+msgstr ""
+
+#: src/sys/con_tty.c:419
+#, possible-c-format
+msgid "droping ISCTL sequence: %d, TTY_erase: %d\n"
+msgstr ""
+
+#: src/sys/sys_main.c:318
+#, possible-c-format
+msgid "Warning: %s"
+msgstr ""
+
+#: src/sys/sys_main.c:347
+msgid "Sys_UnloadDll(NULL)\n"
+msgstr ""
+
+#: src/sys/sys_main.c:367
+#, possible-c-format
+msgid "Sys_LoadDll(%s)... \n"
+msgstr ""
+
+#: src/sys/sys_main.c:372
+#, possible-c-format
+msgid ""
+"Sys_LoadDll(%s) failed:\n"
+"\"%s\"\n"
+msgstr ""
+
+#: src/sys/sys_main.c:376
+#, possible-c-format
+msgid "Sys_LoadDll(%s): succeeded ...\n"
+msgstr ""
+
+#: src/sys/sys_main.c:417
+#, possible-c-format
+msgid "Sys_LoadDll(%s) failed to load library\n"
+msgstr ""
+
+#: src/sys/sys_main.c:426
+#, possible-c-format
+msgid ""
+"Sys_LoadDll(%s) failed to find vmMain function:\n"
+"\"%s\" !\n"
+msgstr ""
+
+#: src/sys/sys_main.c:432
+#, possible-c-format
+msgid "Sys_LoadDll(%s) found vmMain function at %p\n"
+msgstr ""
+
+#: src/sys/sys_main.c:480
+#, c-format
+msgid "DOUBLE SIGNAL FAULT: Received signal %d, exiting...\n"
+msgstr ""
+
+#: src/sys/sys_main.c:486
+#, c-format
+msgid "Received signal %d, exiting...\n"
+msgstr ""
+
+#: src/sys/sys_main.c:490
+msgid "Signal caught"
+msgstr ""
+
+#: src/sys/sys_main.c:525
+msgid "SDL version "
+msgstr ""
+
+#: src/sys/sys_unix.c:532
+#, possible-c-format
+msgid "ERROR: couldn't create path '%s' for crash log.\n"
+msgstr ""
+
+#: src/sys/sys_unix.c:542
+#, possible-c-format
+msgid "ERROR: couldn't open %s\n"
+msgstr ""
+
+#: src/sys/sys_unix.c:549
+#, possible-c-format
+msgid "ERROR: couldn't fully write to %s\n"
+msgstr ""
+
+#: src/sys/sys_win32.c:60
+msgid "Unable to load SHFolder.dll\n"
+msgstr ""
+
+#: src/sys/sys_win32.c:67
+msgid "Unable to find SHGetFolderPath in SHFolder.dll\n"
+msgstr ""
+
+#: src/sys/sys_win32.c:75
+msgid "Unable to detect CSIDL_APPDATA\n"
+msgstr ""
+
+#: src/sys/sys_win32.c:548
+#, possible-c-format
+msgid "%s. Copy console log to clipboard?"
+msgstr ""
+
+#: src/sys/sys_win32.c:659
+#, possible-c-format
+msgid ""
+"SDL_VIDEODRIVER is externally set to \"%s\", in_mouse -1 will have no "
+"effect\n"
+msgstr ""
+
+#: ../assets/ui/createfavorite.menu:50 ../assets/ui/findplayer.menu:58
+#: ../assets/ui/ingame_options.menu:179 ../assets/ui/options.menu:54
+msgid "Name:"
+msgstr ""
+
+#: ../assets/ui/createfavorite.menu:66
+msgid "Address:"
+msgstr ""
+
+#: ../assets/ui/createfavorite.menu:79 ../assets/ui/drop.menu:83
+#: ../assets/ui/error.menu:83 ../assets/ui/options.menu:295
+#: ../assets/ui/password.menu:69 ../assets/ui/tremulous_alienbuild.menu:98
+#: ../assets/ui/tremulous_alienclass.menu:119
+#: ../assets/ui/tremulous_aliendialogs.menu:80
+#: ../assets/ui/tremulous_alienupgrade.menu:98
+#: ../assets/ui/tremulous_dialogs.menu:81
+#: ../assets/ui/tremulous_humanbuild.menu:97
+#: ../assets/ui/tremulous_humandialogs.menu:81
+#: ../assets/ui/tremulous_humanitem.menu:119
+#: ../assets/ui/tremulous_teamselect.menu:98
+msgid "OK"
+msgstr ""
+
+#: ../assets/ui/createfavorite.menu:99 ../assets/ui/mod.menu:93
+#: ../assets/ui/tremulous_alienbuild.menu:119
+#: ../assets/ui/tremulous_alienclass.menu:140
+#: ../assets/ui/tremulous_alienupgrade.menu:119
+#: ../assets/ui/tremulous_humanbuild.menu:118
+#: ../assets/ui/tremulous_humanitem.menu:140
+#: ../assets/ui/tremulous_teamselect.menu:119
+msgid "Cancel"
+msgstr ""
+
+#: ../assets/ui/createserver.menu:125
+msgid "Host Name:"
+msgstr ""
+
+#: ../assets/ui/createserver.menu:141 ../assets/ui/ingame_game.menu:702
+msgid "Time Limit:"
+msgstr ""
+
+#: ../assets/ui/createserver.menu:157
+msgid "Maximum Players:"
+msgstr ""
+
+#: ../assets/ui/createserver.menu:173
+msgid "Require Password:"
+msgstr ""
+
+#: ../assets/ui/createserver.menu:192 ../assets/ui/password.menu:55
+msgid "Password:"
+msgstr ""
+
+#: ../assets/ui/createserver.menu:210
+msgid "Pure Server:"
+msgstr ""
+
+#: ../assets/ui/createserver.menu:229
+msgid "Dedicated:"
+msgstr ""
+
+#: ../assets/ui/createserver.menu:251
+msgid "Auto Download:"
+msgstr ""
+
+#: ../assets/ui/createserver.menu:270
+msgid "Enable Voting:"
+msgstr ""
+
+#: ../assets/ui/createserver.menu:291
+msgid "Minimum Ping:"
+msgstr ""
+
+#: ../assets/ui/createserver.menu:307
+msgid "Maximum Ping:"
+msgstr ""
+
+#: ../assets/ui/createserver.menu:323
+msgid "Synchronous Client:"
+msgstr ""
+
+#: ../assets/ui/createserver.menu:342
+msgid "Max Rate:"
+msgstr ""
+
+#: ../assets/ui/createserver.menu:358
+msgid "Zombie Time:"
+msgstr ""
+
+#: ../assets/ui/createserver.menu:374
+msgid "Reconnect Limit:"
+msgstr ""
+
+#: ../assets/ui/createserver.menu:423 ../assets/ui/joinserver.menu:647
+msgid "Back"
+msgstr ""
+
+#: ../assets/ui/createserver.menu:480
+msgid "Create"
+msgstr ""
+
+#: ../assets/ui/download.menu:47
+msgid "Download"
+msgstr ""
+
+#: ../assets/ui/download.menu:80
+msgid "Download from website"
+msgstr ""
+
+#: ../assets/ui/download.menu:103
+msgid "Download from server"
+msgstr ""
+
+#: ../assets/ui/download.menu:126 ../assets/ui/ingame_game.menu:127
+msgid "Ignore"
+msgstr ""
+
+#: ../assets/ui/download.menu:149
+msgid "Disconnect"
+msgstr ""
+
+#: ../assets/ui/drop.menu:55
+msgid "Disconnected"
+msgstr ""
+
+#: ../assets/ui/drop.menu:103
+msgid "Reconnect"
+msgstr ""
+
+#: ../assets/ui/error.menu:55 ../assets/ui/tremulous_aliendialogs.menu:45
+#: ../assets/ui/tremulous_dialogs.menu:46
+#: ../assets/ui/tremulous_humandialogs.menu:46
+msgid "Error"
+msgstr ""
+
+#: ../assets/ui/findplayer.menu:77
+msgid "Search"
+msgstr ""
+
+#: ../assets/ui/findplayer.menu:140 ../assets/ui/joinserver.menu:704
+msgid "Join"
+msgstr ""
+
+#: ../assets/ui/findplayer.menu:155 ../assets/ui/news.menu:84
+#: ../assets/ui/serverinfo.menu:94
+#: ../assets/ui/tremulous_humanarmoury.menu:152
+msgid "Close"
+msgstr ""
+
+#: ../assets/ui/ingame_game.menu:101
+msgid "Vote"
+msgstr ""
+
+#: ../assets/ui/ingame_game.menu:152
+msgid "Info"
+msgstr ""
+
+#: ../assets/ui/ingame_game.menu:181
+msgid "Map"
+msgstr ""
+
+#: ../assets/ui/ingame_game.menu:203 ../assets/ui/joinserver.menu:323
+msgid "Players"
+msgstr ""
+
+#: ../assets/ui/ingame_game.menu:225
+msgid "Team"
+msgstr ""
+
+#: ../assets/ui/ingame_game.menu:287
+msgid "Load Selected Map"
+msgstr ""
+
+#: ../assets/ui/ingame_game.menu:307
+msgid "Load Selected Map Next"
+msgstr ""
+
+#: ../assets/ui/ingame_game.menu:327
+msgid "Restart Current Map"
+msgstr ""
+
+#: ../assets/ui/ingame_game.menu:347
+msgid "Begin Sudden Death"
+msgstr ""
+
+#: ../assets/ui/ingame_game.menu:367
+msgid "End Match In Draw"
+msgstr ""
+
+#: ../assets/ui/ingame_game.menu:408
+msgid "Mute Player"
+msgstr ""
+
+#: ../assets/ui/ingame_game.menu:428
+msgid "Un-Mute Player"
+msgstr ""
+
+#: ../assets/ui/ingame_game.menu:448
+msgid "Kick Player"
+msgstr ""
+
+#: ../assets/ui/ingame_game.menu:490
+msgid "Kick Teammate"
+msgstr ""
+
+#: ../assets/ui/ingame_game.menu:510
+msgid "Deny Building For Teammate"
+msgstr ""
+
+#: ../assets/ui/ingame_game.menu:530
+msgid "Allow Building For Teammate"
+msgstr ""
+
+#: ../assets/ui/ingame_game.menu:551
+msgid "Admit Defeat"
+msgstr ""
+
+#: ../assets/ui/ingame_game.menu:573
+msgid "Player Name"
+msgstr ""
+
+#: ../assets/ui/ingame_game.menu:586
+msgid "Ignored"
+msgstr ""
+
+#: ../assets/ui/ingame_game.menu:598
+msgid "Ignoring You"
+msgstr ""
+
+#: ../assets/ui/ingame_game.menu:638
+msgid "Ignore Player"
+msgstr ""
+
+#: ../assets/ui/ingame_game.menu:658
+msgid "Stop Ignoring Player"
+msgstr ""
+
+#: ../assets/ui/ingame_game.menu:684
+msgid "Server Name:"
+msgstr ""
+
+#: ../assets/ui/ingame_game.menu:720
+msgid "Sudden Death Time:"
+msgstr ""
+
+#: ../assets/ui/ingame_game.menu:738
+msgid "Max Clients:"
+msgstr ""
+
+#: ../assets/ui/ingame_game.menu:756
+msgid "Map Name:"
+msgstr ""
+
+#: ../assets/ui/ingame_game.menu:774
+msgid "Lag Correction:"
+msgstr ""
+
+#: ../assets/ui/ingame_game.menu:792
+msgid "Friendly Fire:"
+msgstr ""
+
+#: ../assets/ui/ingame_game.menu:810
+msgid "Buildable Friendly Fire:"
+msgstr ""
+
+#: ../assets/ui/ingame_game.menu:828
+msgid "Version:"
+msgstr ""
+
+#: ../assets/ui/ingame_leave.menu:53
+msgid "Main Menu"
+msgstr ""
+
+#: ../assets/ui/ingame_leave.menu:75 ../assets/ui/main.menu:138
+msgid "Quit"
+msgstr ""
+
+#: ../assets/ui/ingame_leave.menu:99
+msgid "Return To Main Menu?"
+msgstr ""
+
+#: ../assets/ui/ingame_leave.menu:114 ../assets/ui/ingame_leave.menu:171
+msgid "Yes"
+msgstr "éñ"
+
+#: ../assets/ui/ingame_leave.menu:134 ../assets/ui/ingame_leave.menu:191
+msgid "No"
+msgstr ""
+
+#: ../assets/ui/ingame_leave.menu:156
+msgid "Want To Quit Game?"
+msgstr ""
+
+#: ../assets/ui/ingame.menu:67
+msgid "Game"
+msgstr ""
+
+#: ../assets/ui/ingame.menu:86 ../assets/ui/main.menu:98
+msgid "Options"
+msgstr ""
+
+#: ../assets/ui/ingame.menu:105
+msgid "Help"
+msgstr ""
+
+#: ../assets/ui/ingame.menu:124
+msgid "Exit"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:69
+msgid "Player"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:94
+msgid "HUD"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:120
+msgid "Controls"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:147
+msgid "System"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:196
+msgid "Taunts Sounds Off:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:216
+msgid "Team Chats Only:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:236
+msgid "Sticky Spectate:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:256
+msgid "Tutorial Mode:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:276
+msgid "Disable Warning Dialogs:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:299
+msgid "Show Clock:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:320
+msgid "Show Crosshair:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:341
+msgid "Crosshair Size:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:362
+msgid "Show Charge Bar:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:382
+msgid "Show Lag-o-meter:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:402
+msgid "Show Team Overlay:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:422
+msgid "Show Gun:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:442
+msgid "Show Speed:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:463
+msgid "Show FPS:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:483
+msgid "Show Timer:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:503
+msgid "Show Demo State:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:524
+msgid "Look"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:550
+msgid "Lookup:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:570
+msgid "Look Down:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:590
+msgid "Mouse Look:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:610
+msgid "Centerview:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:630
+msgid "Free Look:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:650 ../assets/ui/options.menu:189
+msgid "Mouse Sensitivity:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:666 ../assets/ui/options.menu:203
+msgid "Invert Mouse:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:687
+msgid "Smooth Mouse:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:707
+msgid "Auto Wallwalk Pitching:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:727
+msgid "Move"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:751
+msgid "Sprint Toggles:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:771
+msgid "Wallwalk Control Toggles:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:791
+msgid "Wallwalking Speed:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:812
+msgid "Run / Walk:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:832
+msgid "Dodge:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:852
+msgid "Sprint:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:872
+msgid "Forward:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:892
+msgid "Backpedal:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:912
+msgid "Move Left:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:932
+msgid "Move Right:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:952
+msgid "Jump:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:972
+msgid "Crouch:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:992
+msgid "Turn Left:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1012
+msgid "Turn Right:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1032
+msgid "Strafe:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1054
+msgid "Upgrades"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1078
+msgid "Primary Attack:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1098
+msgid "Secondary Attack:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1118
+msgid "Previous Upgrade:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1138
+msgid "Next Upgrade:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1158
+msgid "Activate Upgrade:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1178
+msgid "Reload:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1198
+msgid "Buy Ammo:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1218
+msgid "Use Medkit:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1238
+msgid "Misc"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1262
+msgid "Show Scores:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1282
+msgid "Scroll Scores Up:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1302
+msgid "Scroll Scores Down:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1322
+msgid "Use Structure/Evolve:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1342
+msgid "Deconstruct Structure:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1362
+msgid "Gesture:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1382
+msgid "Chat:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1402
+msgid "Team Chat:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1422
+msgid "Vote Yes:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1442
+msgid "Vote No:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1462
+msgid "Team Vote Yes:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1482
+msgid "Team Vote No:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1502
+msgid "Screenshot:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1522
+msgid "GFX Hardware"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1548
+msgid "Quality:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1570
+msgid "GL Extensions:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1591 ../assets/ui/options.menu:89
+msgid "Video Mode:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1630
+msgid "Color Depth:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1653
+msgid "Fullscreen:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1674
+msgid "Lighting:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1696
+msgid "Geometric Detail:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1719
+msgid "Texture Detail:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1741
+msgid "Texture Quality:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1762
+msgid "Texture Filter:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1784
+msgid "Anisotropic Filtering:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1805
+msgid "Compress Textures:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1826 ../assets/ui/ingame_options.menu:2322
+#: ../assets/ui/options.menu:277
+msgid "APPLY"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1846
+msgid "GFX Software"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1870
+msgid "Brightness:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1886
+msgid "Screen Size:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1902
+msgid "Marks On Walls:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1922
+msgid "Dynamic Lights:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1942
+msgid "Draw Gun:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1962
+msgid "Low Quality Sky:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1982
+msgid "Sync Every Frame:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:2002
+msgid "Show Time:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:2022
+msgid "In Game Videos:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:2042
+msgid "Depth Sort Particles:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:2062
+msgid "Particle Physics:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:2083
+msgid "Light Flares:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:2104
+msgid "OpenGL Info"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:2144
+msgid "Net & Sound"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:2169 ../assets/ui/quitcredit.menu:403
+msgid "Sound"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:2188 ../assets/ui/options.menu:141
+msgid "Effects Volume:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:2204 ../assets/ui/options.menu:155
+msgid "Music Volume:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:2220
+msgid "OpenAL:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:2240
+msgid "Sound Quality:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:2261
+msgid "Doppler Sound:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:2282
+msgid "Network"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:2301
+msgid "Net Data Rate:"
+msgstr ""
+
+#: ../assets/ui/joinserver.menu:85
+msgid "Source:"
+msgstr ""
+
+#: ../assets/ui/joinserver.menu:108
+msgid "Get New List"
+msgstr ""
+
+#: ../assets/ui/joinserver.menu:130
+msgid "Refresh List"
+msgstr ""
+
+#: ../assets/ui/joinserver.menu:154
+msgid "View Empty:"
+msgstr ""
+
+#: ../assets/ui/joinserver.menu:177
+msgid "View Full:"
+msgstr ""
+
+#: ../assets/ui/joinserver.menu:201
+msgid "[official] = Official Server\\n[featured] = Featured Server"
+msgstr ""
+
+#: ../assets/ui/joinserver.menu:235
+msgid "Server Name"
+msgstr ""
+
+#: ../assets/ui/joinserver.menu:280
+msgid "Map Name"
+msgstr ""
+
+#: ../assets/ui/joinserver.menu:367 ../assets/ui/teamscore.menu:181
+#: ../assets/ui/teamscore.menu:256
+msgid "Ping"
+msgstr ""
+
+#: ../assets/ui/joinserver.menu:476
+msgid "Set Password"
+msgstr ""
+
+#: ../assets/ui/joinserver.menu:495
+msgid "Create Favorite"
+msgstr ""
+
+#: ../assets/ui/joinserver.menu:514
+msgid "Add Favorite"
+msgstr ""
+
+#: ../assets/ui/joinserver.menu:534
+msgid "Delete Favorite"
+msgstr ""
+
+#: ../assets/ui/joinserver.menu:555
+msgid "Server Info"
+msgstr ""
+
+#: ../assets/ui/joinserver.menu:574
+msgid "Find a Friend"
+msgstr ""
+
+#: ../assets/ui/joinserver.menu:597
+msgid "Create Server"
+msgstr ""
+
+#: ../assets/ui/main.menu:30
+msgid "and"
+msgstr ""
+
+#: ../assets/ui/main.menu:59
+msgid "Play"
+msgstr "PL¿∞ououou"
+
+#: ../assets/ui/main.menu:78
+msgid "News"
+msgstr ""
+
+#: ../assets/ui/main.menu:118
+msgid "Mods"
+msgstr ""
+
+#: ../assets/ui/main.menu:158
+msgid "Tremulous (C) 2005-2009 darklegion development"
+msgstr ""
+
+#: ../assets/ui/mod.menu:74
+msgid "Load"
+msgstr ""
+
+#: ../assets/ui/news.menu:49
+msgid "Tremulous News"
+msgstr ""
+
+#: ../assets/ui/options.menu:69
+msgid "Video Quality:"
+msgstr ""
+
+#: ../assets/ui/options.menu:125
+msgid "Video Brightness:"
+msgstr ""
+
+#: ../assets/ui/options.menu:169
+msgid "OpenAL Sound:"
+msgstr ""
+
+#: ../assets/ui/options.menu:224
+msgid "Network Connection:"
+msgstr ""
+
+#: ../assets/ui/options.menu:243
+msgid "Allow Auto Download:"
+msgstr ""
+
+#: ../assets/ui/options.menu:261
+msgid "For further options please use the in-game options menu"
+msgstr ""
+
+#: ../assets/ui/quitcredit.menu:73
+msgid "CREDITS"
+msgstr ""
+
+#: ../assets/ui/quitcredit.menu:90
+msgid "Tim 'Timbo' Angus"
+msgstr ""
+
+#: ../assets/ui/quitcredit.menu:106
+msgid "Programming and Direction"
+msgstr ""
+
+#: ../assets/ui/quitcredit.menu:123
+msgid "Nick 'jex' Jansens"
+msgstr ""
+
+#: ../assets/ui/quitcredit.menu:139
+msgid "Mapping, texturing and 2D artwork"
+msgstr ""
+
+#: ../assets/ui/quitcredit.menu:156
+msgid "Robin 'OverFlow' Marshall"
+msgstr ""
+
+#: ../assets/ui/quitcredit.menu:172
+msgid "Modelling, animation and mapping"
+msgstr ""
+
+#: ../assets/ui/quitcredit.menu:189
+msgid "Jan 'Stannum' van der Weg"
+msgstr ""
+
+#: ../assets/ui/quitcredit.menu:205
+msgid "Texturing and mapping"
+msgstr ""
+
+#: ../assets/ui/quitcredit.menu:222
+msgid "Mike 'Veda' McInerney"
+msgstr ""
+
+#: ../assets/ui/quitcredit.menu:238
+msgid "Modelling, animation and texturing"
+msgstr ""
+
+#: ../assets/ui/quitcredit.menu:255
+msgid "Gordon 'Godmil' Miller"
+msgstr ""
+
+#: ../assets/ui/quitcredit.menu:271 ../assets/ui/quitcredit.menu:304
+#: ../assets/ui/quitcredit.menu:337
+msgid "Mapping"
+msgstr ""
+
+#: ../assets/ui/quitcredit.menu:288
+msgid "'Who-[Soup]'"
+msgstr ""
+
+#: ../assets/ui/quitcredit.menu:321
+msgid "Tristan 'jhrx' Blease"
+msgstr ""
+
+#: ../assets/ui/quitcredit.menu:354
+msgid "Paul 'MoP' Greveson"
+msgstr ""
+
+#: ../assets/ui/quitcredit.menu:370
+msgid "Modelling and texturing"
+msgstr ""
+
+#: ../assets/ui/quitcredit.menu:387
+msgid "Chris 'Dolby' McCarthy"
+msgstr ""
+
+#: ../assets/ui/quit.menu:47
+msgid "Quit Tremulous?"
+msgstr ""
+
+#: ../assets/ui/quit.menu:63
+msgid "YES"
+msgstr ""
+
+#: ../assets/ui/quit.menu:82
+msgid "NO"
+msgstr ""
+
+#: ../assets/ui/say.menu:32
+msgid "Say:"
+msgstr ""
+
+#: ../assets/ui/say.menu:74
+msgid "Say to team:"
+msgstr ""
+
+#: ../assets/ui/say.menu:116
+msgid "Command:"
+msgstr ""
+
+#: ../assets/ui/serverinfo.menu:75
+msgid "Refresh"
+msgstr ""
+
+#: ../assets/ui/teamscore.menu:121 ../assets/ui/teamscore.menu:196
+msgid "Status"
+msgstr ""
+
+#: ../assets/ui/teamscore.menu:136 ../assets/ui/teamscore.menu:211
+msgid "Name"
+msgstr ""
+
+#: ../assets/ui/teamscore.menu:151 ../assets/ui/teamscore.menu:226
+msgid "Score"
+msgstr ""
+
+#: ../assets/ui/teamscore.menu:166 ../assets/ui/teamscore.menu:241
+msgid "Time"
+msgstr ""
+
+#: ../assets/ui/teamscore.menu:346
+msgid "Spectating:"
+msgstr ""
+
+#: ../assets/ui/tremulous_alienclass.menu:98
+#: ../assets/ui/tremulous_humanitem.menu:98
+msgid "< Back"
+msgstr ""
+
+#: ../assets/ui/tremulous_default_hud.menu:25
+msgid "SPECTATOR"
+msgstr ""
+
+#: ../assets/ui/tremulous_humanarmoury.menu:132
+msgid "Buy >"
+msgstr ""
+
+#: ../assets/ui/tremulous_humanarmoury.menu:172
+msgid "< Sell"
+msgstr ""
+
+
+###
+# Teams
+msgid "Aliens"
+msgstr ""
+
+msgid "Humans"
+msgstr ""
+
+msgid "Spectate"
+msgstr ""
+
+# bg_misc.c humanName
+msgid "Overmind"
+msgstr ""
+
+msgid "Barricade"
+msgstr ""
+
+msgid "Acid Tube"
+msgstr ""
+
+msgid "Trapper"
+msgstr ""
+
+msgid "Booster"
+msgstr ""
+
+#msgid "Hive"
+#msgstr ""
+
+msgid "Telenode"
+msgstr ""
+
+#msgid "Machinegun Turret"
+#msgstr ""
+
+#msgid "Tesla Generator"
+#msgstr ""
+
+msgid "Armoury"
+msgstr ""
+
+msgid "Defence Computer"
+msgstr ""
+
+msgid "Medistation"
+msgstr ""
+
+msgid "Reactor"
+msgstr ""
+
+msgid "Repeater"
+msgstr ""
+
+msgid "Bite"
+msgstr ""
+
+msgid "Claws"
+msgstr ""
+
+msgid "Claws Upgrade"
+msgstr ""
+
+#msgid "Bite"
+#msgstr ""
+
+msgid "Zap"
+msgstr ""
+
+msgid "Pounce"
+msgstr ""
+
+msgid "Pounce (upgrade)"
+msgstr ""
+
+msgid "Charge"
+msgstr ""
+
+msgid "Blaster"
+msgstr ""
+
+msgid "Rifle"
+msgstr ""
+
+msgid "Pain Saw"
+msgstr ""
+
+msgid "Shotgun"
+msgstr ""
+
+msgid "Las Gun"
+msgstr ""
+
+msgid "Mass Driver"
+msgstr ""
+
+msgid "Chaingun"
+msgstr ""
+
+msgid "Flame Thrower"
+msgstr ""
+
+msgid "Pulse Rifle"
+msgstr ""
+
+msgid "Lucifer Cannon"
+msgstr ""
+
+#msgid "Grenade"
+#msgstr ""
+
+msgid "Lock Blob"
+msgstr ""
+
+msgid "Hive"
+msgstr ""
+
+msgid "Tesla Generator"
+msgstr ""
+
+msgid "Machinegun Turret"
+msgstr ""
+
+msgid "Alien build weapon"
+msgstr ""
+
+msgid "Alien build weapon2"
+msgstr ""
+
+msgid "Construction Kit"
+msgstr ""
+
+msgid "Light Armour"
+msgstr ""
+
+msgid "Helmet"
+msgstr ""
+
+msgid "Medkit"
+msgstr ""
+
+msgid "Battery Pack"
+msgstr ""
+
+msgid "Jet Pack"
+msgstr ""
+
+msgid "Battlesuit"
+msgstr ""
+
+msgid "Grenade"
+msgstr ""
+
+msgid "Ammunition"
+msgstr ""
+
+# bg_misc.c descriptions
+msgid "The most basic alien structure. It allows aliens to spawn and protect the Overmind. Without any of these, the Overmind is left nearly defenseless and defeat is imminent."
+msgstr ""
+
+msgid "A collective consciousness that controls all the alien structures in its vicinity. It must be protected at all costs, since its death will render alien structures defenseless."
+msgstr ""
+
+msgid "Used to obstruct corridors and doorways, hindering humans from threatening the spawns and Overmind. Barricades will shrink to allow aliens to pass over them, however."
+msgstr ""
+
+msgid "Ejects lethal poisonous acid at an approaching human. These are highly effective when used in conjunction with a trapper to hold the victim in place."
+msgstr ""
+
+msgid "Fires a blob of adhesive spit at any non-alien in its line of sight. This hinders their movement, making them an easy target for other defensive structures or aliens."
+msgstr ""
+
+msgid "Laces the attacks of any alien that touches it with a poison that will gradually deal damage to any humans exposed to it. The booster also increases the rate of health regeneration for any nearby aliens."
+msgstr ""
+
+msgid "Houses millions of tiny insectoid aliens. When a human approaches this structure, the insectoids attack."
+msgstr ""
+
+msgid "The most basic human structure. It provides a means for humans to enter the battle arena. Without any of these the humans cannot spawn and defeat is imminent."
+msgstr ""
+
+msgid "Automated base defense that is effective against large targets but slow to begin firing. Should always be backed up by physical support."
+msgstr ""
+
+msgid "A structure equipped with a strong electrical attack that fires instantly and always hits its target. It is effective against smaller aliens and for consolidating basic defense."
+msgstr ""
+
+msgid "An essential part of the human base, providing a means to upgrade the basic human equipment. A range of upgrades and weapons are available for sale from the armoury."
+msgstr ""
+
+msgid "A structure that enables self-repair functionality in human structures. Each Defence Computer built increases repair rate slightly."
+msgstr ""
+
+msgid "A structure that automatically restores the health and stamina of any human that stands on it. It may only be used by one person at a time. This structure also issues medkits."
+msgstr ""
+
+msgid "All structures except the telenode rely on a reactor to operate. The reactor provides power for all the human structures either directly or via repeaters. Only one reactor can be built at a time."
+msgstr ""
+
+msgid "A power distributor that transmits power from the reactor to remote locations, so that bases may be built far from the reactor."
+msgstr ""
+
+msgid "Similar to the base Granger, except that in addition to being able to build structures it has a spit attack that slows victims and the ability to crawl on walls."
+msgstr ""
+
+msgid "Has a lethal reflexive bite and the ability to crawl on walls and ceilings."
+msgstr ""
+
+msgid "A support class able to crawl on walls and ceilings. Its melee attack is most effective when combined with the ability to grab and hold its victims in place. Provides a weak healing aura that accelerates the healing rate of nearby aliens."
+msgstr ""
+
+msgid "In addition to the basic Basilisk abilities, the Advanced Basilisk sprays a poisonous gas which disorients any nearby humans. Has a strong healing aura that that accelerates the healing rate of nearby aliens."
+msgstr ""
+
+msgid "Has a melee attack and the ability to jump off walls. This allows the Marauder to gather great speed in enclosed areas."
+msgstr ""
+
+msgid "The Advanced Marauder has all the abilities of the basic Marauder with the addition of an area effect electric shock attack."
+msgstr ""
+
+msgid "Possesses a melee attack and the pounce ability, which may be used as both an attack and a means to reach remote locations inaccessible from the ground."
+msgstr ""
+
+msgid "In addition to the basic Dragoon abilities, the Advanced Dragoon has 3 barbs which may be used to attack humans from a distance."
+msgstr ""
+
+msgid "A large alien with a strong melee attack, this class can also charge at enemy humans and structures, inflicting great damage. Any humans or their structures caught under a falling Tyrant will be crushed by its weight."
+msgstr ""
+
+msgid "Basic weapon. Cased projectile weapon, with a slow clip based reload system."
+msgstr ""
+
+msgid "Similar to a chainsaw, but instead of a chain it has an electric arc capable of dealing a great deal of damage at close range."
+msgstr ""
+
+msgid "Close range weapon that is useful against larger foes. It has a slow repeat rate, but can be devastatingly effective."
+msgstr ""
+
+msgid "Slightly more powerful than the basic rifle, rapidly fires small packets of energy."
+msgstr ""
+
+msgid "A portable particle accelerator which causes minor nuclear reactions at the point of impact. It has a very large payload, but fires slowly."
+msgstr ""
+
+msgid "Belt drive, cased projectile weapon. It has a high repeat rate but a wide firing angle and is therefore relatively inaccurate."
+msgstr ""
+
+msgid "Sprays fire at its target. It is powered by compressed gas. The relatively low rate of fire means this weapon is most effective against static targets."
+msgstr ""
+
+msgid "An energy weapon that fires rapid pulses of concentrated energy."
+msgstr ""
+
+msgid "Blaster technology scaled up to deliver devastating power. Primary fire must be charged before firing. It has a quick secondary attack that does not require charging."
+msgstr ""
+
+msgid "Used for building structures. This includes spawns, power and basic defense. More structures become available with new stages."
+msgstr ""
+
+msgid "Protective armour that helps to defend against light alien melee attacks."
+msgstr ""
+
+msgid "In addition to protecting your head, the helmet provides a scanner indicating the presence of any friendly or hostile lifeforms and structures in your immediate vicinity."
+msgstr ""
+
+msgid "Back-mounted battery pack that permits storage of one and a half times the normal energy capacity for energy weapons."
+msgstr ""
+
+msgid "Back-mounted jet pack that enables the user to fly to remote locations. It is very useful against alien spawns in hard to reach spots."
+msgstr ""
+
+msgid "A full body armour that is highly effective at repelling alien attacks. It allows the user to enter hostile situations with a greater degree of confidence."
+msgstr ""
+
+msgid "A small incendinary device ideal for damaging tightly packed alien structures. Has a five second timer."
+msgstr ""
+
+msgid "Ammunition for the currently held weapon."
+msgstr ""
+
+
+# Misc
+msgid "ui/help.txt"
+msgstr "ui/help-jbo.txt"
diff --git a/po/tremulous.pot b/po/tremulous.pot
new file mode 100644
index 0000000..e2bbe84
--- /dev/null
+++ b/po/tremulous.pot
@@ -0,0 +1,4271 @@
+# SOME DESCRIPTIVE TITLE.
+# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
+# This file is distributed under the same license as the PACKAGE package.
+# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
+#
+#, fuzzy
+msgid ""
+msgstr ""
+"Project-Id-Version: PACKAGE VERSION\n"
+"Report-Msgid-Bugs-To: \n"
+"POT-Creation-Date: 2010-10-16 01:18+0000\n"
+"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
+"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
+"Language-Team: LANGUAGE <LL@li.org>\n"
+"Language: \n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=CHARSET\n"
+"Content-Transfer-Encoding: 8bit\n"
+
+#: src/cgame/cg_attachment.c:93 src/cgame/cg_attachment.c:156
+#: src/cgame/cg_attachment.c:204
+msgid "ERROR: Invalid attachmentType_t in attachment\n"
+msgstr ""
+
+#: src/cgame/cg_buildable.c:178 src/cgame/cg_buildable.c:269
+#: src/cgame/cg_players.c:115 src/cgame/cg_weapons.c:111
+#: src/cgame/cg_weapons.c:547
+#, possible-c-format
+msgid "File %s is %s\n"
+msgstr ""
+
+#: src/cgame/cg_buildable.c:234 src/cgame/cg_weapons.c:173
+#, possible-c-format
+msgid "Error parsing animation file: %s\n"
+msgstr ""
+
+#: src/cgame/cg_buildable.c:300
+#, possible-c-format
+msgid "Error parsing sound file: %s\n"
+msgstr ""
+
+#: src/cgame/cg_buildable.c:346
+#, possible-c-format
+msgid "WARNING: failed to load animation file %s\n"
+msgstr ""
+
+#: src/cgame/cg_buildable.c:351
+#, possible-c-format
+msgid "WARNING: failed to load sound file %s\n"
+msgstr ""
+
+#: src/cgame/cg_buildable.c:408 src/cgame/cg_players.c:845
+#: src/cgame/cg_weapons.c:813
+#, possible-c-format
+msgid "Bad animation number: %i"
+msgstr ""
+
+#: src/cgame/cg_buildable.c:420 src/cgame/cg_players.c:853
+#: src/cgame/cg_weapons.c:821
+#, possible-c-format
+msgid "Anim: %i\n"
+msgstr ""
+
+#: src/cgame/cg_buildable.c:441
+#, possible-c-format
+msgid "newAnimation: %d lf->animationNumber: %d lf->animation: %d\n"
+msgstr ""
+
+#: src/cgame/cg_buildable.c:450
+#, possible-c-format
+msgid "Sound for animation %d for a %s\n"
+msgstr ""
+
+#: src/cgame/cg_buildable.c:823
+#, possible-c-format
+msgid "CG_BuildableStatusParse: unknown token %s in %s\n"
+msgstr ""
+
+#: src/cgame/cg_consolecmds.c:180
+#, possible-c-format
+msgid "Listed %2d clients\n"
+msgstr ""
+
+#: src/cgame/cg_draw.c:1384 src/cgame/cg_draw.c:1390
+#, possible-c-format
+msgid "(Stage %d)"
+msgstr ""
+
+#: src/cgame/cg_draw.c:1438 src/cgame/cg_draw.c:1454
+#, possible-c-format
+msgid "Stage %d"
+msgstr ""
+
+#: src/cgame/cg_draw.c:1440
+#, possible-c-format
+msgid "Stage %d, 1 frag for next stage"
+msgstr ""
+
+#: src/cgame/cg_draw.c:1443
+#, possible-c-format
+msgid "Stage %d, %d frags for next stage"
+msgstr ""
+
+#: src/cgame/cg_draw.c:1456
+#, possible-c-format
+msgid "Stage %d, 1 credit for next stage"
+msgstr ""
+
+#: src/cgame/cg_draw.c:3201
+#, possible-c-format
+msgid "You are %d%s in the spawn queue"
+msgstr ""
+
+#: src/cgame/cg_draw.c:3208
+msgid "There are no spawns remaining"
+msgstr ""
+
+#: src/cgame/cg_draw.c:3210
+msgid "There is 1 spawn remaining"
+msgstr ""
+
+#: src/cgame/cg_draw.c:3212
+#, possible-c-format
+msgid "There are %d spawns remaining"
+msgstr ""
+
+#: src/cgame/cg_draw.c:3295
+msgid "Default HUD could not be found"
+msgstr ""
+
+#: src/cgame/cg_draw.c:3479
+msgid "CG_DrawActive: Undefined stereoView"
+msgstr ""
+
+#: src/cgame/cg_ents.c:903
+msgid "CG_InterpoateEntityPosition: cg.nextSnap == NULL"
+msgstr ""
+
+#: src/cgame/cg_ents.c:1012
+#, possible-c-format
+msgid "Entity %d entered PVS\n"
+msgstr ""
+
+#: src/cgame/cg_ents.c:1053
+#, possible-c-format
+msgid "Entity %d left PVS\n"
+msgstr ""
+
+#: src/cgame/cg_ents.c:1088
+#, possible-c-format
+msgid "Bad entity type: %i\n"
+msgstr ""
+
+#: src/cgame/cg_event.c:54
+msgid "CG_Obituary: target out of range"
+msgstr ""
+
+#: src/cgame/cg_event.c:199 src/cgame/cg_event.c:364
+#: src/cgame/cg_players.c:708 src/cgame/cg_players.c:713
+#: src/cgame/cg_players.c:716 src/cgame/cg_players.c:719
+#, possible-c-format
+msgid "%s"
+msgstr ""
+
+#: src/cgame/cg_event.c:222
+msgid "was sawn by"
+msgstr ""
+
+#: src/cgame/cg_event.c:225
+msgid "was blasted by"
+msgstr ""
+
+#: src/cgame/cg_event.c:228
+msgid "was machinegunned by"
+msgstr ""
+
+#: src/cgame/cg_event.c:231
+msgid "was chaingunned by"
+msgstr ""
+
+#: src/cgame/cg_event.c:234
+msgid "was gunned down by"
+msgstr ""
+
+#: src/cgame/cg_event.c:237
+msgid "was pulse rifled by"
+msgstr ""
+
+#: src/cgame/cg_event.c:240
+msgid "was mass driven by"
+msgstr ""
+
+#: src/cgame/cg_event.c:243
+msgid "was lasgunned by"
+msgstr ""
+
+#: src/cgame/cg_event.c:246
+msgid "was grilled by"
+msgstr ""
+
+#: src/cgame/cg_event.c:247 src/cgame/cg_event.c:251
+msgid "'s flamer"
+msgstr ""
+
+#: src/cgame/cg_event.c:250
+msgid "was toasted by"
+msgstr ""
+
+#: src/cgame/cg_event.c:254
+msgid "felt the full force of"
+msgstr ""
+
+#: src/cgame/cg_event.c:255 src/cgame/cg_event.c:259
+msgid "'s lucifer cannon"
+msgstr ""
+
+#: src/cgame/cg_event.c:258
+msgid "was caught in the fallout of"
+msgstr ""
+
+#: src/cgame/cg_event.c:262
+msgid "couldn't escape"
+msgstr ""
+
+#: src/cgame/cg_event.c:263
+msgid "'s grenade"
+msgstr ""
+
+#: src/cgame/cg_event.c:267
+msgid "should leave"
+msgstr ""
+
+#: src/cgame/cg_event.c:268
+msgid "'s buildings alone"
+msgstr ""
+
+#: src/cgame/cg_event.c:271
+msgid "was bitten by"
+msgstr ""
+
+#: src/cgame/cg_event.c:274
+msgid "was swiped by"
+msgstr ""
+
+#: src/cgame/cg_event.c:275 src/cgame/cg_event.c:281 src/cgame/cg_event.c:287
+#: src/cgame/cg_event.c:293 src/cgame/cg_event.c:299 src/cgame/cg_event.c:305
+#: src/cgame/cg_event.c:311 src/cgame/cg_event.c:317 src/cgame/cg_event.c:332
+#, possible-c-format
+msgid "'s %s"
+msgstr ""
+
+#: src/cgame/cg_event.c:280
+msgid "was clawed by"
+msgstr ""
+
+#: src/cgame/cg_event.c:286
+msgid "was zapped by"
+msgstr ""
+
+#: src/cgame/cg_event.c:292
+msgid "was chomped by"
+msgstr ""
+
+#: src/cgame/cg_event.c:298
+msgid "was pounced upon by"
+msgstr ""
+
+#: src/cgame/cg_event.c:304
+msgid "was sniped by"
+msgstr ""
+
+#: src/cgame/cg_event.c:310
+msgid "was mauled by"
+msgstr ""
+
+#: src/cgame/cg_event.c:316
+msgid "should have gotten out of the way of"
+msgstr ""
+
+#: src/cgame/cg_event.c:322
+msgid "was crushed under"
+msgstr ""
+
+#: src/cgame/cg_event.c:323
+msgid "'s weight"
+msgstr ""
+
+#: src/cgame/cg_event.c:327
+msgid "should have used a medkit against"
+msgstr ""
+
+#: src/cgame/cg_event.c:328
+msgid "'s poison"
+msgstr ""
+
+#: src/cgame/cg_event.c:331
+msgid "was gassed by"
+msgstr ""
+
+#: src/cgame/cg_event.c:339
+msgid "tried to invade"
+msgstr ""
+
+#: src/cgame/cg_event.c:340
+msgid "'s personal space"
+msgstr ""
+
+#: src/cgame/cg_event.c:343
+msgid "was killed by"
+msgstr ""
+
+#: src/cgame/cg_event.c:351
+msgid "TEAMMATE "
+msgstr ""
+
+#: src/cgame/cg_event.c:355
+msgid "You killed "
+msgstr ""
+
+#: src/cgame/cg_event.c:484
+#, possible-c-format
+msgid "ent:%3i  event:%3i %s\n"
+msgstr ""
+
+#: src/cgame/cg_event.c:904
+msgid "The Overmind is under attack!"
+msgstr ""
+
+#: src/cgame/cg_event.c:912
+msgid "The Overmind is dying!"
+msgstr ""
+
+#: src/cgame/cg_event.c:920
+msgid "Our base is under attack!"
+msgstr ""
+
+#: src/cgame/cg_event.c:932
+msgid "The Overmind needs spawns!"
+msgstr ""
+
+#: src/cgame/cg_event.c:992
+#, possible-c-format
+msgid "Unknown event: %i"
+msgstr ""
+
+#: src/cgame/cg_main.c:963
+#, possible-c-format
+msgid "CG_ConfigString: bad index: %i"
+msgstr ""
+
+#: src/cgame/cg_main.c:1025 src/cgame/cg_main.c:1301
+#, possible-c-format
+msgid "menu file not found: %s, using default\n"
+msgstr ""
+
+#: src/cgame/cg_main.c:1031 src/cgame/cg_main.c:1310
+#, possible-c-format
+msgid "menu file too large: %s is %i, max allowed is %i"
+msgstr ""
+
+#: src/cgame/cg_main.c:1305
+msgid "default menu file not found: ui/hud.txt, unable to continue!\n"
+msgstr ""
+
+#: src/cgame/cg_main.c:1345
+#, possible-c-format
+msgid "UI menu load time = %d milli seconds\n"
+msgstr ""
+
+#: src/cgame/cg_main.c:1510
+msgid "Ready"
+msgstr ""
+
+#: src/cgame/cg_main.c:1791
+#, possible-c-format
+msgid "Client/Server game mismatch: %s/%s"
+msgstr ""
+
+#: src/cgame/cg_main.c:1886
+msgid "WARNING: voipString overflowed\n"
+msgstr ""
+
+#: src/cgame/cg_marks.c:73
+msgid "CG_FreeLocalEntity: not active"
+msgstr ""
+
+#: src/cgame/cg_marks.c:153
+msgid "CG_ImpactMark called with <= 0 radius"
+msgstr ""
+
+#: src/cgame/cg_particles.c:253
+msgid "ERROR: a particle with velocityType normal has no normal\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:427
+#, possible-c-format
+msgid "PE %s created\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:452
+msgid "ERROR: a particle system has not been registered yet\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:474
+#, possible-c-format
+msgid "PS %s created\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:548
+#, possible-c-format
+msgid "Registered particle system %s\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:557
+#, possible-c-format
+msgid "ERROR: failed to register particle system %s\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:734
+msgid "ERROR: 'shader' not allowed in conjunction with 'model'\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:764
+msgid "ERROR: 'model' not allowed in conjunction with 'shader'\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:1126 src/cgame/cg_particles.c:1248
+#: src/cgame/cg_particles.c:1270 src/cgame/cg_trails.c:769
+#: src/cgame/cg_trails.c:791
+msgid "ERROR: missing '}'\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:1276 src/cgame/cg_particles.c:1282
+#: src/cgame/cg_trails.c:797 src/cgame/cg_trails.c:803
+msgid "ERROR: missing '{'\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:1384
+#, possible-c-format
+msgid "ERROR: unknown token '%s' in particle\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:1434
+msgid "ERROR: failed to parse particle\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:1440
+#, possible-c-format
+msgid "ERROR: ejector has > %d particles\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:1445
+#, possible-c-format
+msgid "ERROR: maximum number of particles (%d) reached\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:1522
+#, possible-c-format
+msgid "ERROR: unknown token '%s' in particle ejector\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:1558
+msgid "ERROR: failed to parse particle ejector\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:1568
+msgid "ERROR: ejector with 'count infinite' potentially has zero period\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:1574
+#, possible-c-format
+msgid "ERROR: particle system has > %d ejectors\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:1579
+#, possible-c-format
+msgid "ERROR: maximum number of particle ejectors (%d) reached\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:1599
+#, possible-c-format
+msgid "Parsed particle system %s\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:1605
+#, possible-c-format
+msgid "ERROR: unknown token '%s' in particle system %s\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:1639
+#, possible-c-format
+msgid "ERROR: particle file %s is %s\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:1668
+#, possible-c-format
+msgid "ERROR: a particle system is already named %s\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:1677
+#, possible-c-format
+msgid "ERROR: %s: failed to parse particle system %s\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:1686
+#, possible-c-format
+msgid "ERROR: maximum number of particle systems (%d) reached\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:1697
+msgid "ERROR: unamed particle system\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:1709
+msgid "ERROR: particle system already named\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:1766 src/cgame/cg_trails.c:1184
+#, possible-c-format
+msgid "...loading '%s'\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:1795
+#, possible-c-format
+msgid "WARNING: failed to find child %s\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:1820
+#, possible-c-format
+msgid "WARNING: failed to find onDeath system %s\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:1836
+msgid "WARNING: tried to modify a NULL particle system\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:1866
+msgid "WARNING: tried to destroy a NULL particle system\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:1871
+msgid "PS destroyed\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:1898
+msgid "WARNING: tried to test a NULL particle system\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:1904
+msgid "WARNING: tried to test an invalid particle system\n"
+msgstr ""
+
+#: src/cgame/cg_particles.c:1990
+#, possible-c-format
+msgid "PS %s garbage collected\n"
+msgstr ""
+
+#: src/cgame/cg_players.c:72
+#, possible-c-format
+msgid "Unknown custom sound: %s"
+msgstr ""
+
+#: src/cgame/cg_players.c:115 src/cgame/cg_trails.c:1067
+#: src/cgame/cg_weapons.c:111 src/cgame/cg_weapons.c:547
+msgid "empty"
+msgstr ""
+
+#: src/cgame/cg_players.c:115 src/cgame/cg_trails.c:1067
+#: src/cgame/cg_weapons.c:111 src/cgame/cg_weapons.c:547
+msgid "too long"
+msgstr ""
+
+#: src/cgame/cg_players.c:159
+#, possible-c-format
+msgid "Bad footsteps parm in %s: %s\n"
+msgstr ""
+
+#: src/cgame/cg_players.c:215
+#, possible-c-format
+msgid "unknown token '%s' is %s\n"
+msgstr ""
+
+#: src/cgame/cg_players.c:288 src/cgame/cg_players.c:368
+#, possible-c-format
+msgid "Error parsing animation file: %s"
+msgstr ""
+
+#: src/cgame/cg_players.c:394
+#, possible-c-format
+msgid "Leg skin load failure: %s\n"
+msgstr ""
+
+#: src/cgame/cg_players.c:399
+#, possible-c-format
+msgid "Torso skin load failure: %s\n"
+msgstr ""
+
+#: src/cgame/cg_players.c:404
+#, possible-c-format
+msgid "Head skin load failure: %s\n"
+msgstr ""
+
+#: src/cgame/cg_players.c:414
+#, possible-c-format
+msgid "Non-segmented skin load failure: %s\n"
+msgstr ""
+
+#: src/cgame/cg_players.c:437
+#, possible-c-format
+msgid "Failed to load animation file %s\n"
+msgstr ""
+
+#: src/cgame/cg_players.c:449 src/cgame/cg_players.c:457
+#: src/cgame/cg_players.c:465 src/cgame/cg_players.c:475
+#, possible-c-format
+msgid "Failed to load model file %s\n"
+msgstr ""
+
+#: src/cgame/cg_players.c:483
+#, possible-c-format
+msgid "Failed to load skin file: %s : %s\n"
+msgstr ""
+
+#: src/cgame/cg_players.c:506
+#, possible-c-format
+msgid "CG_RegisterClientModelname( %s, %s ) failed"
+msgstr ""
+
+#: src/cgame/cg_players.c:1113 src/cgame/cg_players.c:1360
+msgid "Bad player movement angle"
+msgstr ""
+
+#: src/cgame/cg_players.c:1895
+msgid "Bad clientNum on player entity"
+msgstr ""
+
+#: src/cgame/cg_players.c:2169
+#, possible-c-format
+msgid "Bad corpseNum on corpse entity: %d"
+msgstr ""
+
+#: src/cgame/cg_playerstate.c:235
+msgid "WARNING: changed predicted event\n"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:94
+#, possible-c-format
+msgid "[skipnotify]CG_ParseTeamInfo: bad client number: %d\n"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:238
+msgid "We have evolved!"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:252
+msgid "Reinforcements have arrived!"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:473
+msgid "Unknown item"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:478
+msgid ""
+"The alien team has too many players. Please wait until slots become "
+"available or join the human team."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:480
+msgid "The alien team has too many players"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:485
+msgid ""
+"The human team has too many players. Please wait until slots become "
+"available or join the alien team."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:487
+msgid "The human team has too many players"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:492
+msgid "The alien team is locked. You cannot join the aliens at this time."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:494
+msgid "The alien team is locked"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:499
+msgid "The human team is locked. You cannot join the humans at this time."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:501
+msgid "The human team is locked"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:506
+msgid ""
+"The maximum number of playing clients has been reached. Please wait until "
+"slots become available."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:508
+msgid "No free player slots"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:513
+msgid "You must wait until the warmup time is finished before joining a team. "
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:515
+msgid "You cannot join a team during warmup."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:520
+msgid "You cannot leave the Alien team until your build timer has expired."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:522 src/cgame/cg_servercmds.c:529
+msgid "You cannot change teams until your build timer expires"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:527
+msgid "You cannot leave the Human team until your build timer has expired."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:535
+msgid "You cannot build the Reactor or the Overmind near a domination point. Domination points represent halfway points between bases, not base locations."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:538
+msgid "Cannot build Reactor or Overmind near a domination point"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:541
+msgid "Cheats are not enabled on this server"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:546
+msgid ""
+"Cheats are not enabled on this server, so you may not use this command while "
+"on a team"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:554
+msgid "Join a team first"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:561
+msgid "You can only use this command when spectating"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:567
+msgid "Must be alien to use this command"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:573
+msgid "Must be human to use this command"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:579
+msgid "Must be living to use this command"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:587
+msgid ""
+"There is no room to build here. Move until the structure turns translucent "
+"green, indicating a valid build location."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:589
+msgid "There is no room to build here"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:594
+msgid ""
+"Cannot build on this surface. The surface is too steep or unsuitable for "
+"building. Please choose another site for this structure."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:597
+msgid "Cannot build on this surface"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:603
+msgid "You cannot build that structure"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:609
+msgid ""
+"This action would remove your team's last spawn point, which often quickly "
+"results in a loss. Try building more spawns."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:612
+msgid "You may not deconstruct the last spawn"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:616
+msgid ""
+"Neither team has prevailed after a certain time and the game has entered "
+"Sudden Death. During Sudden Death building is not allowed."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:619
+msgid "Cannot build during Sudden Death"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:624
+msgid ""
+"Your teammates have lost faith in your ability to build for the team. You "
+"will not be allowed to build until your team votes to reinstate your "
+"building rights."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:627
+msgid "Your building rights have been revoked"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:632
+msgid ""
+"Your team has decided to admit defeat and concede the game:traitors and "
+"cowards are not allowed to build."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:635
+msgid "Building is denied to traitorous cowards"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:642
+msgid ""
+"There is no power remaining. Free up power by marking existing buildable "
+"objects."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:645
+msgid ""
+"There is no power remaining. Free up power by deconstructing existing "
+"buildable objects."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:647
+msgid "There is no power remaining"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:652
+msgid ""
+"This buildable is not powered. Build a Reactor and/or Repeater in order to "
+"power it."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:654
+msgid "This buildable is not powered"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:659
+msgid ""
+"There can only be one Reactor. Deconstruct the existing one if you wish to "
+"move it."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:661
+msgid "There can only be one Reactor"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:666
+msgid ""
+"There is no power here. If available, a Repeater may be used to transmit "
+"power to this location."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:668
+msgid "There is no power here"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:673
+msgid ""
+"There is no Defense Computer. A Defense Computer is needed to build this."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:675
+msgid "There is no Defense Computer"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:680
+msgid "This area already has power. A Repeater is not required here."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:681
+msgid "This area already has power"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:686
+msgid ""
+"You have no room to carry this. Please sell any conflicting upgrades before "
+"purchasing this item."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:688
+msgid "You have no room to carry this"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:693
+msgid ""
+"Insufficient funds. You do not have enough credits to perform this action."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:695
+msgid "Insufficient funds"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:700
+msgid ""
+"You already hold this item. It is not possible to carry multiple items of "
+"the same type."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:702
+msgid "You already hold this item"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:707
+msgid ""
+"You must be near a powered Armoury in order to purchase weapons, upgrades or "
+"ammunition."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:709
+msgid "You must be near a powered Armoury"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:714
+msgid ""
+"You must be near a Reactor or a powered Armoury or Repeater in order to "
+"purchase energy ammunition."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:716
+msgid "You must be near a Reactor or a powered Armoury or Repeater"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:721
+msgid ""
+"There is not enough room here to put on a Battle Suit. Make sure you have "
+"enough head room to climb in."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:723
+msgid "Not enough room here to put on a Battle Suit"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:728
+msgid ""
+"There is not enough room here to take off your Battle Suit. Make sure you "
+"have enough head room to climb out."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:730
+msgid "Not enough room here to take off your Battle Suit"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:735
+msgid ""
+"You are not allowed to buy or sell weapons until your build timer has "
+"expired."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:737
+msgid "You can not buy or sell weapons until your build timer expires"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:743
+msgid "You must be dead to use the class command"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:748
+msgid "Unknown starting item"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:755
+msgid ""
+"There is no creep here. You must build near existing Eggs or the Overmind. "
+"Alien structures will not support themselves."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:757
+msgid "There is no creep here"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:762
+msgid ""
+"There is no Overmind. An Overmind must be built to control the structure you "
+"tried to place."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:764 src/cgame/cg_servercmds.c:799
+msgid "There is no Overmind"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:769
+msgid ""
+"There can only be one Overmind. Deconstruct the existing one if you wish to "
+"move it."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:771
+msgid "There can only be one Overmind"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:776
+msgid ""
+"The Overmind cannot control any more structures. Deconstruct existing "
+"structures to build more."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:778
+msgid "The Overmind cannot control any more structures"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:783
+msgid ""
+"There is no room to evolve here. Move away from walls or other nearby "
+"objects and try again."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:785
+msgid "There is no room to evolve here"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:790
+msgid ""
+"This location is too close to the enemy to evolve. Move away from the "
+"enemy's presence and try again."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:792
+msgid "This location is too close to the enemy to evolve"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:797
+msgid ""
+"There is no Overmind. An Overmind must be built to allow you to upgrade."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:804
+msgid "You cannot evolve until your build timer has expired."
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:805
+msgid "You cannot evolve until your build timer expires"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:819
+#, possible-c-format
+msgid "You cannot evolve into a %s"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:825
+msgid "You cannot evolve while wallwalking"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:830
+msgid "Unknown class"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:835
+#, possible-c-format
+msgid "You cannot spawn as a %s"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:841
+#, possible-c-format
+msgid "The %s is not allowed"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:847
+#, possible-c-format
+msgid "The %s is not allowed at Stage %d"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:854
+#, possible-c-format
+msgid "cgame: debug: no such menu %d\n"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:986
+#, possible-c-format
+msgid "%sPrivate message from: "
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:1032
+#, possible-c-format
+msgid "[skipnotify]WARNING: could not find voice \"%s\"\n"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:1038
+#, possible-c-format
+msgid "[skipnotify]WARNING: could not find command %d in voice \"%s\"\n"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:1045
+#, possible-c-format
+msgid ""
+"[skipnotify]WARNING: could not find track %d for command %d in voice \"%s\"\n"
+msgstr ""
+
+#: src/cgame/cg_servercmds.c:1295
+#, possible-c-format
+msgid "Unknown client game command: %s\n"
+msgstr ""
+
+#: src/cgame/cg_snapshot.c:137
+msgid "CG_TransitionSnapshot: NULL cg.snap"
+msgstr ""
+
+#: src/cgame/cg_snapshot.c:140
+msgid "CG_TransitionSnapshot: NULL cg.nextSnap"
+msgstr ""
+
+#: src/cgame/cg_snapshot.c:262
+#, possible-c-format
+msgid "WARNING: CG_ReadNextSnapshot: way out of range, %i > %i"
+msgstr ""
+
+#: src/cgame/cg_snapshot.c:340
+msgid "CG_ProcessSnapshots: n < cg.latestSnapshotNum"
+msgstr ""
+
+#: src/cgame/cg_snapshot.c:384
+msgid "CG_ProcessSnapshots: Server time went backwards"
+msgstr ""
+
+#: src/cgame/cg_snapshot.c:397
+msgid "CG_ProcessSnapshots: cg.snap == NULL"
+msgstr ""
+
+#: src/cgame/cg_snapshot.c:406
+msgid "CG_ProcessSnapshots: cg.nextSnap->serverTime <= cg.time"
+msgstr ""
+
+#: src/cgame/cg_trails.c:715
+msgid "WARNING: too many segments in trail beam\n"
+msgstr ""
+
+#: src/cgame/cg_trails.c:873
+#, possible-c-format
+msgid "ERROR: unknown textureType clamp \"%s\"\n"
+msgstr ""
+
+#: src/cgame/cg_trails.c:885
+#, possible-c-format
+msgid "ERROR: unknown textureType \"%s\"\n"
+msgstr ""
+
+#: src/cgame/cg_trails.c:901
+msgid "ERROR: too many jitters\n"
+msgstr ""
+
+#: src/cgame/cg_trails.c:931
+#, possible-c-format
+msgid "ERROR: unknown token '%s' in trail beam\n"
+msgstr ""
+
+#: src/cgame/cg_trails.c:986
+msgid "ERROR: failed to parse trail beam\n"
+msgstr ""
+
+#: src/cgame/cg_trails.c:992
+#, possible-c-format
+msgid "ERROR: trail system has > %d beams\n"
+msgstr ""
+
+#: src/cgame/cg_trails.c:997
+#, possible-c-format
+msgid "ERROR: maximum number of trail beams (%d) reached\n"
+msgstr ""
+
+#: src/cgame/cg_trails.c:1026
+#, possible-c-format
+msgid "Parsed trail system %s\n"
+msgstr ""
+
+#: src/cgame/cg_trails.c:1032
+#, possible-c-format
+msgid "ERROR: unknown token '%s' in trail system %s\n"
+msgstr ""
+
+#: src/cgame/cg_trails.c:1066
+#, possible-c-format
+msgid "ERROR: trail file %s is %s\n"
+msgstr ""
+
+#: src/cgame/cg_trails.c:1095
+#, possible-c-format
+msgid "ERROR: a trail system is already named %s\n"
+msgstr ""
+
+#: src/cgame/cg_trails.c:1104
+#, possible-c-format
+msgid "ERROR: %s: failed to parse trail system %s\n"
+msgstr ""
+
+#: src/cgame/cg_trails.c:1113
+#, possible-c-format
+msgid "ERROR: maximum number of trail systems (%d) reached\n"
+msgstr ""
+
+#: src/cgame/cg_trails.c:1124
+msgid "ERROR: unamed trail system\n"
+msgstr ""
+
+#: src/cgame/cg_trails.c:1136
+msgid "ERROR: trail system already named\n"
+msgstr ""
+
+#: src/cgame/cg_trails.c:1220
+#, possible-c-format
+msgid "Registered trail system %s\n"
+msgstr ""
+
+#: src/cgame/cg_trails.c:1229
+#, possible-c-format
+msgid "ERROR: failed to register trail system %s\n"
+msgstr ""
+
+#: src/cgame/cg_trails.c:1263
+#, possible-c-format
+msgid "TB %s created\n"
+msgstr ""
+
+#: src/cgame/cg_trails.c:1270
+msgid "MAX_TRAIL_BEAMS\n"
+msgstr ""
+
+#: src/cgame/cg_trails.c:1291
+msgid "ERROR: a trail system has not been registered yet\n"
+msgstr ""
+
+#: src/cgame/cg_trails.c:1314
+#, possible-c-format
+msgid "TS %s created\n"
+msgstr ""
+
+#: src/cgame/cg_trails.c:1321
+msgid "MAX_TRAIL_SYSTEMS\n"
+msgstr ""
+
+#: src/cgame/cg_trails.c:1435
+#, possible-c-format
+msgid "TS %s expired (born %d, lives %d, now %d)\n"
+msgstr ""
+
+#: src/cgame/cg_trails.c:1441
+#, possible-c-format
+msgid "TS %s garbage collected\n"
+msgstr ""
+
+#: src/cgame/cg_trails.c:1482
+#, possible-c-format
+msgid "TS: %d  TB: %d\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:117
+msgid " or "
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:124
+#, possible-c-format
+msgid "^K^E^Y^7%s or %s"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:128
+#, possible-c-format
+msgid "^K^E^Y^7%s"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:133
+#, possible-c-format
+msgid "\"%s\" (unbound)"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:191 src/cgame/cg_tutorial.c:367
+#, possible-c-format
+msgid "Press %s to place the %s\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:196 src/cgame/cg_tutorial.c:372
+#, possible-c-format
+msgid "Press %s to cancel placing the %s\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:203 src/cgame/cg_tutorial.c:379
+#, possible-c-format
+msgid "Press %s to build a structure\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:214 src/cgame/cg_tutorial.c:390
+#, possible-c-format
+msgid "Press %s to unmark this structure\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:220 src/cgame/cg_tutorial.c:396
+#, possible-c-format
+msgid "Press %s to mark this structure\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:227 src/cgame/cg_tutorial.c:403
+#, possible-c-format
+msgid "Press %s to destroy this structure\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:235 src/cgame/cg_tutorial.c:277
+#: src/cgame/cg_tutorial.c:346
+#, possible-c-format
+msgid "Press %s to swipe\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:242 src/cgame/cg_tutorial.c:329
+#, possible-c-format
+msgid "Press %s to launch a projectile\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:246 src/cgame/cg_tutorial.c:262
+#: src/cgame/cg_tutorial.c:288
+#, possible-c-format
+msgid "Press %s to walk on walls\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:259
+msgid "Touch humans to damage them\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:274
+msgid "Touch humans to grab them\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:283
+#, possible-c-format
+msgid "Press %s to spray poisonous gas\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:300 src/cgame/cg_tutorial.c:323
+#, possible-c-format
+msgid "Press %s to bite\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:306
+#, possible-c-format
+msgid "Press %s to invoke an electrical attack\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:311
+#, possible-c-format
+msgid "Hold down %s then touch a wall to wall jump\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:334
+#, possible-c-format
+msgid "Hold down and release %s to pounce\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:350
+#, possible-c-format
+msgid "Hold down and release %s to trample\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:437
+#, possible-c-format
+msgid "Find an Armoury and press %s for more ammo\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:446
+#, possible-c-format
+msgid "Find a Reactor or Repeater and press %s for more ammo\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:466 src/cgame/cg_tutorial.c:473
+#: src/cgame/cg_tutorial.c:495
+#, possible-c-format
+msgid "Press %s to fire the %s\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:478
+#, possible-c-format
+msgid "Hold %s to zoom\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:484
+#, possible-c-format
+msgid "Hold %s to activate the %s\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:491
+#, possible-c-format
+msgid "Hold and release %s to fire a charged shot\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:510
+#, possible-c-format
+msgid "Press %s and "
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:513
+#, possible-c-format
+msgid "%s to select an upgrade\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:520
+#, possible-c-format
+msgid "Press %s to use the %s\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:529
+#, possible-c-format
+msgid "Press %s to use your %s\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:537
+msgid "You are blacking out. Stop sprinting to recover stamina.\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:542
+msgid "Your stamina is low. Stop sprinting to recover.\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:548
+#, possible-c-format
+msgid "Press %s to use this structure\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:553
+#, possible-c-format
+msgid "Press %s and any direction to sprint\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:557
+#, possible-c-format
+msgid "Press %s and back or strafe to dodge\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:572
+#, possible-c-format
+msgid "Press %s to leave spawn queue\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:576
+#, possible-c-format
+msgid "Press %s to spawn\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:582
+#, possible-c-format
+msgid "Press %s to join a team\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:590
+#, possible-c-format
+msgid "Press %s to switch to chase-cam spectator mode\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:594
+#, possible-c-format
+msgid "Press %s to return to free spectator mode\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:598
+#, possible-c-format
+msgid "Press %s or "
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:601
+#, possible-c-format
+msgid "%s to change player\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:607
+#, possible-c-format
+msgid "Press %s to follow a player\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:684
+#, possible-c-format
+msgid "Press %s to evolve\n"
+msgstr ""
+
+#: src/cgame/cg_tutorial.c:690
+msgid "Press ESC for the menu"
+msgstr ""
+
+#: src/cgame/cg_view.c:101 src/cgame/cg_view.c:180
+msgid "Can't register model\n"
+msgstr ""
+
+#: src/cgame/cg_view.c:1500
+#, possible-c-format
+msgid "cg.clientFrame:%i\n"
+msgstr ""
+
+#: src/cgame/cg_weapons.c:53
+#, possible-c-format
+msgid "Couldn't find upgrade %i"
+msgstr ""
+
+#: src/cgame/cg_weapons.c:213
+#, possible-c-format
+msgid "ERROR: missile model not found %s\n"
+msgstr ""
+
+#: src/cgame/cg_weapons.c:239
+#, possible-c-format
+msgid "ERROR: missile sprite not found %s\n"
+msgstr ""
+
+#: src/cgame/cg_weapons.c:298
+#, possible-c-format
+msgid "ERROR: missile particle system not found %s\n"
+msgstr ""
+
+#: src/cgame/cg_weapons.c:311
+#, possible-c-format
+msgid "ERROR: missile trail system not found %s\n"
+msgstr ""
+
+#: src/cgame/cg_weapons.c:324
+#, possible-c-format
+msgid "ERROR: muzzle particle system not found %s\n"
+msgstr ""
+
+#: src/cgame/cg_weapons.c:337
+#, possible-c-format
+msgid "ERROR: impact particle system not found %s\n"
+msgstr ""
+
+#: src/cgame/cg_weapons.c:362
+#, possible-c-format
+msgid "ERROR: impact mark shader not found %s\n"
+msgstr ""
+
+#: src/cgame/cg_weapons.c:514
+#, possible-c-format
+msgid "ERROR: unknown token '%s' in weapon section\n"
+msgstr ""
+
+#: src/cgame/cg_weapons.c:573
+msgid "ERROR: weapon mode section started without a declaration\n"
+msgstr ""
+
+#: src/cgame/cg_weapons.c:578
+msgid "ERROR: failed to parse weapon mode section\n"
+msgstr ""
+
+#: src/cgame/cg_weapons.c:613
+#, possible-c-format
+msgid "ERROR: weapon model not found %s\n"
+msgstr ""
+
+#: src/cgame/cg_weapons.c:644
+#, possible-c-format
+msgid "ERROR: 3rd person weapon model not found %s\n"
+msgstr ""
+
+#: src/cgame/cg_weapons.c:679
+#, possible-c-format
+msgid "ERROR: weapon icon not found %s\n"
+msgstr ""
+
+#: src/cgame/cg_weapons.c:704
+#, possible-c-format
+msgid "ERROR: weapon crosshair not found %s\n"
+msgstr ""
+
+#: src/cgame/cg_weapons.c:715
+#, possible-c-format
+msgid "ERROR: unknown token '%s'\n"
+msgstr ""
+
+#: src/cgame/cg_weapons.c:746
+#, possible-c-format
+msgid "Couldn't find weapon %i"
+msgstr ""
+
+#: src/cgame/cg_weapons.c:753 src/cgame/cg_weapons.c:758
+#, possible-c-format
+msgid "ERROR: failed to parse %s\n"
+msgstr ""
+
+#: src/cgame/cg_weapons.c:1701
+msgid "CG_FireWeapon: ent->weapon >= WP_NUM_WEAPONS"
+msgstr ""
+
+#: src/client/cl_avi.c:85
+msgid "Failed to write avi file\n"
+msgstr ""
+
+#: src/client/cl_avi.c:145
+msgid "ERROR: Top of chunkstack breached\n"
+msgstr ""
+
+#: src/client/cl_avi.c:165
+msgid "ERROR: Bottom of chunkstack breached\n"
+msgstr ""
+
+#: src/client/cl_avi.c:387
+#, possible-c-format
+msgid ""
+"WARNING: cl_aviFrameRate is not a divisor of the audio rate, suggest %d\n"
+msgstr ""
+
+#: src/client/cl_avi.c:399
+#, possible-c-format
+msgid "WARNING: Audio format of %d bit/%d channels not supported"
+msgstr ""
+
+#: src/client/cl_avi.c:409
+msgid ""
+"WARNING: Audio capture is not supported with OpenAL. Set s_useOpenAL to 0 "
+"for audio capture\n"
+msgstr ""
+
+#: src/client/cl_avi.c:531
+msgid "WARNING: Audio capture buffer overflow -- truncating\n"
+msgstr ""
+
+#: src/client/cl_avi.c:658
+#, possible-c-format
+msgid "Wrote %d:%d frames to %s\n"
+msgstr ""
+
+#: src/client/cl_cgame.c:151
+#, possible-c-format
+msgid "CL_GetSnapshot: truncated %i entities to %i\n"
+msgstr ""
+
+#: src/client/cl_cgame.c:239 src/client/cl_parse.c:494
+msgid "MAX_GAMESTATE_CHARS exceeded"
+msgstr ""
+
+#: src/client/cl_cgame.c:275
+msgid "CL_GetServerCommand: a reliable command was cycled out"
+msgstr ""
+
+#: src/client/cl_cgame.c:280
+msgid "CL_GetServerCommand: requested a command not received"
+msgstr ""
+
+#: src/client/cl_cgame.c:298
+#, possible-c-format
+msgid "Server disconnected - %s"
+msgstr ""
+
+#: src/client/cl_cgame.c:300
+msgid "Server disconnected\n"
+msgstr ""
+
+#: src/client/cl_cgame.c:311 src/client/cl_cgame.c:320
+msgid "bcs exceeded BIG_INFO_STRING"
+msgstr ""
+
+#: src/client/cl_cgame.c:746
+#, possible-c-format
+msgid "Bad cgame system trap: %ld"
+msgstr ""
+
+#: src/client/cl_cgame.c:785
+msgid "VM_Create on cgame failed"
+msgstr ""
+
+#: src/client/cl_cgame.c:804
+#, possible-c-format
+msgid "CL_InitCGame: %5.2f seconds\n"
+msgstr ""
+
+#: src/client/cl_cgame.c:970
+#, possible-c-format
+msgid "Mumble: Linking to Mumble application %s\n"
+msgstr ""
+
+#: src/client/cl_cin.c:160
+msgid "CIN_HandleForVideo: none free"
+msgstr ""
+
+#: src/client/cl_cin.c:1007
+msgid "HACK: approxmimating cinematic for Rage Pro or Voodoo\n"
+msgstr ""
+
+#: src/client/cl_cin.c:1274
+msgid "finished cinematic\n"
+msgstr ""
+
+#: src/client/cl_console.c:115
+msgid "usage: condump <filename>\n"
+msgstr ""
+
+#: src/client/cl_console.c:119
+#, possible-c-format
+msgid "Dumped console text to %s.\n"
+msgstr ""
+
+#: src/client/cl_console.c:124 src/client/cl_main.c:698
+msgid "ERROR: couldn't open.\n"
+msgstr ""
+
+#: src/client/cl_curl.c:73
+#, possible-c-format
+msgid "Can't load symbol %s\n"
+msgstr ""
+
+#: src/client/cl_curl.c:79
+#, possible-c-format
+msgid "Loaded symbol %s (0x%p)\n"
+msgstr ""
+
+#: src/client/cl_curl.c:97
+#, possible-c-format
+msgid "Loading \"%s\"..."
+msgstr ""
+
+#: src/client/cl_curl.c:149
+msgid "FAIL One or more symbols not found\n"
+msgstr ""
+
+#: src/client/cl_curl.c:152
+msgid "OK\n"
+msgstr ""
+
+#: src/client/cl_curl.c:232
+#, possible-c-format
+msgid "URL: %s\n"
+msgstr ""
+
+#: src/client/cl_curl.c:260
+#, possible-c-format
+msgid "CL_cURL_BeginDownload: failed to open %s for writing\n"
+msgstr ""
+
+#: src/client/cl_curl.c:287
+msgid "CL_cURL_BeginDownload: qcurl_multi_init() failed\n"
+msgstr ""
+
+#: src/client/cl_curl.c:332
+#, possible-c-format
+msgid "Download Error: %s Code: %ld URL: %s"
+msgstr ""
+
+#: src/client/cl_input.c:97
+msgid "Three keys down for a button!\n"
+msgstr ""
+
+#: src/client/cl_input.c:392
+#, possible-c-format
+msgid "CL_JoystickEvent: bad axis %i"
+msgstr ""
+
+#: src/client/cl_keys.c:888
+msgid "unbind <key> : remove commands from a key\n"
+msgstr ""
+
+#: src/client/cl_keys.c:895 src/client/cl_keys.c:937
+#, possible-c-format
+msgid "\"%s\" isn't a valid key\n"
+msgstr ""
+
+#: src/client/cl_keys.c:931
+msgid "bind <key> [command] : attach a command to a key\n"
+msgstr ""
+
+#: src/client/cl_keys.c:946
+#, possible-c-format
+msgid "\"%s\" is not bound\n"
+msgstr ""
+
+#: src/client/cl_keys.c:1373 src/client/cl_keys.c:1420
+#, possible-c-format
+msgid "Couldn't read %s.\n"
+msgstr ""
+
+#: src/client/cl_keys.c:1401
+msgid "WARNING: probable corrupt history\n"
+msgstr ""
+
+#: src/client/cl_keys.c:1473 src/client/cl_keys.c:1478
+#, possible-c-format
+msgid "Couldn't write %s.\n"
+msgstr ""
+
+#: src/client/cl_main.c:202 src/client/cl_main.c:301
+msgid "VoIP: invalid player ID#\n"
+msgstr ""
+
+#: src/client/cl_main.c:214
+#, possible-c-format
+msgid "VoIP: player #%d gain now set to %f\n"
+msgstr ""
+
+#: src/client/cl_main.c:258
+#, possible-c-format
+msgid "WARNING: VoIP target %d is not a valid client number\n"
+msgstr ""
+
+#: src/client/cl_main.c:284
+#, possible-c-format
+msgid "VoIP: command ignored: %s\n"
+msgstr ""
+
+#: src/client/cl_main.c:298
+#, possible-c-format
+msgid "VoIP: current gain for player #%d is %f\n"
+msgstr ""
+
+#: src/client/cl_main.c:304
+msgid "usage: voip gain <playerID#> [value]\n"
+msgstr ""
+
+#: src/client/cl_main.c:307
+msgid "VoIP: muting incoming voice\n"
+msgstr ""
+
+#: src/client/cl_main.c:311
+msgid "VoIP: unmuting incoming voice\n"
+msgstr ""
+
+#: src/client/cl_main.c:315
+msgid ""
+"usage: voip [un]ignore <playerID#>\n"
+"       voip [un]muteall\n"
+"       voip gain <playerID#> [value]\n"
+msgstr ""
+
+#: src/client/cl_main.c:474
+#, possible-c-format
+msgid "VoIP: Send %d frames, %d bytes, %f power\n"
+msgstr ""
+
+#: src/client/cl_main.c:529
+msgid "Client command overflow"
+msgstr ""
+
+#: src/client/cl_main.c:596
+msgid "Not recording a demo.\n"
+msgstr ""
+
+#: src/client/cl_main.c:608
+msgid "Stopped demo.\n"
+msgstr ""
+
+#: src/client/cl_main.c:661
+msgid "Already recording.\n"
+msgstr ""
+
+#: src/client/cl_main.c:667
+msgid "You must be in a level to record.\n"
+msgstr ""
+
+#: src/client/cl_main.c:673
+msgid ""
+"WARNING: You should set 'g_synchronousClients 1' for smoother demo "
+"recording\n"
+msgstr ""
+
+#: src/client/cl_main.c:695
+#, possible-c-format
+msgid "recording to %s.\n"
+msgstr ""
+
+#: src/client/cl_main.c:863
+#, possible-c-format
+msgid "Couldn't open %s for writing\n"
+msgstr ""
+
+#: src/client/cl_main.c:917
+msgid "Demo file was truncated.\n"
+msgstr ""
+
+#: src/client/cl_main.c:1015
+#, possible-c-format
+msgid "Protocol %d not supported for demos\n"
+msgstr ""
+
+#: src/client/cl_main.c:1025
+#, possible-c-format
+msgid "couldn't open %s"
+msgstr ""
+
+#: src/client/cl_main.c:1302
+msgid "Mumble: Unlinking from Mumble application\n"
+msgstr ""
+
+#: src/client/cl_main.c:1402
+#, possible-c-format
+msgid "Unknown command \"%s"
+msgstr ""
+
+#: src/client/cl_main.c:1425
+#, possible-c-format
+msgid "Resolving %s\n"
+msgstr ""
+
+#: src/client/cl_main.c:1431
+msgid "Couldn't resolve master address\n"
+msgstr ""
+
+#: src/client/cl_main.c:1440 src/client/cl_main.c:1573
+#, possible-c-format
+msgid "%s resolved to %s\n"
+msgstr ""
+
+#: src/client/cl_main.c:1470 src/client/cl_main.c:1818
+msgid "Not connected to a server.\n"
+msgstr ""
+
+#: src/client/cl_main.c:1489
+msgid "Disconnected from server"
+msgstr ""
+
+#: src/client/cl_main.c:1502
+msgid "Can't reconnect to localhost.\n"
+msgstr ""
+
+#: src/client/cl_main.c:1535 src/client/cl_main.c:4193
+#: src/client/cl_main.c:4359
+msgid "warning: only -4 or -6 as address type understood.\n"
+msgstr ""
+
+#: src/client/cl_main.c:1563
+msgid "Bad server address\n"
+msgstr ""
+
+#: src/client/cl_main.c:1632
+msgid ""
+"You must set 'rconpassword' before\n"
+"issuing an rcon command.\n"
+msgstr ""
+
+#: src/client/cl_main.c:1655
+msgid ""
+"You must either be connected,\n"
+"or set the 'rconAddress' cvar\n"
+"to issue rcon commands\n"
+msgstr ""
+
+#: src/client/cl_main.c:1796
+#, possible-c-format
+msgid "Opened PK3 Names: %s\n"
+msgstr ""
+
+#: src/client/cl_main.c:1805
+#, possible-c-format
+msgid "Referenced PK3 Names: %s\n"
+msgstr ""
+
+#: src/client/cl_main.c:1837
+msgid "--------- Client Information ---------\n"
+msgstr ""
+
+#: src/client/cl_main.c:1838
+#, possible-c-format
+msgid "state: %i\n"
+msgstr ""
+
+#: src/client/cl_main.c:1839
+#, possible-c-format
+msgid "Server: %s\n"
+msgstr ""
+
+#: src/client/cl_main.c:1840
+msgid "User info settings:\n"
+msgstr ""
+
+#: src/client/cl_main.c:1842
+msgid "--------------------------------------\n"
+msgstr ""
+
+#: src/client/cl_main.c:1856
+msgid "Downloads complete\n"
+msgstr ""
+
+#: src/client/cl_main.c:1934
+#, possible-c-format
+msgid ""
+"***** CL_BeginDownload *****\n"
+"Localname: %s\n"
+"Remotename: %s\n"
+"****************************\n"
+msgstr ""
+
+#: src/client/cl_main.c:1978
+#, possible-c-format
+msgid "Incorrect checksum for file: %s"
+msgstr ""
+
+#: src/client/cl_main.c:2096
+#, possible-c-format
+msgid "Trying CURL download: %s; %s\n"
+msgstr ""
+
+#: src/client/cl_main.c:2098
+#, possible-c-format
+msgid ""
+"WARNING: server does not allow download redirection (sv_allowDownload is "
+"%d)\n"
+msgstr ""
+
+#: src/client/cl_main.c:2104
+msgid ""
+"WARNING: server allows download redirection, but does not have sv_dlURL set\n"
+msgstr ""
+
+#: src/client/cl_main.c:2109
+msgid "WARNING: could not load cURL library\n"
+msgstr ""
+
+#: src/client/cl_main.c:2119
+#, possible-c-format
+msgid ""
+"WARNING: server allows download redirection, but it disabled by client "
+"configuration (cl_allowDownload is %d)\n"
+msgstr ""
+
+#: src/client/cl_main.c:2126
+#, possible-c-format
+msgid "Trying UDP download: %s; %s\n"
+msgstr ""
+
+#: src/client/cl_main.c:2132
+#, possible-c-format
+msgid ""
+"Automatic downloads are disabled on your client (cl_allowDownload is %d). "
+"You can enable automatic downloads in the Options menu."
+msgstr ""
+
+#: src/client/cl_main.c:2140
+msgid "WARNING: UDP downloads are disabled.\n"
+msgstr ""
+
+#: src/client/cl_main.c:2169
+#, possible-c-format
+msgid "Need paks: %s\n"
+msgstr ""
+
+#: src/client/cl_main.c:2283 src/client/cl_main.c:2284
+msgid "Server disconnected for unknown reason\n"
+msgstr ""
+
+#: src/client/cl_main.c:2300
+msgid "MOTD packet from unexpected source\n"
+msgstr ""
+
+#: src/client/cl_main.c:2311
+#, possible-c-format
+msgid "MOTD packet mismatched challenge: '%s' != '%s'\n"
+msgstr ""
+
+#: src/client/cl_main.c:2377
+msgid "Master changed its mind about packet count!\n"
+msgstr ""
+
+#: src/client/cl_main.c:2410
+msgid "Warning: CL_GSRFeaturedLabel: overflow\n"
+msgstr ""
+
+#: src/client/cl_main.c:2470
+#, possible-c-format
+msgid "CL_ServersResponsePacket: received packet %d again, ignoring\n"
+msgstr ""
+
+#: src/client/cl_main.c:2477
+#, possible-c-format
+msgid "CL_ServersResponsePacket: packet %d of %d\n"
+msgstr ""
+
+#: src/client/cl_main.c:2561
+#, possible-c-format
+msgid "%d servers parsed (total %d)\n"
+msgstr ""
+
+#: src/client/cl_main.c:2591
+msgid "Unwanted challenge response received.  Ignored.\n"
+msgstr ""
+
+#: src/client/cl_main.c:2605
+msgid "Challenge response received from unexpected source. Ignored.\n"
+msgstr ""
+
+#: src/client/cl_main.c:2626
+msgid "Dup connect received.  Ignored.\n"
+msgstr ""
+
+#: src/client/cl_main.c:2630
+msgid "connectResponse packet while not connecting. Ignored.\n"
+msgstr ""
+
+#: src/client/cl_main.c:2634
+msgid "connectResponse from wrong address. Ignored.\n"
+msgstr ""
+
+#: src/client/cl_main.c:2699
+msgid "Unknown connectionless packet command.\n"
+msgstr ""
+
+#: src/client/cl_main.c:2725
+#, possible-c-format
+msgid "%s: Runt packet\n"
+msgstr ""
+
+#: src/client/cl_main.c:2733
+#, possible-c-format
+msgid "%s:sequenced packet without connection\n"
+msgstr ""
+
+#: src/client/cl_main.c:2777
+msgid ""
+"\n"
+"Server connection timed out.\n"
+msgstr ""
+
+#: src/client/cl_main.c:2843
+#, possible-c-format
+msgid "Download prompt returned %d\n"
+msgstr ""
+
+#: src/client/cl_main.c:2853
+msgid "WARNING: UI VM does not support download prompt\n"
+msgstr ""
+
+#: src/client/cl_main.c:3117
+msgid "----- Initializing Renderer ----\n"
+msgstr ""
+
+#: src/client/cl_main.c:3162
+msgid "-------------------------------\n"
+msgstr ""
+
+#: src/client/cl_main.c:3165
+msgid "Couldn't initialize refresh"
+msgstr ""
+
+#: src/client/cl_main.c:3188
+#, possible-c-format
+msgid "model is set to %s\n"
+msgstr ""
+
+#: src/client/cl_main.c:3211
+msgid "The video command can only be used when playing back demos\n"
+msgstr ""
+
+#: src/client/cl_main.c:3246
+msgid "ERROR: no free file names to create video\n"
+msgstr ""
+
+#: src/client/cl_main.c:3281
+msgid "QKEY found.\n"
+msgstr ""
+
+#: src/client/cl_main.c:3286
+#, possible-c-format
+msgid "QKEY file size != %d, regenerating\n"
+msgstr ""
+
+#: src/client/cl_main.c:3290
+msgid "QKEY building random string\n"
+msgstr ""
+
+#: src/client/cl_main.c:3295
+#, possible-c-format
+msgid "QKEY could not open %s for write\n"
+msgstr ""
+
+#: src/client/cl_main.c:3301
+msgid "QKEY generated\n"
+msgstr ""
+
+#: src/client/cl_main.c:3311
+msgid "----- Client Initialization -----\n"
+msgstr ""
+
+#: src/client/cl_main.c:3446
+msgid "Your network rate is too slow for VoIP.\n"
+msgstr ""
+
+#: src/client/cl_main.c:3447
+msgid ""
+"Set 'Data Rate' to 'LAN/Cable/xDSL' in 'Setup/System/Network' and restart.\n"
+msgstr ""
+
+#: src/client/cl_main.c:3448
+msgid "Until then, VoIP is disabled.\n"
+msgstr ""
+
+#: src/client/cl_main.c:3499
+msgid "----- Client Initialization Complete -----\n"
+msgstr ""
+
+#: src/client/cl_main.c:3516
+msgid "----- CL_Shutdown -----\n"
+msgstr ""
+
+#: src/client/cl_main.c:3519
+msgid "WARNING: Recursive shutdown\n"
+msgstr ""
+
+#: src/client/cl_main.c:3559
+msgid "-----------------------\n"
+msgstr ""
+
+#: src/client/cl_main.c:3619
+#, possible-c-format
+msgid "Different protocol info packet: %s\n"
+msgstr ""
+
+#: src/client/cl_main.c:3630
+#, possible-c-format
+msgid "ping time %dms from %s\n"
+msgstr ""
+
+#: src/client/cl_main.c:3675
+msgid "MAX_OTHER_SERVERS hit, dropping infoResponse\n"
+msgstr ""
+
+#: src/client/cl_main.c:3830
+msgid "Server settings:\n"
+msgstr ""
+
+#: src/client/cl_main.c:3861
+msgid ""
+"\n"
+"Players:\n"
+msgstr ""
+
+#: src/client/cl_main.c:3862
+msgid "num: score: ping: name:\n"
+msgstr ""
+
+#: src/client/cl_main.c:3903
+msgid "Scanning for servers on the local network...\n"
+msgstr ""
+
+#: src/client/cl_main.c:3949
+msgid "usage: globalservers <master# 0-4> <protocol> [keywords]\n"
+msgstr ""
+
+#: src/client/cl_main.c:3958
+msgid "CL_GlobalServers_f: Error: No master server address given.\n"
+msgstr ""
+
+#: src/client/cl_main.c:3969
+#, possible-c-format
+msgid "CL_GlobalServers_f: Error: could not resolve address of master %s\n"
+msgstr ""
+
+#: src/client/cl_main.c:3975
+#, possible-c-format
+msgid "Requesting servers from master %s...\n"
+msgstr ""
+
+#: src/client/cl_parse.c:124
+msgid "CL_ParsePacketEntities: end of message"
+msgstr ""
+
+#: src/client/cl_parse.c:252
+msgid "Delta from invalid frame (not supposed to happen!).\n"
+msgstr ""
+
+#: src/client/cl_parse.c:256
+msgid "Delta frame too old.\n"
+msgstr ""
+
+#: src/client/cl_parse.c:258
+msgid "Delta parseEntitiesNum too old.\n"
+msgstr ""
+
+#: src/client/cl_parse.c:269
+#, possible-c-format
+msgid "CL_ParseSnapshot: Invalid size %d for areamask."
+msgstr ""
+
+#: src/client/cl_parse.c:404
+#, possible-c-format
+msgid "WARNING: Server sent invalid fs_game value %s\n"
+msgstr ""
+
+#: src/client/cl_parse.c:418
+#, possible-c-format
+msgid "WARNING: server is not allowed to set %s=%s\n"
+msgstr ""
+
+#: src/client/cl_parse.c:488
+msgid "configstring > MAX_CONFIGSTRINGS"
+msgstr ""
+
+#: src/client/cl_parse.c:504
+#, possible-c-format
+msgid "Baseline number out of range: %i"
+msgstr ""
+
+#: src/client/cl_parse.c:510
+msgid "CL_ParseGamestate: bad command byte"
+msgstr ""
+
+#: src/client/cl_parse.c:555
+msgid "Server sending download, but no download was requested\n"
+msgstr ""
+
+#: src/client/cl_parse.c:580
+#, possible-c-format
+msgid "CL_ParseDownload: Invalid size %d for download chunk."
+msgstr ""
+
+#: src/client/cl_parse.c:587
+#, possible-c-format
+msgid "CL_ParseDownload: Expected block %d, got %d\n"
+msgstr ""
+
+#: src/client/cl_parse.c:597
+#, possible-c-format
+msgid "Could not create %s\n"
+msgstr ""
+
+#: src/client/cl_parse.c:676
+#, possible-c-format
+msgid "VoIP: %d-byte packet from client %d\n"
+msgstr ""
+
+#: src/client/cl_parse.c:714
+msgid "VoIP: packet accepted!\n"
+msgstr ""
+
+#: src/client/cl_parse.c:718
+#, possible-c-format
+msgid "VoIP: new generation %d!\n"
+msgstr ""
+
+#: src/client/cl_parse.c:724
+#, possible-c-format
+msgid "VoIP: misordered sequence! %d < %d!\n"
+msgstr ""
+
+#: src/client/cl_parse.c:731
+#, possible-c-format
+msgid "VoIP: Dropped way too many (%d) frames from client #%d\n"
+msgstr ""
+
+#: src/client/cl_parse.c:738
+#, possible-c-format
+msgid "VoIP: Dropped %d frames from client #%d\n"
+msgstr ""
+
+#: src/client/cl_parse.c:752
+msgid "VoIP: Short packet!\n"
+msgstr ""
+
+#: src/client/cl_parse.c:759 src/client/cl_parse.c:782
+#, possible-c-format
+msgid "VoIP: playback %d bytes, %d samples, %d frames\n"
+msgstr ""
+
+#: src/client/cl_parse.c:833
+msgid "------------------\n"
+msgstr ""
+
+#: src/client/cl_parse.c:850
+msgid "CL_ParseServerMessage: read past end of server message"
+msgstr ""
+
+#: src/client/cl_parse.c:885
+msgid "CL_ParseServerMessage: Illegible server message\n"
+msgstr ""
+
+#: src/client/cl_scrn.c:481
+msgid "SCR_DrawScreenField: bad cls.state"
+msgstr ""
+
+#: src/client/cl_scrn.c:544
+msgid "SCR_UpdateScreen: recursively called"
+msgstr ""
+
+#: src/client/cl_ui.c:99
+msgid "^1Error: Could not load cURL library"
+msgstr ""
+
+#: src/client/cl_ui.c:763
+#, possible-c-format
+msgid "turning EXEC_NOW '%.11s' into EXEC_INSERT\n"
+msgstr ""
+
+#: src/client/cl_ui.c:1050
+#, possible-c-format
+msgid "Bad UI system trap: %ld"
+msgstr ""
+
+#: src/client/cl_ui.c:1094
+msgid "Failed to find a valid UI vm. The following paths were searched:\n"
+msgstr ""
+
+#: src/client/cl_ui.c:1096
+msgid "VM_Create on UI failed"
+msgstr ""
+
+#: src/client/cl_ui.c:1106
+#, possible-c-format
+msgid "User Interface is version %d, expected %d"
+msgstr ""
+
+#: src/client/qal.c:129
+#, possible-c-format
+msgid " Can't load symbol %s\n"
+msgstr ""
+
+#: src/client/qal.c:135
+#, possible-c-format
+msgid " Loaded symbol %s (%p)\n"
+msgstr ""
+
+#: src/client/qal.c:150
+#, possible-c-format
+msgid "Loading \"%s\"...\n"
+msgstr ""
+
+#: src/client/qal.c:249
+msgid " One or more symbols not found\n"
+msgstr ""
+
+#: src/client/snd_codec.c:148 src/client/snd_codec.c:171
+#, possible-c-format
+msgid "Unknown extension for %s\n"
+msgstr ""
+
+#: src/client/snd_codec.c:209
+#, possible-c-format
+msgid "Can't read sound file %s\n"
+msgstr ""
+
+#: src/client/snd_codec_wav.c:71
+msgid "WARNING: Negative chunk length\n"
+msgstr ""
+
+#: src/client/snd_codec_wav.c:145
+msgid "ERROR: Couldn't find \"fmt\" chunk\n"
+msgstr ""
+
+#: src/client/snd_codec_wav.c:159
+msgid "ERROR: Less than 8 bit sound is not supported\n"
+msgstr ""
+
+#: src/client/snd_codec_wav.c:176
+msgid "ERROR: Couldn't find \"data\" chunk\n"
+msgstr ""
+
+#: src/client/snd_codec_wav.c:209
+#, possible-c-format
+msgid "ERROR: Could not open \"%s\"\n"
+msgstr ""
+
+#: src/client/snd_codec_wav.c:218
+#, possible-c-format
+msgid "ERROR: Incorrect/unsupported format in \"%s\"\n"
+msgstr ""
+
+#: src/client/snd_codec_wav.c:228
+#, possible-c-format
+msgid "ERROR: Out of memory reading \"%s\"\n"
+msgstr ""
+
+#: src/client/snd_dma.c:99
+msgid "----- Sound Info -----\n"
+msgstr ""
+
+#: src/client/snd_dma.c:101
+msgid "sound system not started\n"
+msgstr ""
+
+#: src/client/snd_dma.c:103
+#, possible-c-format
+msgid "%5d stereo\n"
+msgstr ""
+
+#: src/client/snd_dma.c:104
+#, possible-c-format
+msgid "%5d samples\n"
+msgstr ""
+
+#: src/client/snd_dma.c:105
+#, possible-c-format
+msgid "%5d samplebits\n"
+msgstr ""
+
+#: src/client/snd_dma.c:106
+#, possible-c-format
+msgid "%5d submission_chunk\n"
+msgstr ""
+
+#: src/client/snd_dma.c:107
+#, possible-c-format
+msgid "%5d speed\n"
+msgstr ""
+
+#: src/client/snd_dma.c:108
+#, possible-c-format
+msgid "%p dma buffer\n"
+msgstr ""
+
+#: src/client/snd_dma.c:110
+#, possible-c-format
+msgid "Background file: %s\n"
+msgstr ""
+
+#: src/client/snd_dma.c:112
+msgid "No background file.\n"
+msgstr ""
+
+#: src/client/snd_dma.c:116
+msgid "----------------------\n"
+msgstr ""
+
+#: src/client/snd_dma.c:180
+#, possible-c-format
+msgid "Total resident: %i\n"
+msgstr ""
+
+#: src/client/snd_dma.c:217
+msgid "Channel memory manager started\n"
+msgstr ""
+
+#: src/client/snd_dma.c:263
+msgid "S_FindName: NULL\n"
+msgstr ""
+
+#: src/client/snd_dma.c:266
+msgid "S_FindName: empty name\n"
+msgstr ""
+
+#: src/client/snd_dma.c:270
+#, possible-c-format
+msgid "Sound name too long: %s"
+msgstr ""
+
+#: src/client/snd_dma.c:293
+msgid "S_FindName: out of sfx_t"
+msgstr ""
+
+#: src/client/snd_dma.c:357
+msgid "Sound name exceeds MAX_QPATH\n"
+msgstr ""
+
+#: src/client/snd_dma.c:364 src/client/snd_dma.c:376
+#, possible-c-format
+msgid "WARNING: could not find %s - using default\n"
+msgstr ""
+
+#: src/client/snd_dma.c:390
+#, possible-c-format
+msgid "S_Base_SoundDuration: handle %i out of range\n"
+msgstr ""
+
+#: src/client/snd_dma.c:512
+#, possible-c-format
+msgid "S_StartSound: bad entitynum %i"
+msgstr ""
+
+#: src/client/snd_dma.c:516
+#, possible-c-format
+msgid "S_StartSound: handle %i out of range\n"
+msgstr ""
+
+#: src/client/snd_dma.c:591
+msgid "dropping sound\n"
+msgstr ""
+
+#: src/client/snd_dma.c:629
+#, possible-c-format
+msgid "S_StartLocalSound: handle %i out of range\n"
+msgstr ""
+
+#: src/client/snd_dma.c:734
+#, possible-c-format
+msgid "S_AddLoopingSound: handle %i out of range\n"
+msgstr ""
+
+#: src/client/snd_dma.c:745 src/client/snd_dma.c:808
+#, possible-c-format
+msgid "%s has length 0"
+msgstr ""
+
+#: src/client/snd_dma.c:797
+#, possible-c-format
+msgid "S_AddRealLoopingSound: handle %i out of range\n"
+msgstr ""
+
+#: src/client/snd_dma.c:958
+#, possible-c-format
+msgid "S_Base_RawSamples: resetting minimum: %i < %i\n"
+msgstr ""
+
+#: src/client/snd_dma.c:1036
+#, possible-c-format
+msgid "S_Base_RawSamples: overflowed %i > %i\n"
+msgstr ""
+
+#: src/client/snd_dma.c:1051 src/client/snd_openal.c:1127
+#, possible-c-format
+msgid "S_UpdateEntityPosition: bad entitynum %i"
+msgstr ""
+
+#: src/client/snd_dma.c:1172
+#, possible-c-format
+msgid "----(%i)---- painted: %i\n"
+msgstr ""
+
+#: src/client/snd_dma.c:1219
+msgid "S_Update_ : overflow\n"
+msgstr ""
+
+#: src/client/snd_dma.c:1328
+#, possible-c-format
+msgid "S_StartBackgroundTrack( %s, %s )\n"
+msgstr ""
+
+#: src/client/snd_dma.c:1353
+#, possible-c-format
+msgid "WARNING: couldn't open music file %s\n"
+msgstr ""
+
+#: src/client/snd_dma.c:1358
+#, possible-c-format
+msgid "WARNING: music file %s is not 22k stereo\n"
+msgstr ""
+
+#: src/client/snd_dma.c:1464
+#, possible-c-format
+msgid "S_FreeOldestSound: freeing sound %s\n"
+msgstr ""
+
+#: src/client/snd_main.c:492
+msgid "------ Initializing Sound ------\n"
+msgstr ""
+
+#: src/client/snd_main.c:504
+msgid "Sound disabled.\n"
+msgstr ""
+
+#: src/client/snd_main.c:530
+msgid "Sound interface invalid."
+msgstr ""
+
+#: src/client/snd_main.c:534
+msgid "Sound initialization successful.\n"
+msgstr ""
+
+#: src/client/snd_main.c:536
+msgid "Sound initialization failed.\n"
+msgstr ""
+
+#: src/client/snd_main.c:540
+msgid "--------------------------------\n"
+msgstr ""
+
+#: src/client/snd_mem.c:101
+msgid "Sound memory manager started\n"
+msgstr ""
+
+#: src/client/snd_mem.c:221
+#, possible-c-format
+msgid "WARNING: %s is a 8 bit wav file\n"
+msgstr ""
+
+#: src/client/snd_mem.c:225
+#, possible-c-format
+msgid "WARNING: %s is not a 22kHz wav file\n"
+msgstr ""
+
+#: src/client/snd_mem.c:269
+#, possible-c-format
+msgid "%d bytes free sound buffer memory, %d total used\n"
+msgstr ""
+
+#: src/client/snd_openal.c:86
+msgid "No error"
+msgstr ""
+
+#: src/client/snd_openal.c:88
+msgid "Invalid name"
+msgstr ""
+
+#: src/client/snd_openal.c:90
+msgid "Invalid enumerator"
+msgstr ""
+
+#: src/client/snd_openal.c:92
+msgid "Invalid value"
+msgstr ""
+
+#: src/client/snd_openal.c:94
+msgid "Invalid operation"
+msgstr ""
+
+#: src/client/snd_openal.c:96
+msgid "Out of memory"
+msgstr ""
+
+#: src/client/snd_openal.c:98
+msgid "Unknown error"
+msgstr ""
+
+#: src/client/snd_openal.c:115
+#, possible-c-format
+msgid "WARNING: unhandled AL error: %s\n"
+msgstr ""
+
+#: src/client/snd_openal.c:174
+msgid "S_AL_BufferFindFree: No free sound handles"
+msgstr ""
+
+#: src/client/snd_openal.c:226
+#, possible-c-format
+msgid "Can't load default sound effect %s\n"
+msgstr ""
+
+#: src/client/snd_openal.c:228
+#, possible-c-format
+msgid "WARNING: Using default sound for %s\n"
+msgstr ""
+
+#: src/client/snd_openal.c:252
+#, possible-c-format
+msgid "ERROR: Can't delete sound buffer for %s\n"
+msgstr ""
+
+#: src/client/snd_openal.c:340
+#, possible-c-format
+msgid "ERROR: Can't create a sound buffer for %s - %s\n"
+msgstr ""
+
+#: src/client/snd_openal.c:365
+#, possible-c-format
+msgid "ERROR: Out of memory loading %s\n"
+msgstr ""
+
+#: src/client/snd_openal.c:379
+#, possible-c-format
+msgid "ERROR: Can't fill sound buffer for %s - %s\n"
+msgstr ""
+
+#: src/client/snd_openal.c:488
+#, possible-c-format
+msgid "ERROR: S_AL_SoundDuration: handle %i out of range\n"
+msgstr ""
+
+#: src/client/snd_openal.c:573
+#, possible-c-format
+msgid ""
+"WARNING: vector with one or more NaN components being passed to OpenAL at %s:"
+"%d -- zeroing\n"
+msgstr ""
+
+#: src/client/snd_openal.c:702
+#, possible-c-format
+msgid "Allocated %d sources.\n"
+msgstr ""
+
+#: src/client/snd_openal.c:727
+#, possible-c-format
+msgid "WARNING: Source %d is locked\n"
+msgstr ""
+
+#: src/client/snd_openal.c:813
+#, possible-c-format
+msgid "WARNING: Could not get time offset for alSource %d: %s\n"
+msgstr ""
+
+#: src/client/snd_openal.c:1141
+#, possible-c-format
+msgid "ERROR: S_AL_CheckInput: bad entitynum %i"
+msgstr ""
+
+#: src/client/snd_openal.c:1145
+#, possible-c-format
+msgid "ERROR: S_AL_CheckInput: handle %i out of range\n"
+msgstr ""
+
+#: src/client/snd_openal.c:1284
+#, possible-c-format
+msgid "WARNING: Failed to allocate source for loop sfx %d on entity %d\n"
+msgstr ""
+
+#: src/client/snd_openal.c:1487
+#, possible-c-format
+msgid "WARNING: Cannot get sample offset from source %d: %s\n"
+msgstr ""
+
+#: src/client/snd_openal.c:1687
+msgid "ERROR: Can't allocate streaming streamSource\n"
+msgstr ""
+
+#: src/client/snd_openal.c:1951
+#, possible-c-format
+msgid "ERROR: while buffering data for music stream - %s\n"
+msgstr ""
+
+#: src/client/snd_openal.c:2059
+msgid "Restarted OpenAL music\n"
+msgstr ""
+
+#: src/client/snd_openal.c:2283
+msgid "OpenAL info:\n"
+msgstr ""
+
+#: src/client/snd_openal.c:2284
+#, possible-c-format
+msgid "  Vendor:     %s\n"
+msgstr ""
+
+#: src/client/snd_openal.c:2285
+#, possible-c-format
+msgid "  Version:    %s\n"
+msgstr ""
+
+#: src/client/snd_openal.c:2286
+#, possible-c-format
+msgid "  Renderer:   %s\n"
+msgstr ""
+
+#: src/client/snd_openal.c:2287
+#, possible-c-format
+msgid "  AL Extensions: %s\n"
+msgstr ""
+
+#: src/client/snd_openal.c:2288
+#, possible-c-format
+msgid "  ALC Extensions: %s\n"
+msgstr ""
+
+#: src/client/snd_openal.c:2291
+#, possible-c-format
+msgid "  Device:     %s\n"
+msgstr ""
+
+#: src/client/snd_openal.c:2292
+#, possible-c-format
+msgid ""
+"Available Devices:\n"
+"%s"
+msgstr ""
+
+#: src/client/snd_openal.c:2320
+msgid "OpenAL capture device closed.\n"
+msgstr ""
+
+#: src/client/snd_openal.c:2374
+#, possible-c-format
+msgid "Failed to load library: \"%s\".\n"
+msgstr ""
+
+#: src/client/snd_openal.c:2418
+#, possible-c-format
+msgid "Failed to open OpenAL device '%s', trying default.\n"
+msgstr ""
+
+#: src/client/snd_openal.c:2425
+msgid "Failed to open OpenAL device.\n"
+msgstr ""
+
+#: src/client/snd_openal.c:2435
+msgid "Failed to create OpenAL context.\n"
+msgstr ""
+
+#: src/client/snd_openal.c:2456
+msgid ""
+"OpenAL capture support disabled by user ('+set s_alCapture 1' to enable)\n"
+msgstr ""
+
+#: src/client/snd_openal.c:2461
+msgid "OpenAL capture support disabled for Mumble support\n"
+msgstr ""
+
+#: src/client/snd_openal.c:2477
+msgid "No ALC_EXT_capture support, can't record audio.\n"
+msgstr ""
+
+#: src/client/snd_openal.c:2485
+#, possible-c-format
+msgid "OpenAL default capture device is '%s'\n"
+msgstr ""
+
+#: src/client/snd_openal.c:2488
+#, possible-c-format
+msgid "OpenAL capture device %s.\n"
+msgstr ""
+
+#: src/sys/con_tty.c:288
+msgid "tty console mode disabled\n"
+msgstr ""
+
+#: src/sys/con_tty.c:419
+#, possible-c-format
+msgid "droping ISCTL sequence: %d, TTY_erase: %d\n"
+msgstr ""
+
+#: src/sys/sys_main.c:318
+#, possible-c-format
+msgid "Warning: %s"
+msgstr ""
+
+#: src/sys/sys_main.c:347
+msgid "Sys_UnloadDll(NULL)\n"
+msgstr ""
+
+#: src/sys/sys_main.c:367
+#, possible-c-format
+msgid "Sys_LoadDll(%s)... \n"
+msgstr ""
+
+#: src/sys/sys_main.c:372
+#, possible-c-format
+msgid ""
+"Sys_LoadDll(%s) failed:\n"
+"\"%s\"\n"
+msgstr ""
+
+#: src/sys/sys_main.c:376
+#, possible-c-format
+msgid "Sys_LoadDll(%s): succeeded ...\n"
+msgstr ""
+
+#: src/sys/sys_main.c:417
+#, possible-c-format
+msgid "Sys_LoadDll(%s) failed to load library\n"
+msgstr ""
+
+#: src/sys/sys_main.c:426
+#, possible-c-format
+msgid ""
+"Sys_LoadDll(%s) failed to find vmMain function:\n"
+"\"%s\" !\n"
+msgstr ""
+
+#: src/sys/sys_main.c:432
+#, possible-c-format
+msgid "Sys_LoadDll(%s) found vmMain function at %p\n"
+msgstr ""
+
+#: src/sys/sys_main.c:480
+#, c-format
+msgid "DOUBLE SIGNAL FAULT: Received signal %d, exiting...\n"
+msgstr ""
+
+#: src/sys/sys_main.c:486
+#, c-format
+msgid "Received signal %d, exiting...\n"
+msgstr ""
+
+#: src/sys/sys_main.c:490
+msgid "Signal caught"
+msgstr ""
+
+#: src/sys/sys_main.c:525
+msgid "SDL version "
+msgstr ""
+
+#: src/sys/sys_unix.c:532
+#, possible-c-format
+msgid "ERROR: couldn't create path '%s' for crash log.\n"
+msgstr ""
+
+#: src/sys/sys_unix.c:542
+#, possible-c-format
+msgid "ERROR: couldn't open %s\n"
+msgstr ""
+
+#: src/sys/sys_unix.c:549
+#, possible-c-format
+msgid "ERROR: couldn't fully write to %s\n"
+msgstr ""
+
+#: src/sys/sys_win32.c:60
+msgid "Unable to load SHFolder.dll\n"
+msgstr ""
+
+#: src/sys/sys_win32.c:67
+msgid "Unable to find SHGetFolderPath in SHFolder.dll\n"
+msgstr ""
+
+#: src/sys/sys_win32.c:75
+msgid "Unable to detect CSIDL_APPDATA\n"
+msgstr ""
+
+#: src/sys/sys_win32.c:548
+#, possible-c-format
+msgid "%s. Copy console log to clipboard?"
+msgstr ""
+
+#: src/sys/sys_win32.c:659
+#, possible-c-format
+msgid ""
+"SDL_VIDEODRIVER is externally set to \"%s\", in_mouse -1 will have no "
+"effect\n"
+msgstr ""
+
+#: ../assets/ui/createfavorite.menu:50 ../assets/ui/findplayer.menu:58
+#: ../assets/ui/ingame_options.menu:179 ../assets/ui/options.menu:54
+msgid "Name:"
+msgstr ""
+
+#: ../assets/ui/createfavorite.menu:66
+msgid "Address:"
+msgstr ""
+
+#: ../assets/ui/createfavorite.menu:79 ../assets/ui/drop.menu:83
+#: ../assets/ui/error.menu:83 ../assets/ui/options.menu:295
+#: ../assets/ui/password.menu:69 ../assets/ui/tremulous_alienbuild.menu:98
+#: ../assets/ui/tremulous_alienclass.menu:119
+#: ../assets/ui/tremulous_aliendialogs.menu:80
+#: ../assets/ui/tremulous_alienupgrade.menu:98
+#: ../assets/ui/tremulous_dialogs.menu:81
+#: ../assets/ui/tremulous_humanbuild.menu:97
+#: ../assets/ui/tremulous_humandialogs.menu:81
+#: ../assets/ui/tremulous_humanitem.menu:119
+#: ../assets/ui/tremulous_teamselect.menu:98
+msgid "OK"
+msgstr ""
+
+#: ../assets/ui/createfavorite.menu:99 ../assets/ui/mod.menu:93
+#: ../assets/ui/tremulous_alienbuild.menu:119
+#: ../assets/ui/tremulous_alienclass.menu:140
+#: ../assets/ui/tremulous_alienupgrade.menu:119
+#: ../assets/ui/tremulous_humanbuild.menu:118
+#: ../assets/ui/tremulous_humanitem.menu:140
+#: ../assets/ui/tremulous_teamselect.menu:119
+msgid "Cancel"
+msgstr ""
+
+#: ../assets/ui/createserver.menu:125
+msgid "Host Name:"
+msgstr ""
+
+#: ../assets/ui/createserver.menu:141 ../assets/ui/ingame_game.menu:702
+msgid "Time Limit:"
+msgstr ""
+
+#: ../assets/ui/createserver.menu:157
+msgid "Maximum Players:"
+msgstr ""
+
+#: ../assets/ui/createserver.menu:173
+msgid "Require Password:"
+msgstr ""
+
+#: ../assets/ui/createserver.menu:192 ../assets/ui/password.menu:55
+msgid "Password:"
+msgstr ""
+
+#: ../assets/ui/createserver.menu:210
+msgid "Pure Server:"
+msgstr ""
+
+#: ../assets/ui/createserver.menu:229
+msgid "Dedicated:"
+msgstr ""
+
+#: ../assets/ui/createserver.menu:251
+msgid "Auto Download:"
+msgstr ""
+
+#: ../assets/ui/createserver.menu:270
+msgid "Enable Voting:"
+msgstr ""
+
+#: ../assets/ui/createserver.menu:291
+msgid "Minimum Ping:"
+msgstr ""
+
+#: ../assets/ui/createserver.menu:307
+msgid "Maximum Ping:"
+msgstr ""
+
+#: ../assets/ui/createserver.menu:323
+msgid "Synchronous Client:"
+msgstr ""
+
+#: ../assets/ui/createserver.menu:342
+msgid "Max Rate:"
+msgstr ""
+
+#: ../assets/ui/createserver.menu:358
+msgid "Zombie Time:"
+msgstr ""
+
+#: ../assets/ui/createserver.menu:374
+msgid "Reconnect Limit:"
+msgstr ""
+
+#: ../assets/ui/createserver.menu:423 ../assets/ui/joinserver.menu:647
+msgid "Back"
+msgstr ""
+
+#: ../assets/ui/createserver.menu:480
+msgid "Create"
+msgstr ""
+
+#: ../assets/ui/download.menu:47
+msgid "Download"
+msgstr ""
+
+#: ../assets/ui/download.menu:80
+msgid "Download from website"
+msgstr ""
+
+#: ../assets/ui/download.menu:103
+msgid "Download from server"
+msgstr ""
+
+#: ../assets/ui/download.menu:126 ../assets/ui/ingame_game.menu:127
+msgid "Ignore"
+msgstr ""
+
+#: ../assets/ui/download.menu:149
+msgid "Disconnect"
+msgstr ""
+
+#: ../assets/ui/drop.menu:55
+msgid "Disconnected"
+msgstr ""
+
+#: ../assets/ui/drop.menu:103
+msgid "Reconnect"
+msgstr ""
+
+#: ../assets/ui/error.menu:55 ../assets/ui/tremulous_aliendialogs.menu:45
+#: ../assets/ui/tremulous_dialogs.menu:46
+#: ../assets/ui/tremulous_humandialogs.menu:46
+msgid "Error"
+msgstr ""
+
+#: ../assets/ui/findplayer.menu:77
+msgid "Search"
+msgstr ""
+
+#: ../assets/ui/findplayer.menu:140 ../assets/ui/joinserver.menu:704
+msgid "Join"
+msgstr ""
+
+#: ../assets/ui/findplayer.menu:155 ../assets/ui/news.menu:84
+#: ../assets/ui/serverinfo.menu:94
+#: ../assets/ui/tremulous_humanarmoury.menu:152
+msgid "Close"
+msgstr ""
+
+#: ../assets/ui/ingame_game.menu:101
+msgid "Vote"
+msgstr ""
+
+#: ../assets/ui/ingame_game.menu:152
+msgid "Info"
+msgstr ""
+
+#: ../assets/ui/ingame_game.menu:181
+msgid "Map"
+msgstr ""
+
+#: ../assets/ui/ingame_game.menu:203 ../assets/ui/joinserver.menu:323
+msgid "Players"
+msgstr ""
+
+#: ../assets/ui/ingame_game.menu:225
+msgid "Team"
+msgstr ""
+
+#: ../assets/ui/ingame_game.menu:287
+msgid "Load Selected Map"
+msgstr ""
+
+#: ../assets/ui/ingame_game.menu:307
+msgid "Load Selected Map Next"
+msgstr ""
+
+#: ../assets/ui/ingame_game.menu:327
+msgid "Restart Current Map"
+msgstr ""
+
+#: ../assets/ui/ingame_game.menu:347
+msgid "Begin Sudden Death"
+msgstr ""
+
+#: ../assets/ui/ingame_game.menu:367
+msgid "End Match In Draw"
+msgstr ""
+
+#: ../assets/ui/ingame_game.menu:408
+msgid "Mute Player"
+msgstr ""
+
+#: ../assets/ui/ingame_game.menu:428
+msgid "Un-Mute Player"
+msgstr ""
+
+#: ../assets/ui/ingame_game.menu:448
+msgid "Kick Player"
+msgstr ""
+
+#: ../assets/ui/ingame_game.menu:490
+msgid "Kick Teammate"
+msgstr ""
+
+#: ../assets/ui/ingame_game.menu:510
+msgid "Deny Building For Teammate"
+msgstr ""
+
+#: ../assets/ui/ingame_game.menu:530
+msgid "Allow Building For Teammate"
+msgstr ""
+
+#: ../assets/ui/ingame_game.menu:551
+msgid "Admit Defeat"
+msgstr ""
+
+#: ../assets/ui/ingame_game.menu:573
+msgid "Player Name"
+msgstr ""
+
+#: ../assets/ui/ingame_game.menu:586
+msgid "Ignored"
+msgstr ""
+
+#: ../assets/ui/ingame_game.menu:598
+msgid "Ignoring You"
+msgstr ""
+
+#: ../assets/ui/ingame_game.menu:638
+msgid "Ignore Player"
+msgstr ""
+
+#: ../assets/ui/ingame_game.menu:658
+msgid "Stop Ignoring Player"
+msgstr ""
+
+#: ../assets/ui/ingame_game.menu:684
+msgid "Server Name:"
+msgstr ""
+
+#: ../assets/ui/ingame_game.menu:720
+msgid "Sudden Death Time:"
+msgstr ""
+
+#: ../assets/ui/ingame_game.menu:738
+msgid "Max Clients:"
+msgstr ""
+
+#: ../assets/ui/ingame_game.menu:756
+msgid "Map Name:"
+msgstr ""
+
+#: ../assets/ui/ingame_game.menu:774
+msgid "Lag Correction:"
+msgstr ""
+
+#: ../assets/ui/ingame_game.menu:792
+msgid "Friendly Fire:"
+msgstr ""
+
+#: ../assets/ui/ingame_game.menu:810
+msgid "Buildable Friendly Fire:"
+msgstr ""
+
+#: ../assets/ui/ingame_game.menu:828
+msgid "Version:"
+msgstr ""
+
+#: ../assets/ui/ingame_leave.menu:53
+msgid "Main Menu"
+msgstr ""
+
+#: ../assets/ui/ingame_leave.menu:75 ../assets/ui/main.menu:138
+msgid "Quit"
+msgstr ""
+
+#: ../assets/ui/ingame_leave.menu:99
+msgid "Return To Main Menu?"
+msgstr ""
+
+#: ../assets/ui/ingame_leave.menu:114 ../assets/ui/ingame_leave.menu:171
+msgid "Yes"
+msgstr ""
+
+#: ../assets/ui/ingame_leave.menu:134 ../assets/ui/ingame_leave.menu:191
+msgid "No"
+msgstr ""
+
+#: ../assets/ui/ingame_leave.menu:156
+msgid "Want To Quit Game?"
+msgstr ""
+
+#: ../assets/ui/ingame.menu:67
+msgid "Game"
+msgstr ""
+
+#: ../assets/ui/ingame.menu:86 ../assets/ui/main.menu:98
+msgid "Options"
+msgstr ""
+
+#: ../assets/ui/ingame.menu:105
+msgid "Help"
+msgstr ""
+
+#: ../assets/ui/ingame.menu:124
+msgid "Exit"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:69
+msgid "Player"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:94
+msgid "HUD"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:120
+msgid "Controls"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:147
+msgid "System"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:196
+msgid "Taunts Sounds Off:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:216
+msgid "Team Chats Only:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:236
+msgid "Sticky Spectate:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:256
+msgid "Tutorial Mode:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:276
+msgid "Disable Warning Dialogs:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:299
+msgid "Show Clock:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:320
+msgid "Show Crosshair:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:341
+msgid "Crosshair Size:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:362
+msgid "Show Charge Bar:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:382
+msgid "Show Lag-o-meter:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:402
+msgid "Show Team Overlay:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:422
+msgid "Show Gun:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:442
+msgid "Show Speed:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:463
+msgid "Show FPS:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:483
+msgid "Show Timer:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:503
+msgid "Show Demo State:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:524
+msgid "Look"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:550
+msgid "Lookup:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:570
+msgid "Look Down:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:590
+msgid "Mouse Look:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:610
+msgid "Centerview:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:630
+msgid "Free Look:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:650 ../assets/ui/options.menu:189
+msgid "Mouse Sensitivity:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:666 ../assets/ui/options.menu:203
+msgid "Invert Mouse:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:687
+msgid "Smooth Mouse:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:707
+msgid "Auto Wallwalk Pitching:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:727
+msgid "Move"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:751
+msgid "Sprint Toggles:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:771
+msgid "Wallwalk Control Toggles:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:791
+msgid "Wallwalking Speed:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:812
+msgid "Run / Walk:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:832
+msgid "Dodge:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:852
+msgid "Sprint:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:872
+msgid "Forward:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:892
+msgid "Backpedal:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:912
+msgid "Move Left:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:932
+msgid "Move Right:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:952
+msgid "Jump:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:972
+msgid "Crouch:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:992
+msgid "Turn Left:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1012
+msgid "Turn Right:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1032
+msgid "Strafe:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1054
+msgid "Upgrades"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1078
+msgid "Primary Attack:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1098
+msgid "Secondary Attack:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1118
+msgid "Previous Upgrade:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1138
+msgid "Next Upgrade:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1158
+msgid "Activate Upgrade:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1178
+msgid "Reload:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1198
+msgid "Buy Ammo:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1218
+msgid "Use Medkit:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1238
+msgid "Misc"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1262
+msgid "Show Scores:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1282
+msgid "Scroll Scores Up:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1302
+msgid "Scroll Scores Down:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1322
+msgid "Use Structure/Evolve:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1342
+msgid "Deconstruct Structure:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1362
+msgid "Gesture:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1382
+msgid "Chat:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1402
+msgid "Team Chat:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1422
+msgid "Vote Yes:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1442
+msgid "Vote No:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1462
+msgid "Team Vote Yes:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1482
+msgid "Team Vote No:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1502
+msgid "Screenshot:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1522
+msgid "GFX Hardware"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1548
+msgid "Quality:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1570
+msgid "GL Extensions:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1591 ../assets/ui/options.menu:89
+msgid "Video Mode:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1630
+msgid "Color Depth:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1653
+msgid "Fullscreen:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1674
+msgid "Lighting:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1696
+msgid "Geometric Detail:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1719
+msgid "Texture Detail:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1741
+msgid "Texture Quality:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1762
+msgid "Texture Filter:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1784
+msgid "Anisotropic Filtering:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1805
+msgid "Compress Textures:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1826 ../assets/ui/ingame_options.menu:2322
+#: ../assets/ui/options.menu:277
+msgid "APPLY"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1846
+msgid "GFX Software"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1870
+msgid "Brightness:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1886
+msgid "Screen Size:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1902
+msgid "Marks On Walls:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1922
+msgid "Dynamic Lights:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1942
+msgid "Draw Gun:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1962
+msgid "Low Quality Sky:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:1982
+msgid "Sync Every Frame:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:2002
+msgid "Show Time:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:2022
+msgid "In Game Videos:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:2042
+msgid "Depth Sort Particles:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:2062
+msgid "Particle Physics:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:2083
+msgid "Light Flares:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:2104
+msgid "OpenGL Info"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:2144
+msgid "Net & Sound"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:2169 ../assets/ui/quitcredit.menu:403
+msgid "Sound"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:2188 ../assets/ui/options.menu:141
+msgid "Effects Volume:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:2204 ../assets/ui/options.menu:155
+msgid "Music Volume:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:2220
+msgid "OpenAL:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:2240
+msgid "Sound Quality:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:2261
+msgid "Doppler Sound:"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:2282
+msgid "Network"
+msgstr ""
+
+#: ../assets/ui/ingame_options.menu:2301
+msgid "Net Data Rate:"
+msgstr ""
+
+#: ../assets/ui/joinserver.menu:85
+msgid "Source:"
+msgstr ""
+
+#: ../assets/ui/joinserver.menu:108
+msgid "Get New List"
+msgstr ""
+
+#: ../assets/ui/joinserver.menu:130
+msgid "Refresh List"
+msgstr ""
+
+#: ../assets/ui/joinserver.menu:154
+msgid "View Empty:"
+msgstr ""
+
+#: ../assets/ui/joinserver.menu:177
+msgid "View Full:"
+msgstr ""
+
+#: ../assets/ui/joinserver.menu:201
+msgid "[official] = Official Server\\n[featured] = Featured Server"
+msgstr ""
+
+#: ../assets/ui/joinserver.menu:235
+msgid "Server Name"
+msgstr ""
+
+#: ../assets/ui/joinserver.menu:280
+msgid "Map Name"
+msgstr ""
+
+#: ../assets/ui/joinserver.menu:367 ../assets/ui/teamscore.menu:181
+#: ../assets/ui/teamscore.menu:256
+msgid "Ping"
+msgstr ""
+
+#: ../assets/ui/joinserver.menu:476
+msgid "Set Password"
+msgstr ""
+
+#: ../assets/ui/joinserver.menu:495
+msgid "Create Favorite"
+msgstr ""
+
+#: ../assets/ui/joinserver.menu:514
+msgid "Add Favorite"
+msgstr ""
+
+#: ../assets/ui/joinserver.menu:534
+msgid "Delete Favorite"
+msgstr ""
+
+#: ../assets/ui/joinserver.menu:555
+msgid "Server Info"
+msgstr ""
+
+#: ../assets/ui/joinserver.menu:574
+msgid "Find a Friend"
+msgstr ""
+
+#: ../assets/ui/joinserver.menu:597
+msgid "Create Server"
+msgstr ""
+
+#: ../assets/ui/main.menu:30
+msgid "and"
+msgstr ""
+
+#: ../assets/ui/main.menu:59
+msgid "Play"
+msgstr ""
+
+#: ../assets/ui/main.menu:78
+msgid "News"
+msgstr ""
+
+#: ../assets/ui/main.menu:118
+msgid "Mods"
+msgstr ""
+
+#: ../assets/ui/main.menu:158
+msgid "Tremulous (C) 2005-2009 darklegion development"
+msgstr ""
+
+#: ../assets/ui/mod.menu:74
+msgid "Load"
+msgstr ""
+
+#: ../assets/ui/news.menu:49
+msgid "Tremulous News"
+msgstr ""
+
+#: ../assets/ui/options.menu:69
+msgid "Video Quality:"
+msgstr ""
+
+#: ../assets/ui/options.menu:125
+msgid "Video Brightness:"
+msgstr ""
+
+#: ../assets/ui/options.menu:169
+msgid "OpenAL Sound:"
+msgstr ""
+
+#: ../assets/ui/options.menu:224
+msgid "Network Connection:"
+msgstr ""
+
+#: ../assets/ui/options.menu:243
+msgid "Allow Auto Download:"
+msgstr ""
+
+#: ../assets/ui/options.menu:261
+msgid "For further options please use the in-game options menu"
+msgstr ""
+
+#: ../assets/ui/quitcredit.menu:73
+msgid "CREDITS"
+msgstr ""
+
+#: ../assets/ui/quitcredit.menu:90
+msgid "Tim 'Timbo' Angus"
+msgstr ""
+
+#: ../assets/ui/quitcredit.menu:106
+msgid "Programming and Direction"
+msgstr ""
+
+#: ../assets/ui/quitcredit.menu:123
+msgid "Nick 'jex' Jansens"
+msgstr ""
+
+#: ../assets/ui/quitcredit.menu:139
+msgid "Mapping, texturing and 2D artwork"
+msgstr ""
+
+#: ../assets/ui/quitcredit.menu:156
+msgid "Robin 'OverFlow' Marshall"
+msgstr ""
+
+#: ../assets/ui/quitcredit.menu:172
+msgid "Modelling, animation and mapping"
+msgstr ""
+
+#: ../assets/ui/quitcredit.menu:189
+msgid "Jan 'Stannum' van der Weg"
+msgstr ""
+
+#: ../assets/ui/quitcredit.menu:205
+msgid "Texturing and mapping"
+msgstr ""
+
+#: ../assets/ui/quitcredit.menu:222
+msgid "Mike 'Veda' McInerney"
+msgstr ""
+
+#: ../assets/ui/quitcredit.menu:238
+msgid "Modelling, animation and texturing"
+msgstr ""
+
+#: ../assets/ui/quitcredit.menu:255
+msgid "Gordon 'Godmil' Miller"
+msgstr ""
+
+#: ../assets/ui/quitcredit.menu:271 ../assets/ui/quitcredit.menu:304
+#: ../assets/ui/quitcredit.menu:337
+msgid "Mapping"
+msgstr ""
+
+#: ../assets/ui/quitcredit.menu:288
+msgid "'Who-[Soup]'"
+msgstr ""
+
+#: ../assets/ui/quitcredit.menu:321
+msgid "Tristan 'jhrx' Blease"
+msgstr ""
+
+#: ../assets/ui/quitcredit.menu:354
+msgid "Paul 'MoP' Greveson"
+msgstr ""
+
+#: ../assets/ui/quitcredit.menu:370
+msgid "Modelling and texturing"
+msgstr ""
+
+#: ../assets/ui/quitcredit.menu:387
+msgid "Chris 'Dolby' McCarthy"
+msgstr ""
+
+#: ../assets/ui/quit.menu:47
+msgid "Quit Tremulous?"
+msgstr ""
+
+#: ../assets/ui/quit.menu:63
+msgid "YES"
+msgstr ""
+
+#: ../assets/ui/quit.menu:82
+msgid "NO"
+msgstr ""
+
+#: ../assets/ui/say.menu:32
+msgid "Say:"
+msgstr ""
+
+#: ../assets/ui/say.menu:74
+msgid "Say to team:"
+msgstr ""
+
+#: ../assets/ui/say.menu:116
+msgid "Command:"
+msgstr ""
+
+#: ../assets/ui/serverinfo.menu:75
+msgid "Refresh"
+msgstr ""
+
+#: ../assets/ui/teamscore.menu:121 ../assets/ui/teamscore.menu:196
+msgid "Status"
+msgstr ""
+
+#: ../assets/ui/teamscore.menu:136 ../assets/ui/teamscore.menu:211
+msgid "Name"
+msgstr ""
+
+#: ../assets/ui/teamscore.menu:151 ../assets/ui/teamscore.menu:226
+msgid "Score"
+msgstr ""
+
+#: ../assets/ui/teamscore.menu:166 ../assets/ui/teamscore.menu:241
+msgid "Time"
+msgstr ""
+
+#: ../assets/ui/teamscore.menu:346
+msgid "Spectating:"
+msgstr ""
+
+#: ../assets/ui/tremulous_alienclass.menu:98
+#: ../assets/ui/tremulous_humanitem.menu:98
+msgid "< Back"
+msgstr ""
+
+#: ../assets/ui/tremulous_default_hud.menu:25
+msgid "SPECTATOR"
+msgstr ""
+
+#: ../assets/ui/tremulous_humanarmoury.menu:132
+msgid "Buy >"
+msgstr ""
+
+#: ../assets/ui/tremulous_humanarmoury.menu:172
+msgid "< Sell"
+msgstr ""
+
+
+###
+# Teams
+msgid "Aliens"
+msgstr ""
+
+msgid "Humans"
+msgstr ""
+
+msgid "Spectate"
+msgstr ""
+
+# bg_misc.c humanName
+msgid "Overmind"
+msgstr ""
+
+msgid "Barricade"
+msgstr ""
+
+msgid "Acid Tube"
+msgstr ""
+
+msgid "Trapper"
+msgstr ""
+
+msgid "Booster"
+msgstr ""
+
+msgid "Hive"
+msgstr ""
+
+msgid "Telenode"
+msgstr ""
+
+msgid "Machinegun Turret"
+msgstr ""
+
+msgid "Tesla Generator"
+msgstr ""
+
+msgid "Armoury"
+msgstr ""
+
+msgid "Defence Computer"
+msgstr ""
+
+msgid "Medistation"
+msgstr ""
+
+msgid "Reactor"
+msgstr ""
+
+msgid "Repeater"
+msgstr ""
+
+msgid "Bite"
+msgstr ""
+
+msgid "Claws"
+msgstr ""
+
+msgid "Claws Upgrade"
+msgstr ""
+
+#msgid "Bite"
+#msgstr ""
+
+msgid "Zap"
+msgstr ""
+
+msgid "Pounce"
+msgstr ""
+
+msgid "Pounce (upgrade)"
+msgstr ""
+
+msgid "Charge"
+msgstr ""
+
+msgid "Blaster"
+msgstr ""
+
+msgid "Rifle"
+msgstr ""
+
+msgid "Pain Saw"
+msgstr ""
+
+msgid "Shotgun"
+msgstr ""
+
+msgid "Las Gun"
+msgstr ""
+
+msgid "Mass Driver"
+msgstr ""
+
+msgid "Chaingun"
+msgstr ""
+
+msgid "Flame Thrower"
+msgstr ""
+
+msgid "Pulse Rifle"
+msgstr ""
+
+msgid "Lucifer Cannon"
+msgstr ""
+
+msgid "Grenade"
+msgstr ""
+
+msgid "Lock Blob"
+msgstr ""
+
+#msgid "Hive"
+#msgstr ""
+
+#msgid "Tesla Generator"
+#msgstr ""
+
+#msgid "Machinegun Turret"
+#msgstr ""
+
+msgid "Alien build weapon"
+msgstr ""
+
+msgid "Alien build weapon2"
+msgstr ""
+
+msgid "Construction Kit"
+msgstr ""
+
+msgid "Light Armour"
+msgstr ""
+
+msgid "Helmet"
+msgstr ""
+
+msgid "Medkit"
+msgstr ""
+
+msgid "Battery Pack"
+msgstr ""
+
+msgid "Jet Pack"
+msgstr ""
+
+msgid "Battlesuit"
+msgstr ""
+
+#msgid "Grenade"
+#msgstr ""
+
+msgid "Ammunition"
+msgstr ""
+
+# bg_misc.c descriptions
+msgid "The most basic alien structure. It allows aliens to spawn and protect the Overmind. Without any of these, the Overmind is left nearly defenseless and defeat is imminent."
+msgstr ""
+
+msgid "A collective consciousness that controls all the alien structures in its vicinity. It must be protected at all costs, since its death will render alien structures defenseless."
+msgstr ""
+
+msgid "Used to obstruct corridors and doorways, hindering humans from threatening the spawns and Overmind. Barricades will shrink to allow aliens to pass over them, however."
+msgstr ""
+
+msgid "Ejects lethal poisonous acid at an approaching human. These are highly effective when used in conjunction with a trapper to hold the victim in place."
+msgstr ""
+
+msgid "Fires a blob of adhesive spit at any non-alien in its line of sight. This hinders their movement, making them an easy target for other defensive structures or aliens."
+msgstr ""
+
+msgid "Laces the attacks of any alien that touches it with a poison that will gradually deal damage to any humans exposed to it. The booster also increases the rate of health regeneration for any nearby aliens."
+msgstr ""
+
+msgid "Houses millions of tiny insectoid aliens. When a human approaches this structure, the insectoids attack."
+msgstr ""
+
+msgid "The most basic human structure. It provides a means for humans to enter the battle arena. Without any of these the humans cannot spawn and defeat is imminent."
+msgstr ""
+
+msgid "Automated base defense that is effective against large targets but slow to begin firing. Should always be backed up by physical support."
+msgstr ""
+
+msgid "A structure equipped with a strong electrical attack that fires instantly and always hits its target. It is effective against smaller aliens and for consolidating basic defense."
+msgstr ""
+
+msgid "An essential part of the human base, providing a means to upgrade the basic human equipment. A range of upgrades and weapons are available for sale from the armoury."
+msgstr ""
+
+msgid "A structure that enables self-repair functionality in human structures. Each Defence Computer built increases repair rate slightly."
+msgstr ""
+
+msgid "A structure that automatically restores the health and stamina of any human that stands on it. It may only be used by one person at a time. This structure also issues medkits."
+msgstr ""
+
+msgid "All structures except the telenode rely on a reactor to operate. The reactor provides power for all the human structures either directly or via repeaters. Only one reactor can be built at a time."
+msgstr ""
+
+msgid "A power distributor that transmits power from the reactor to remote locations, so that bases may be built far from the reactor."
+msgstr ""
+
+msgid "Similar to the base Granger, except that in addition to being able to build structures it has a spit attack that slows victims and the ability to crawl on walls."
+msgstr ""
+
+msgid "Has a lethal reflexive bite and the ability to crawl on walls and ceilings."
+msgstr ""
+
+msgid "A support class able to crawl on walls and ceilings. Its melee attack is most effective when combined with the ability to grab and hold its victims in place. Provides a weak healing aura that accelerates the healing rate of nearby aliens."
+msgstr ""
+
+msgid "In addition to the basic Basilisk abilities, the Advanced Basilisk sprays a poisonous gas which disorients any nearby humans. Has a strong healing aura that that accelerates the healing rate of nearby aliens."
+msgstr ""
+
+msgid "Has a melee attack and the ability to jump off walls. This allows the Marauder to gather great speed in enclosed areas."
+msgstr ""
+
+msgid "The Advanced Marauder has all the abilities of the basic Marauder with the addition of an area effect electric shock attack."
+msgstr ""
+
+msgid "Possesses a melee attack and the pounce ability, which may be used as both an attack and a means to reach remote locations inaccessible from the ground."
+msgstr ""
+
+msgid "In addition to the basic Dragoon abilities, the Advanced Dragoon has 3 barbs which may be used to attack humans from a distance."
+msgstr ""
+
+msgid "A large alien with a strong melee attack, this class can also charge at enemy humans and structures, inflicting great damage. Any humans or their structures caught under a falling Tyrant will be crushed by its weight."
+msgstr ""
+
+msgid "Basic weapon. Cased projectile weapon, with a slow clip based reload system."
+msgstr ""
+
+msgid "Similar to a chainsaw, but instead of a chain it has an electric arc capable of dealing a great deal of damage at close range."
+msgstr ""
+
+msgid "Close range weapon that is useful against larger foes. It has a slow repeat rate, but can be devastatingly effective."
+msgstr ""
+
+msgid "Slightly more powerful than the basic rifle, rapidly fires small packets of energy."
+msgstr ""
+
+msgid "A portable particle accelerator which causes minor nuclear reactions at the point of impact. It has a very large payload, but fires slowly."
+msgstr ""
+
+msgid "Belt drive, cased projectile weapon. It has a high repeat rate but a wide firing angle and is therefore relatively inaccurate."
+msgstr ""
+
+msgid "Sprays fire at its target. It is powered by compressed gas. The relatively low rate of fire means this weapon is most effective against static targets."
+msgstr ""
+
+msgid "An energy weapon that fires rapid pulses of concentrated energy."
+msgstr ""
+
+msgid "Blaster technology scaled up to deliver devastating power. Primary fire must be charged before firing. It has a quick secondary attack that does not require charging."
+msgstr ""
+
+msgid "Used for building structures. This includes spawns, power and basic defense. More structures become available with new stages."
+msgstr ""
+
+msgid "Protective armour that helps to defend against light alien melee attacks."
+msgstr ""
+
+msgid "In addition to protecting your head, the helmet provides a scanner indicating the presence of any friendly or hostile lifeforms and structures in your immediate vicinity."
+msgstr ""
+
+msgid "Back-mounted battery pack that permits storage of one and a half times the normal energy capacity for energy weapons."
+msgstr ""
+
+msgid "Back-mounted jet pack that enables the user to fly to remote locations. It is very useful against alien spawns in hard to reach spots."
+msgstr ""
+
+msgid "A full body armour that is highly effective at repelling alien attacks. It allows the user to enter hostile situations with a greater degree of confidence."
+msgstr ""
+
+msgid "A small incendinary device ideal for damaging tightly packed alien structures. Has a five second timer."
+msgstr ""
+
+msgid "Ammunition for the currently held weapon."
+msgstr ""
+
+# Misc
+msgid "ui/help.txt"
+msgstr ""
diff --git a/src/cgame/cg_attachment.c b/src/cgame/cg_attachment.c
index da094a5..77585be 100644
--- a/src/cgame/cg_attachment.c
+++ b/src/cgame/cg_attachment.c
@@ -90,7 +90,7 @@ qboolean CG_AttachmentPoint( attachment_t *a, vec3_t v )
       break;
 
     default:
-      CG_Printf( S_COLOR_RED "ERROR: Invalid attachmentType_t in attachment\n" );
+      CG_Printf( _(S_COLOR_RED "ERROR: Invalid attachmentType_t in attachment\n") );
       break;
   }
 
@@ -153,7 +153,7 @@ qboolean CG_AttachmentDir( attachment_t *a, vec3_t v )
       break;
 
     default:
-      CG_Printf( S_COLOR_RED "ERROR: Invalid attachmentType_t in attachment\n" );
+      CG_Printf( _(S_COLOR_RED "ERROR: Invalid attachmentType_t in attachment\n") );
       break;
   }
 
@@ -201,7 +201,7 @@ qboolean CG_AttachmentAxis( attachment_t *a, vec3_t axis[ 3 ] )
       break;
 
     default:
-      CG_Printf( S_COLOR_RED "ERROR: Invalid attachmentType_t in attachment\n" );
+      CG_Printf( _(S_COLOR_RED "ERROR: Invalid attachmentType_t in attachment\n") );
       break;
   }
 
diff --git a/src/cgame/cg_buildable.c b/src/cgame/cg_buildable.c
index cef82e1..0101d68 100644
--- a/src/cgame/cg_buildable.c
+++ b/src/cgame/cg_buildable.c
@@ -175,7 +175,7 @@ static qboolean CG_ParseBuildableAnimationFile( const char *filename, buildable_
   if( len == 0 || len >= sizeof( text ) - 1 )
   {
     trap_FS_FCloseFile( f );
-    CG_Printf( "File %s is %s\n", filename, len == 0 ? "empty" : "too long" );
+    CG_Printf( _("File %s is %s\n"), filename, len == 0 ? "empty" : "too long" );
     return qfalse;
   }
 
@@ -231,7 +231,7 @@ static qboolean CG_ParseBuildableAnimationFile( const char *filename, buildable_
 
   if( i != MAX_BUILDABLE_ANIMATIONS )
   {
-    CG_Printf( "Error parsing animation file: %s\n", filename );
+    CG_Printf( _("Error parsing animation file: %s\n"), filename );
     return qfalse;
   }
 
@@ -266,7 +266,7 @@ static qboolean CG_ParseBuildableSoundFile( const char *filename, buildable_t bu
   if ( len == 0 || len >= sizeof( text ) - 1 )
   {
     trap_FS_FCloseFile( f );
-    CG_Printf( "File %s is %s\n", filename, len == 0 ? "empty" : "too long" );
+    CG_Printf( _("File %s is %s\n"), filename, len == 0 ? "empty" : "too long" );
     return qfalse;
   }
 
@@ -297,7 +297,7 @@ static qboolean CG_ParseBuildableSoundFile( const char *filename, buildable_t bu
 
   if( i != MAX_BUILDABLE_ANIMATIONS )
   {
-    CG_Printf( "Error parsing sound file: %s\n", filename );
+    CG_Printf( _("Error parsing sound file: %s\n"), filename );
     return qfalse;
   }
 
@@ -343,12 +343,12 @@ void CG_InitBuildables( void )
     //animation.cfg
     Com_sprintf( filename, sizeof( filename ), "models/buildables/%s/animation.cfg", buildableName );
     if ( !CG_ParseBuildableAnimationFile( filename, i ) )
-      Com_Printf( S_COLOR_YELLOW "WARNING: failed to load animation file %s\n", filename );
+      Com_Printf( _(S_COLOR_YELLOW "WARNING: failed to load animation file %s\n"), filename );
 
     //sound.cfg
     Com_sprintf( filename, sizeof( filename ), "sound/buildables/%s/sound.cfg", buildableName );
     if ( !CG_ParseBuildableSoundFile( filename, i ) )
-      Com_Printf( S_COLOR_YELLOW "WARNING: failed to load sound file %s\n", filename );
+      Com_Printf( _(S_COLOR_YELLOW "WARNING: failed to load sound file %s\n"), filename );
 
     //models
     for( j = 0; j <= 3; j++ )
@@ -405,7 +405,7 @@ static void CG_SetBuildableLerpFrameAnimation( buildable_t buildable, lerpFrame_
   lf->animationNumber = newAnimation;
 
   if( newAnimation < 0 || newAnimation >= MAX_BUILDABLE_ANIMATIONS )
-    CG_Error( "Bad animation number: %i", newAnimation );
+    CG_Error( _("Bad animation number: %i"), newAnimation );
 
   anim = &cg_buildables[ buildable ].animations[ newAnimation ];
 
@@ -417,7 +417,7 @@ static void CG_SetBuildableLerpFrameAnimation( buildable_t buildable, lerpFrame_
   lf->animationTime = lf->frameTime + anim->initialLerp;
 
   if( cg_debugAnim.integer )
-    CG_Printf( "Anim: %i\n", newAnimation );
+    CG_Printf( _("Anim: %i\n"), newAnimation );
 }
 
 /*
@@ -438,7 +438,7 @@ static void CG_RunBuildableLerpFrame( centity_t *cent )
   if( newAnimation != lf->animationNumber || !lf->animation )
   {
     if( cg_debugRandom.integer )
-      CG_Printf( "newAnimation: %d lf->animationNumber: %d lf->animation: %d\n",
+      CG_Printf( _("newAnimation: %d lf->animationNumber: %d lf->animation: %d\n"),
                  newAnimation, lf->animationNumber, lf->animation );
 
     CG_SetBuildableLerpFrameAnimation( buildable, lf, newAnimation );
@@ -447,7 +447,7 @@ static void CG_RunBuildableLerpFrame( centity_t *cent )
         cg_buildables[ buildable ].sounds[ newAnimation ].enabled )
     {
       if( cg_debugRandom.integer )
-        CG_Printf( "Sound for animation %d for a %s\n",
+        CG_Printf( _("Sound for animation %d for a %s\n"),
             newAnimation, BG_Buildable( buildable )->humanName );
 
       trap_S_StartSound( cent->lerpOrigin, cent->currentState.number, CHAN_AUTO,
@@ -820,7 +820,7 @@ void CG_BuildableStatusParse( const char *filename, buildStat_t *bs )
     }
     else
     {
-      Com_Printf("CG_BuildableStatusParse: unknown token %s in %s\n",
+      Com_Printf(_("CG_BuildableStatusParse: unknown token %s in %s\n"),
         token.string, filename );
       bs->loaded = qfalse;
       trap_Parse_FreeSource( handle );
diff --git a/src/cgame/cg_consolecmds.c b/src/cgame/cg_consolecmds.c
index 23a2289..cbd87ff 100644
--- a/src/cgame/cg_consolecmds.c
+++ b/src/cgame/cg_consolecmds.c
@@ -177,7 +177,7 @@ void CG_ClientList_f( void )
     count++;
   }
 
-  Com_Printf( "Listed %2d clients\n", count );
+  Com_Printf( _("Listed %2d clients\n"), count );
 }
 
 static void CG_UIMenu_f( void )
diff --git a/src/cgame/cg_draw.c b/src/cgame/cg_draw.c
index 848b20d..4298960 100644
--- a/src/cgame/cg_draw.c
+++ b/src/cgame/cg_draw.c
@@ -1381,13 +1381,13 @@ static void CG_DrawTeamLabel( rectDef_t *rect, team_t team, float text_x, float
     case TEAM_ALIENS:
       t = "Aliens";
       if( cg.intermissionStarted )
-        Com_sprintf( stage, MAX_TOKEN_CHARS, "(Stage %d)", cgs.alienStage + 1 );
+        Com_sprintf( stage, MAX_TOKEN_CHARS, _("(Stage %d)"), cgs.alienStage + 1 );
       break;
 
     case TEAM_HUMANS:
       t = "Humans";
       if( cg.intermissionStarted )
-        Com_sprintf( stage, MAX_TOKEN_CHARS, "(Stage %d)", cgs.humanStage + 1 );
+        Com_sprintf( stage, MAX_TOKEN_CHARS, _("(Stage %d)"), cgs.humanStage + 1 );
       break;
 
     default:
@@ -1435,12 +1435,12 @@ static void CG_DrawStageReport( rectDef_t *rect, float text_x, float text_y,
       kills = 0;
 
     if( cgs.alienNextStageThreshold < 0 )
-      Com_sprintf( s, MAX_TOKEN_CHARS, "Stage %d", cgs.alienStage + 1 );
+      Com_sprintf( s, MAX_TOKEN_CHARS, _("Stage %d"), cgs.alienStage + 1 );
     else if( kills == 1 )
-      Com_sprintf( s, MAX_TOKEN_CHARS, "Stage %d, 1 frag for next stage",
+      Com_sprintf( s, MAX_TOKEN_CHARS, _("Stage %d, 1 frag for next stage"),
           cgs.alienStage + 1 );
     else
-      Com_sprintf( s, MAX_TOKEN_CHARS, "Stage %d, %d frags for next stage",
+      Com_sprintf( s, MAX_TOKEN_CHARS, _("Stage %d, %d frags for next stage"),
           cgs.alienStage + 1, kills );
   }
   else if( cg.snap->ps.stats[ STAT_TEAM ] == TEAM_HUMANS )
@@ -1451,9 +1451,9 @@ static void CG_DrawStageReport( rectDef_t *rect, float text_x, float text_y,
       credits = 0;
 
     if( cgs.humanNextStageThreshold < 0 )
-      Com_sprintf( s, MAX_TOKEN_CHARS, "Stage %d", cgs.humanStage + 1 );
+      Com_sprintf( s, MAX_TOKEN_CHARS, _("Stage %d"), cgs.humanStage + 1 );
     else if( credits == 1 )
-      Com_sprintf( s, MAX_TOKEN_CHARS, "Stage %d, 1 credit for next stage",
+      Com_sprintf( s, MAX_TOKEN_CHARS, _("Stage %d, 1 credit for next stage"),
           cgs.humanStage + 1 );
     else
       Com_sprintf( s, MAX_TOKEN_CHARS, "Stage %d, %d credits for next stage",
@@ -2865,8 +2865,21 @@ void CG_EventHandling( int type )
 
 
 
-void CG_KeyEvent( int key, qboolean down )
+void CG_KeyEvent( int key, int state )
 {
+  qboolean sup = state & (1 << KEYEVSTATE_SUP);
+  qboolean down = !sup ? state : state & (1 << KEYEVSTATE_DOWN);
+
+  if( sup )
+  {
+    qboolean bit = ( state & (1 << KEYEVSTATE_BIT) ) >> KEYEVSTATE_BIT;
+
+    if( bit )
+      key |= bit << (K_CHAR_BIT - 1);
+    else
+      key &= ~(bit << (K_CHAR_BIT - 1));
+  }
+
   if( !down )
     return;
 
@@ -2879,7 +2892,7 @@ void CG_KeyEvent( int key, qboolean down )
     return;
   }
 
-  Display_HandleKey( key, down, cgs.cursorX, cgs.cursorY );
+  Display_HandleKey( key, state, cgs.cursorX, cgs.cursorY );
 
   if( cgs.capturedItem )
     cgs.capturedItem = NULL;
@@ -2958,6 +2971,9 @@ void CG_CenterPrint( const char *str, int y, int charWidth )
   const char *wrapped;
   static int maxWidth = (int)( ( 2.0f / 3.0f ) * (float)SCREEN_WIDTH );
 
+  if( cg_translateCenterPrint.integer )
+    str = _(str);
+
   Q_ParseNewlines( newlineParsed, str, sizeof( newlineParsed ) );
 
   wrapped = Item_Text_Wrap( newlineParsed, 0.5f, maxWidth );
@@ -3196,18 +3212,18 @@ static qboolean CG_DrawQueue( void )
       break;
   }
 
-  Com_sprintf( buffer, MAX_STRING_CHARS, "You are %d%s in the spawn queue",
+  Com_sprintf( buffer, MAX_STRING_CHARS, _("You are %d%s in the spawn queue"),
                position, ordinal );
 
   w = UI_Text_Width( buffer, 0.7f, 0 );
   UI_Text_Paint( 320 - w / 2, 360, 0.7f, color, buffer, 0, 0, ITEM_TEXTSTYLE_SHADOWED );
 
   if( cg.snap->ps.persistant[ PERS_SPAWNS ] == 0 )
-    Com_sprintf( buffer, MAX_STRING_CHARS, "There are no spawns remaining" );
+    Com_sprintf( buffer, MAX_STRING_CHARS, _("There are no spawns remaining") );
   else if( cg.snap->ps.persistant[ PERS_SPAWNS ] == 1 )
-    Com_sprintf( buffer, MAX_STRING_CHARS, "There is 1 spawn remaining" );
+    Com_sprintf( buffer, MAX_STRING_CHARS, _("There is 1 spawn remaining") );
   else
-    Com_sprintf( buffer, MAX_STRING_CHARS, "There are %d spawns remaining",
+    Com_sprintf( buffer, MAX_STRING_CHARS, _("There are %d spawns remaining"),
                  cg.snap->ps.persistant[ PERS_SPAWNS ] );
 
   w = UI_Text_Width( buffer, 0.7f, 0 );
@@ -3290,7 +3306,7 @@ static void CG_Draw2D( void )
     menu = Menus_FindByName( "default_hud" );
 
     if( !menu ) // still couldn't find it
-      CG_Error( "Default HUD could not be found" );
+      CG_Error( _("Default HUD could not be found") );
   }
 
   Menu_Update( menu );
@@ -3474,7 +3490,7 @@ void CG_DrawActive( stereoFrame_t stereoView )
       break;
     default:
       separation = 0;
-      CG_Error( "CG_DrawActive: Undefined stereoView" );
+      CG_Error( _("CG_DrawActive: Undefined stereoView") );
   }
 
   // clear around the rendered view if sized down
diff --git a/src/cgame/cg_ents.c b/src/cgame/cg_ents.c
index b2794a8..49f4dc3 100644
--- a/src/cgame/cg_ents.c
+++ b/src/cgame/cg_ents.c
@@ -900,7 +900,7 @@ static void CG_InterpolateEntityPosition( centity_t *cent )
   // it would be an internal error to find an entity that interpolates without
   // a snapshot ahead of the current one
   if( cg.nextSnap == NULL )
-    CG_Error( "CG_InterpoateEntityPosition: cg.nextSnap == NULL" );
+    CG_Error( _("CG_InterpoateEntityPosition: cg.nextSnap == NULL") );
 
   f = cg.frameInterpolation;
 
@@ -1009,7 +1009,7 @@ static void CG_CEntityPVSEnter( centity_t *cent )
   entityState_t *es = &cent->currentState;
 
   if( cg_debugPVS.integer )
-    CG_Printf( "Entity %d entered PVS\n", cent->currentState.number );
+    CG_Printf( _("Entity %d entered PVS\n"), cent->currentState.number );
 
   switch( es->eType )
   {
@@ -1050,7 +1050,7 @@ static void CG_CEntityPVSLeave( centity_t *cent )
   entityState_t *es = &cent->currentState;
 
   if( cg_debugPVS.integer )
-    CG_Printf( "Entity %d left PVS\n", cent->currentState.number );
+    CG_Printf( _("Entity %d left PVS\n"), cent->currentState.number );
   switch( es->eType )
   {
     case ET_LEV2_ZAP_CHAIN:
@@ -1085,7 +1085,7 @@ static void CG_AddCEntity( centity_t *cent )
   switch( cent->currentState.eType )
   {
     default:
-      CG_Error( "Bad entity type: %i\n", cent->currentState.eType );
+      CG_Error( _("Bad entity type: %i\n"), cent->currentState.eType );
       break;
 
     case ET_INVISIBLE:
diff --git a/src/cgame/cg_event.c b/src/cgame/cg_event.c
index b87cb2d..f7c8a87 100644
--- a/src/cgame/cg_event.c
+++ b/src/cgame/cg_event.c
@@ -51,7 +51,7 @@ static void CG_Obituary( entityState_t *ent )
   mod = ent->eventParm;
 
   if( target < 0 || target >= MAX_CLIENTS )
-    CG_Error( "CG_Obituary: target out of range" );
+    CG_Error( _("CG_Obituary: target out of range") );
 
   ci = &cgs.clientinfo[ target ];
   gender = ci->gender;
@@ -196,7 +196,7 @@ static void CG_Obituary( entityState_t *ent )
 
   if( message )
   {
-    CG_Printf( "%s" S_COLOR_WHITE " %s\n", targetName, message );
+    CG_Printf( _("%s" S_COLOR_WHITE " %s\n"), targetName, message );
     return;
   }
 
@@ -219,128 +219,128 @@ static void CG_Obituary( entityState_t *ent )
     switch( mod )
     {
       case MOD_PAINSAW:
-        message = "was sawn by";
+        message = _("was sawn by");
         break;
       case MOD_BLASTER:
-        message = "was blasted by";
+        message = _("was blasted by");
         break;
       case MOD_MACHINEGUN:
-        message = "was machinegunned by";
+        message = _("was machinegunned by");
         break;
       case MOD_CHAINGUN:
-        message = "was chaingunned by";
+        message = _("was chaingunned by");
         break;
       case MOD_SHOTGUN:
-        message = "was gunned down by";
+        message = _("was gunned down by");
         break;
       case MOD_PRIFLE:
-        message = "was pulse rifled by";
+        message = _("was pulse rifled by");
         break;
       case MOD_MDRIVER:
-        message = "was mass driven by";
+        message = _("was mass driven by");
         break;
       case MOD_LASGUN:
-        message = "was lasgunned by";
+        message = _("was lasgunned by");
         break;
       case MOD_FLAMER:
-        message = "was grilled by";
-        message2 = "'s flamer";
+        message = _("was grilled by");
+        message2 = _("'s flamer");
         break;
       case MOD_FLAMER_SPLASH:
-        message = "was toasted by";
-        message2 = "'s flamer";
+        message = _("was toasted by");
+        message2 = _("'s flamer");
         break;
       case MOD_LCANNON:
-        message = "felt the full force of";
-        message2 = "'s lucifer cannon";
+        message = _("felt the full force of");
+        message2 = _("'s lucifer cannon");
         break;
       case MOD_LCANNON_SPLASH:
-        message = "was caught in the fallout of";
-        message2 = "'s lucifer cannon";
+        message = _("was caught in the fallout of");
+        message2 = _("'s lucifer cannon");
         break;
       case MOD_GRENADE:
-        message = "couldn't escape";
-        message2 = "'s grenade";
+        message = _("couldn't escape");
+        message2 = _("'s grenade");
         break;
 
       case MOD_ABUILDER_CLAW:
-        message = "should leave";
-        message2 = "'s buildings alone";
+        message = _("should leave");
+        message2 = _("'s buildings alone");
         break;
       case MOD_LEVEL0_BITE:
-        message = "was bitten by";
+        message = _("was bitten by");
         break;
       case MOD_LEVEL1_CLAW:
-        message = "was swiped by";
-        Com_sprintf( className, 64, "'s %s",
-            BG_ClassConfig( PCL_ALIEN_LEVEL1 )->humanName );
+        message = _("was swiped by");
+        Com_sprintf( className, 64, _("'s %s"),
+            _(BG_ClassConfig( PCL_ALIEN_LEVEL1 )->humanName) );
         message2 = className;
         break;
       case MOD_LEVEL2_CLAW:
-        message = "was clawed by";
-        Com_sprintf( className, 64, "'s %s",
-            BG_ClassConfig( PCL_ALIEN_LEVEL2 )->humanName );
+        message = _("was clawed by");
+        Com_sprintf( className, 64, _("'s %s"),
+            _(BG_ClassConfig( PCL_ALIEN_LEVEL2 )->humanName) );
         message2 = className;
         break;
       case MOD_LEVEL2_ZAP:
-        message = "was zapped by";
-        Com_sprintf( className, 64, "'s %s",
-            BG_ClassConfig( PCL_ALIEN_LEVEL2 )->humanName );
+        message = _("was zapped by");
+        Com_sprintf( className, 64, _("'s %s"),
+            _(BG_ClassConfig( PCL_ALIEN_LEVEL2 )->humanName) );
         message2 = className;
         break;
       case MOD_LEVEL3_CLAW:
-        message = "was chomped by";
-        Com_sprintf( className, 64, "'s %s",
-            BG_ClassConfig( PCL_ALIEN_LEVEL3 )->humanName );
+        message = _("was chomped by");
+        Com_sprintf( className, 64, _("'s %s"),
+            _(BG_ClassConfig( PCL_ALIEN_LEVEL3 )->humanName) );
         message2 = className;
         break;
       case MOD_LEVEL3_POUNCE:
-        message = "was pounced upon by";
-        Com_sprintf( className, 64, "'s %s",
-            BG_ClassConfig( PCL_ALIEN_LEVEL3 )->humanName );
+        message = _("was pounced upon by");
+        Com_sprintf( className, 64, _("'s %s"),
+            _(BG_ClassConfig( PCL_ALIEN_LEVEL3 )->humanName) );
         message2 = className;
         break;
       case MOD_LEVEL3_BOUNCEBALL:
-        message = "was sniped by";
-        Com_sprintf( className, 64, "'s %s",
-            BG_ClassConfig( PCL_ALIEN_LEVEL3 )->humanName );
+        message = _("was sniped by");
+        Com_sprintf( className, 64, _("'s %s"),
+            _(BG_ClassConfig( PCL_ALIEN_LEVEL3 )->humanName) );
         message2 = className;
         break;
       case MOD_LEVEL4_CLAW:
-        message = "was mauled by";
-        Com_sprintf( className, 64, "'s %s",
-            BG_ClassConfig( PCL_ALIEN_LEVEL4 )->humanName );
+        message = _("was mauled by");
+        Com_sprintf( className, 64, _("'s %s"),
+            _(BG_ClassConfig( PCL_ALIEN_LEVEL4 )->humanName) );
         message2 = className;
         break;
       case MOD_LEVEL4_TRAMPLE:
-        message = "should have gotten out of the way of";
-        Com_sprintf( className, 64, "'s %s",
-            BG_ClassConfig( PCL_ALIEN_LEVEL4 )->humanName );
+        message = _("should have gotten out of the way of");
+        Com_sprintf( className, 64, _("'s %s"),
+            _(BG_ClassConfig( PCL_ALIEN_LEVEL4 )->humanName) );
         message2 = className;
         break;
       case MOD_LEVEL4_CRUSH:
-        message = "was crushed under";
-        message2 = "'s weight";
+        message = _("was crushed under");
+        message2 = _("'s weight");
         break;
 
       case MOD_POISON:
-        message = "should have used a medkit against";
-        message2 = "'s poison";
+        message = _("should have used a medkit against");
+        message2 = _("'s poison");
         break;
       case MOD_LEVEL1_PCLOUD:
-        message = "was gassed by";
-        Com_sprintf( className, 64, "'s %s",
-            BG_ClassConfig( PCL_ALIEN_LEVEL1 )->humanName );
+        message = _("was gassed by");
+        Com_sprintf( className, 64, _("'s %s"),
+            _(BG_ClassConfig( PCL_ALIEN_LEVEL1 )->humanName) );
         message2 = className;
         break;
 
 
       case MOD_TELEFRAG:
-        message = "tried to invade";
-        message2 = "'s personal space";
+        message = _("tried to invade");
+        message2 = _("'s personal space");
         break;
       default:
-        message = "was killed by";
+        message = _("was killed by");
         break;
     }
 
@@ -348,12 +348,12 @@ static void CG_Obituary( entityState_t *ent )
     {
       CG_Printf( "%s" S_COLOR_WHITE " %s %s%s" S_COLOR_WHITE "%s\n",
         targetName, message,
-        ( teamKill ) ? S_COLOR_RED "TEAMMATE " S_COLOR_WHITE : "",
+        ( teamKill ) ? _(S_COLOR_RED "TEAMMATE " S_COLOR_WHITE) : "",
         attackerName, message2 );
       if( teamKill && attacker == cg.clientNum )
       {
-        CG_CenterPrint( va ( "You killed " S_COLOR_RED "TEAMMATE "
-          S_COLOR_WHITE "%s", targetName ),
+        CG_CenterPrint( va ( _("You killed " S_COLOR_RED "TEAMMATE "
+          S_COLOR_WHITE "%s"), targetName ),
           SCREEN_HEIGHT * 0.30, BIGCHAR_WIDTH );
       }
       return;
@@ -361,7 +361,7 @@ static void CG_Obituary( entityState_t *ent )
   }
 
   // we don't know what it was
-  CG_Printf( "%s" S_COLOR_WHITE " died\n", targetName );
+  CG_Printf( _("%s" S_COLOR_WHITE " died\n"), targetName );
 }
 
 
@@ -481,7 +481,7 @@ void CG_EntityEvent( centity_t *cent, vec3_t position )
   event = es->event & ~EV_EVENT_BITS;
 
   if( cg_debugEvents.integer )
-    CG_Printf( "ent:%3i  event:%3i %s\n", es->number, event,
+    CG_Printf( _("ent:%3i  event:%3i %s\n"), es->number, event,
                BG_EventName( event ) );
 
   if( !event )
@@ -901,7 +901,7 @@ void CG_EntityEvent( centity_t *cent, vec3_t position )
       if( cg.predictedPlayerState.stats[ STAT_TEAM ] == TEAM_ALIENS )
       {
         trap_S_StartLocalSound( cgs.media.alienOvermindAttack, CHAN_ANNOUNCER );
-        CG_CenterPrint( "The Overmind is under attack!", 200, GIANTCHAR_WIDTH * 4 );
+        CG_CenterPrint( _("The Overmind is under attack!"), 200, GIANTCHAR_WIDTH * 4 );
       }
       break;
 
@@ -909,7 +909,7 @@ void CG_EntityEvent( centity_t *cent, vec3_t position )
       if( cg.predictedPlayerState.stats[ STAT_TEAM ] == TEAM_ALIENS )
       {
         trap_S_StartLocalSound( cgs.media.alienOvermindDying, CHAN_ANNOUNCER );
-        CG_CenterPrint( "The Overmind is dying!", 200, GIANTCHAR_WIDTH * 4 );
+        CG_CenterPrint( _("The Overmind is dying!"), 200, GIANTCHAR_WIDTH * 4 );
       }
       break;
 
@@ -917,7 +917,7 @@ void CG_EntityEvent( centity_t *cent, vec3_t position )
       if( cg.predictedPlayerState.stats[ STAT_TEAM ] == TEAM_HUMANS )
       {
         //trap_S_StartLocalSound( cgs.media.humanDCCAttack, CHAN_ANNOUNCER );
-        CG_CenterPrint( "Our base is under attack!", 200, GIANTCHAR_WIDTH * 4 );
+        CG_CenterPrint( _("Our base is under attack!"), 200, GIANTCHAR_WIDTH * 4 );
       }
       break;
 
@@ -929,7 +929,7 @@ void CG_EntityEvent( centity_t *cent, vec3_t position )
       if( cg.predictedPlayerState.stats[ STAT_TEAM ] == TEAM_ALIENS )
       {
         trap_S_StartLocalSound( cgs.media.alienOvermindSpawns, CHAN_ANNOUNCER );
-        CG_CenterPrint( "The Overmind needs spawns!", 200, GIANTCHAR_WIDTH * 4 );
+        CG_CenterPrint( _("The Overmind needs spawns!"), 200, GIANTCHAR_WIDTH * 4 );
       }
       break;
 
@@ -989,7 +989,7 @@ void CG_EntityEvent( centity_t *cent, vec3_t position )
       break;
 
     default:
-      CG_Error( "Unknown event: %i", event );
+      CG_Error( _("Unknown event: %i"), event );
       break;
   }
 }
diff --git a/src/cgame/cg_local.h b/src/cgame/cg_local.h
index 6bc011f..89126e6 100644
--- a/src/cgame/cg_local.h
+++ b/src/cgame/cg_local.h
@@ -79,6 +79,8 @@ Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 #define TEAM_OVERLAY_MAXNAME_WIDTH  12
 #define TEAM_OVERLAY_MAXLOCATION_WIDTH  16
 
+#define _(String) gettext(String)
+
 typedef enum
 {
   FOOTSTEP_NORMAL,
@@ -1538,6 +1540,8 @@ extern  vmCvar_t    cg_emoticons;
 
 extern  vmCvar_t    cg_chatTeamPrefix;
 
+extern  vmCvar_t    cg_translateCenterPrint;
+
 //
 // cg_main.c
 //
@@ -1555,7 +1559,7 @@ void        CG_UpdateCvars( void );
 int         CG_CrosshairPlayer( void );
 int         CG_LastAttacker( void );
 void        CG_LoadMenus( const char *menuFile );
-void        CG_KeyEvent( int key, qboolean down );
+void        CG_KeyEvent( int key, int state );
 void        CG_MouseEvent( int x, int y );
 void        CG_EventHandling( int type );
 void        CG_SetScoreSelection( void *menu );
@@ -2038,6 +2042,18 @@ void          testPrintFloat( char *string, float f );
 
 int           trap_MemoryRemaining( void );
 void          trap_R_RegisterFont(const char *fontName, int pointSize, fontInfo_t *font);
+void          trap_R_LoadFace(const char *fileName, int pointSize, const char *name, face_t *face);
+void          trap_R_FreeFace(face_t *face);
+void          trap_R_LoadGlyph(face_t *face, const char *str, int img, glyphInfo_t *glyphInfo);
+void          trap_R_FreeGlyph(face_t *face, int img, glyphInfo_t *glyphInfo);
+void          trap_R_Glyph(fontInfo_t *font, face_t *face, const char *str, glyphInfo_t *glyph);
+void          trap_R_FreeCachedGlyphs(face_t *face);
+void          LoadFace(const char *fileName, int pointSize, const char *name, face_t *face);
+void          FreeFace(face_t *face);
+void          LoadGlyph(face_t *face, const char *str, int img, glyphInfo_t *glyphInfo);
+void          FreeGlyph(face_t *face, int img, glyphInfo_t *glyphInfo);
+void          Glyph(fontInfo_t *font, face_t *face, const char *str, glyphInfo_t *glyph);
+void          FreeCachedGlyphs(face_t *face);
 qboolean      trap_Key_IsDown( int keynum );
 int           trap_Key_GetCatcher( void );
 void          trap_Key_SetCatcher( int catcher );
@@ -2067,6 +2083,10 @@ int           trap_GetDemoState( void );
 int           trap_GetDemoPos( void );
 void          trap_GetDemoName( char *buffer, int size );
 
+void          trap_Gettext ( char *buffer, const char *msgid, int bufferLength );
+void          Gettext ( char *buffer, const char *msgid, int bufferLength );
+char          *gettext ( const char *msgid );
+
 // cg_drawCrosshair settings
 #define CROSSHAIR_ALWAYSOFF       0
 #define CROSSHAIR_RANGEDONLY      1
diff --git a/src/cgame/cg_main.c b/src/cgame/cg_main.c
index dd08e32..132f492 100644
--- a/src/cgame/cg_main.c
+++ b/src/cgame/cg_main.c
@@ -219,6 +219,8 @@ vmCvar_t  cg_emoticons;
 
 vmCvar_t  cg_chatTeamPrefix;
 
+vmCvar_t  cg_translateCenterPrint;
+
 typedef struct
 {
   vmCvar_t  *vmCvar;
@@ -350,7 +352,9 @@ static cvarTable_t cvarTable[ ] =
 
   { &cg_emoticons, "cg_emoticons", "1", CVAR_LATCH|CVAR_ARCHIVE},
 
-  { &cg_chatTeamPrefix, "cg_chatTeamPrefix", "1", CVAR_ARCHIVE}
+  { &cg_chatTeamPrefix, "cg_chatTeamPrefix", "1", CVAR_ARCHIVE},
+
+  { &cg_translateCenterPrint, "cg_translateCenterPrint", "0", CVAR_ARCHIVE}
 };
 
 static int   cvarTableSize = sizeof( cvarTable ) / sizeof( cvarTable[0] );
@@ -956,7 +960,7 @@ CG_ConfigString
 const char *CG_ConfigString( int index )
 {
   if( index < 0 || index >= MAX_CONFIGSTRINGS )
-    CG_Error( "CG_ConfigString: bad index: %i", index );
+    CG_Error( _("CG_ConfigString: bad index: %i"), index );
 
   return cgs.gameState.stringData + cgs.gameState.stringOffsets[ index ];
 }
@@ -1018,13 +1022,13 @@ char *CG_GetMenuBuffer( const char *filename )
 
   if( !f )
   {
-    trap_Print( va( S_COLOR_RED "menu file not found: %s, using default\n", filename ) );
+    trap_Print( va( _(S_COLOR_RED "menu file not found: %s, using default\n"), filename ) );
     return NULL;
   }
 
   if( len >= MAX_MENUFILE )
   {
-    trap_Print( va( S_COLOR_RED "menu file too large: %s is %i, max allowed is %i",
+    trap_Print( va( _(S_COLOR_RED "menu file too large: %s is %i, max allowed is %i"),
                     filename, len, MAX_MENUFILE ) );
     trap_FS_FCloseFile( f );
     return NULL;
@@ -1092,6 +1096,42 @@ qboolean CG_Asset_Parse( int handle )
       continue;
     }
 
+    // dynFont
+    if( Q_stricmp( token.string, "dynFont" ) == 0 )
+    {
+      int pointSize;
+
+      if( !PC_String_Parse( handle, &tempStr ) || !PC_Int_Parse( handle, &pointSize ) )
+        return qfalse;
+
+      cgDC.loadFace( tempStr, pointSize, tempStr, &cgDC.Assets.dynFont );
+      continue;
+    }
+
+    // smallDynFont
+    if( Q_stricmp( token.string, "smallDynFont" ) == 0 )
+    {
+      int pointSize;
+
+      if( !PC_String_Parse( handle, &tempStr ) || !PC_Int_Parse( handle, &pointSize ) )
+        return qfalse;
+
+      cgDC.loadFace( tempStr, pointSize, tempStr, &cgDC.Assets.smallDynFont );
+      continue;
+    }
+
+    // dynFont
+    if( Q_stricmp( token.string, "bigDynFont" ) == 0 )
+    {
+      int pointSize;
+
+      if( !PC_String_Parse( handle, &tempStr ) || !PC_Int_Parse( handle, &pointSize ) )
+        return qfalse;
+
+      cgDC.loadFace( tempStr, pointSize, tempStr, &cgDC.Assets.bigDynFont );
+      continue;
+    }
+
     // gradientbar
     if( Q_stricmp( token.string, "gradientbar" ) == 0 )
     {
@@ -1223,12 +1263,12 @@ void CG_ParseMenu( const char *menuFile )
       break;
 
     //if ( Q_stricmp( token, "{" ) ) {
-    //  Com_Printf( "Missing { in menu file\n" );
+    //  Com_Printf( _("Missing { in menu file\n") );
     //  break;
     //}
 
     //if ( menuCount == MAX_MENUS ) {
-    //  Com_Printf( "Too many menus!\n" );
+    //  Com_Printf( _("Too many menus!\n") );
     //  break;
     //}
 
@@ -1294,16 +1334,16 @@ void CG_LoadMenus( const char *menuFile )
 
   if( !f )
   {
-    trap_Error( va( S_COLOR_YELLOW "menu file not found: %s, using default\n", menuFile ) );
+    trap_Error( va( _(S_COLOR_YELLOW "menu file not found: %s, using default\n"), menuFile ) );
     len = trap_FS_FOpenFile( "ui/hud.txt", &f, FS_READ );
 
     if( !f )
-      trap_Error( va( S_COLOR_RED "default menu file not found: ui/hud.txt, unable to continue!\n" ) );
+      trap_Error( va( _(S_COLOR_RED "default menu file not found: ui/hud.txt, unable to continue!\n") ) );
   }
 
   if( len >= MAX_MENUDEFFILE )
   {
-    trap_Error( va( S_COLOR_RED "menu file too large: %s is %i, max allowed is %i",
+    trap_Error( va( _(S_COLOR_RED "menu file too large: %s is %i, max allowed is %i"),
                 menuFile, len, MAX_MENUDEFFILE ) );
     trap_FS_FCloseFile( f );
     return;
@@ -1338,12 +1378,12 @@ void CG_LoadMenus( const char *menuFile )
     }
   }
 
-  Com_Printf( "UI menu load time = %d milli seconds\n", trap_Milliseconds( ) - start );
+  Com_Printf( _("UI menu load time = %d milli seconds\n"), trap_Milliseconds( ) - start );
 }
 
 
 
-static qboolean CG_OwnerDrawHandleKey( int ownerDraw, int key )
+static qboolean CG_OwnerDrawHandleKey( int ownerDraw, int key, int state )
 {
   return qfalse;
 }
@@ -1503,7 +1543,7 @@ static const char *CG_FeederItemText( int feederID, int index, int column, qhand
 
       case 2:
         if( cg.intermissionStarted && CG_ClientIsReady( sp->client ) )
-          return "Ready";
+          return _("Ready");
         break;
 
       case 3:
@@ -1636,6 +1676,12 @@ void CG_LoadHudMenu( void )
   cgDC.addRefEntityToScene  = &trap_R_AddRefEntityToScene;
   cgDC.renderScene          = &trap_R_RenderScene;
   cgDC.registerFont         = &trap_R_RegisterFont;
+  cgDC.loadFace             = &LoadFace;
+  cgDC.freeFace             = &FreeFace;
+  cgDC.loadGlyph            = &LoadGlyph;
+  cgDC.freeGlyph            = &FreeGlyph;
+  cgDC.glyph                = &Glyph;
+  cgDC.freeCachedGlyphs     = &FreeCachedGlyphs;
   cgDC.ownerDrawItem        = &CG_OwnerDraw;
   cgDC.getValue             = &CG_GetValue;
   cgDC.ownerDrawVisible     = &CG_OwnerDrawVisible;
@@ -1784,7 +1830,7 @@ void CG_Init( int serverMessageNum, int serverCommandSequence, int clientNum )
   s = CG_ConfigString( CS_GAME_VERSION );
 
   if( strcmp( s, GAME_VERSION ) )
-    CG_Error( "Client/Server game mismatch: %s/%s", GAME_VERSION, s );
+    CG_Error( _("Client/Server game mismatch: %s/%s"), GAME_VERSION, s );
 
   s = CG_ConfigString( CS_LEVEL_START_TIME );
   cgs.levelStartTime = atoi( s );
@@ -1847,8 +1893,9 @@ Called before every level change or subsystem restart
 */
 void CG_Shutdown( void )
 {
-  // some mods may need to do cleanup work here,
-  // like closing files or archiving session data
+  FreeFace( &cgDC.Assets.dynFont );
+
+  UIS_Shutdown( );
 }
 
 /*
@@ -1879,7 +1926,7 @@ static char *CG_VoIPString( void )
                          "%s%d", ( slen > 0 ) ? "," : "", i );
       if( slen + nlen + 1 >= sizeof( voipString ) )
       {
-        CG_Printf( S_COLOR_YELLOW "WARNING: voipString overflowed\n" );
+        CG_Printf( _(S_COLOR_YELLOW "WARNING: voipString overflowed\n") );
         break;
       }
 
@@ -1902,3 +1949,156 @@ static char *CG_VoIPString( void )
   return voipString;
 }
 
+void LoadFace( const char *fileName, int pointSize, const char *name, face_t *face )
+{
+  static int engineState = 0;
+
+  if( !( engineState & 0x01 ) )
+  {
+    char t[2];
+
+    engineState |= 0x01;
+
+    trap_Cvar_VariableStringBuffer( "\\IS_GETTEXT_SUPPORTED", t, 2 );
+
+    if( t[0] == '1' )
+      engineState |= 0x02;
+  }
+
+  if( engineState & 0x02 )
+    trap_R_LoadFace( fileName, pointSize, name, face );
+}
+
+void FreeFace( face_t *face )
+{
+  static int engineState = 0;
+
+  if( !( engineState & 0x01 ) )
+  {
+    char t[2];
+
+    engineState |= 0x01;
+
+    trap_Cvar_VariableStringBuffer( "\\IS_GETTEXT_SUPPORTED", t, 2 );
+
+    if( t[0] == '1' )
+      engineState |= 0x02;
+  }
+
+  if( engineState & 0x02 )
+    trap_R_FreeFace( face );
+}
+
+void LoadGlyph( face_t *face, const char *str, int img, glyphInfo_t *glyphInfo )
+{
+  static int engineState = 0;
+
+  if( !( engineState & 0x01 ) )
+  {
+    char t[2];
+
+    engineState |= 0x01;
+
+    trap_Cvar_VariableStringBuffer( "\\IS_GETTEXT_SUPPORTED", t, 2 );
+
+    if( t[0] == '1' )
+      engineState |= 0x02;
+  }
+
+  if( engineState & 0x02 )
+    trap_R_LoadGlyph( face, str, img, glyphInfo );
+}
+
+void FreeGlyph( face_t *face, int img, glyphInfo_t *glyphInfo )
+{
+  static int engineState = 0;
+
+  if( !( engineState & 0x01 ) )
+  {
+    char t[2];
+
+    engineState |= 0x01;
+
+    trap_Cvar_VariableStringBuffer( "\\IS_GETTEXT_SUPPORTED", t, 2 );
+
+    if( t[0] == '1' )
+      engineState |= 0x02;
+  }
+
+  if( engineState & 0x02 )
+    trap_R_FreeGlyph( face, img, glyphInfo );
+}
+
+void Glyph( fontInfo_t *font, face_t *face, const char *str, glyphInfo_t *glyph )
+{
+  static int engineState = 0;
+
+  if( !( engineState & 0x01 ) )
+  {
+    char t[2];
+
+    engineState |= 0x01;
+
+    trap_Cvar_VariableStringBuffer( "\\IS_GETTEXT_SUPPORTED", t, 2 );
+
+    if( t[0] == '1' )
+      engineState |= 0x02;
+  }
+
+  if( engineState & 0x02 )
+    trap_R_Glyph( font, face, str, glyph );
+}
+
+void FreeCachedGlyphs( face_t *face )
+{
+  static int engineState = 0;
+
+  if( !( engineState & 0x01 ) )
+  {
+    char t[2];
+
+    engineState |= 0x01;
+
+    trap_Cvar_VariableStringBuffer( "\\IS_GETTEXT_SUPPORTED", t, 2 );
+
+    if( t[0] == '1' )
+      engineState |= 0x02;
+  }
+
+  if( engineState & 0x02 )
+    trap_R_FreeCachedGlyphs( face );
+}
+
+void Gettext( char *buffer, const char *msgid, int bufferLength )
+{
+  static int engineState = 0;
+
+  if( !( engineState & 0x01 ) )
+  {
+    char t[2];
+
+    engineState |= 0x01;
+
+    trap_Cvar_VariableStringBuffer( "\\IS_GETTEXT_SUPPORTED", t, 2 );
+
+    if( t[0] == '1' )
+      engineState |= 0x02;
+  }
+
+  if( !( engineState & 0x02 ) )
+    strncpy( buffer, msgid, bufferLength );
+  else
+    trap_Gettext( buffer, msgid, bufferLength );
+}
+
+char *gettext ( const char *msgid )
+{
+  static char string[8][32000];
+  static int  index = 0;
+  char        *buf = string[index++ & 7];
+
+  Gettext( buf, msgid, sizeof( *string ) );
+
+  return buf;
+}
+
diff --git a/src/cgame/cg_marks.c b/src/cgame/cg_marks.c
index 6e1891f..8bbbf2e 100644
--- a/src/cgame/cg_marks.c
+++ b/src/cgame/cg_marks.c
@@ -70,7 +70,7 @@ CG_FreeMarkPoly
 void CG_FreeMarkPoly( markPoly_t *le )
 {
   if( !le->prevMark )
-    CG_Error( "CG_FreeLocalEntity: not active" );
+    CG_Error( _("CG_FreeLocalEntity: not active") );
 
   // remove from the doubly linked active list
   le->prevMark->nextMark = le->nextMark;
@@ -150,7 +150,7 @@ void CG_ImpactMark( qhandle_t markShader, const vec3_t origin, const vec3_t dir,
     return;
 
   if( radius <= 0 )
-    CG_Error( "CG_ImpactMark called with <= 0 radius" );
+    CG_Error( _("CG_ImpactMark called with <= 0 radius") );
 
   //if ( markTotal >= MAX_MARK_POLYS ) {
   //  return;
diff --git a/src/cgame/cg_particles.c b/src/cgame/cg_particles.c
index 5a302d5..82888ac 100644
--- a/src/cgame/cg_particles.c
+++ b/src/cgame/cg_particles.c
@@ -250,8 +250,8 @@ static particle_t *CG_SpawnNewParticle( baseParticle_t *bp, particleEjector_t *p
         case PMT_NORMAL:
           if( !ps->normalValid )
           {
-            CG_Printf( S_COLOR_RED "ERROR: a particle with velocityType "
-                "normal has no normal\n" );
+            CG_Printf( _(S_COLOR_RED "ERROR: a particle with velocityType "
+                "normal has no normal\n") );
             return NULL;
           }
 
@@ -424,7 +424,7 @@ static particleEjector_t *CG_SpawnNewParticleEjector( baseParticleEjector_t *bpe
       pe->valid = qtrue;
 
       if( cg_debugParticles.integer >= 1 )
-        CG_Printf( "PE %s created\n", ps->class->name );
+        CG_Printf( _("PE %s created\n"), ps->class->name );
 
       break;
     }
@@ -449,7 +449,7 @@ particleSystem_t *CG_SpawnNewParticleSystem( qhandle_t psHandle )
 
   if( !bps->registered )
   {
-    CG_Printf( S_COLOR_RED "ERROR: a particle system has not been registered yet\n" );
+    CG_Printf( _(S_COLOR_RED "ERROR: a particle system has not been registered yet\n") );
     return NULL;
   }
 
@@ -471,7 +471,7 @@ particleSystem_t *CG_SpawnNewParticleSystem( qhandle_t psHandle )
         CG_SpawnNewParticleEjector( bps->ejectors[ j ], ps );
 
       if( cg_debugParticles.integer >= 1 )
-        CG_Printf( "PS %s created\n", bps->name );
+        CG_Printf( _("PS %s created\n"), bps->name );
 
       break;
     }
@@ -545,7 +545,7 @@ qhandle_t CG_RegisterParticleSystem( char *name )
       }
 
       if( cg_debugParticles.integer >= 1 )
-        CG_Printf( "Registered particle system %s\n", name );
+        CG_Printf( _("Registered particle system %s\n"), name );
 
       bps->registered = qtrue;
 
@@ -554,7 +554,7 @@ qhandle_t CG_RegisterParticleSystem( char *name )
     }
   }
 
-  CG_Printf( S_COLOR_RED "ERROR: failed to register particle system %s\n", name );
+  CG_Printf( _(S_COLOR_RED "ERROR: failed to register particle system %s\n"), name );
   return 0;
 }
 
@@ -731,8 +731,8 @@ static qboolean CG_ParseParticle( baseParticle_t *bp, char **text_p )
     {
       if( bp->numModels > 0 )
       {
-        CG_Printf( S_COLOR_RED "ERROR: 'shader' not allowed in "
-            "conjunction with 'model'\n", token );
+        CG_Printf( _(S_COLOR_RED "ERROR: 'shader' not allowed in "
+            "conjunction with 'model'\n"), token );
         break;
       }
 
@@ -761,8 +761,8 @@ static qboolean CG_ParseParticle( baseParticle_t *bp, char **text_p )
     {
       if( bp->numFrames > 0 )
       {
-        CG_Printf( S_COLOR_RED "ERROR: 'model' not allowed in "
-            "conjunction with 'shader'\n", token );
+        CG_Printf( _(S_COLOR_RED "ERROR: 'model' not allowed in "
+            "conjunction with 'shader'\n"), token );
         break;
       }
 
@@ -1123,7 +1123,7 @@ static qboolean CG_ParseParticle( baseParticle_t *bp, char **text_p )
         token = COM_Parse( text_p );
         if( Q_stricmp( token, "}" ) )
         {
-          CG_Printf( S_COLOR_RED "ERROR: missing '}'\n" );
+          CG_Printf( _(S_COLOR_RED "ERROR: missing '}'\n") );
           break;
         }
       }
@@ -1245,7 +1245,7 @@ static qboolean CG_ParseParticle( baseParticle_t *bp, char **text_p )
         token = COM_Parse( text_p );
         if( Q_stricmp( token, "}" ) )
         {
-          CG_Printf( S_COLOR_RED "ERROR: missing '}'\n" );
+          CG_Printf( _(S_COLOR_RED "ERROR: missing '}'\n") );
           break;
         }
 
@@ -1267,19 +1267,19 @@ static qboolean CG_ParseParticle( baseParticle_t *bp, char **text_p )
           token = COM_Parse( text_p );
           if( Q_stricmp( token, "}" ) )
           {
-            CG_Printf( S_COLOR_RED "ERROR: missing '}'\n" );
+            CG_Printf( _(S_COLOR_RED "ERROR: missing '}'\n") );
             break;
           }
         }
         else
         {
-          CG_Printf( S_COLOR_RED "ERROR: missing '{'\n" );
+          CG_Printf( _(S_COLOR_RED "ERROR: missing '{'\n") );
           break;
         }
       }
       else
       {
-        CG_Printf( S_COLOR_RED "ERROR: missing '{'\n" );
+        CG_Printf( _(S_COLOR_RED "ERROR: missing '{'\n") );
         break;
       }
 
@@ -1381,7 +1381,7 @@ static qboolean CG_ParseParticle( baseParticle_t *bp, char **text_p )
       return qtrue; //reached the end of this particle
     else
     {
-      CG_Printf( S_COLOR_RED "ERROR: unknown token '%s' in particle\n", token );
+      CG_Printf( _(S_COLOR_RED "ERROR: unknown token '%s' in particle\n"), token );
       return qfalse;
     }
   }
@@ -1431,18 +1431,18 @@ static qboolean CG_ParseParticleEjector( baseParticleEjector_t *bpe, char **text
 
       if( !CG_ParseParticle( &baseParticles[ numBaseParticles ], text_p ) )
       {
-        CG_Printf( S_COLOR_RED "ERROR: failed to parse particle\n" );
+        CG_Printf( _(S_COLOR_RED "ERROR: failed to parse particle\n") );
         return qfalse;
       }
 
       if( bpe->numParticles == MAX_PARTICLES_PER_EJECTOR )
       {
-        CG_Printf( S_COLOR_RED "ERROR: ejector has > %d particles\n", MAX_PARTICLES_PER_EJECTOR );
+        CG_Printf( _(S_COLOR_RED "ERROR: ejector has > %d particles\n"), MAX_PARTICLES_PER_EJECTOR );
         return qfalse;
       }
       else if( numBaseParticles == MAX_BASEPARTICLES )
       {
-        CG_Printf( S_COLOR_RED "ERROR: maximum number of particles (%d) reached\n", MAX_BASEPARTICLES );
+        CG_Printf( _(S_COLOR_RED "ERROR: maximum number of particles (%d) reached\n"), MAX_BASEPARTICLES );
         return qfalse;
       }
       else
@@ -1519,7 +1519,7 @@ static qboolean CG_ParseParticleEjector( baseParticleEjector_t *bpe, char **text
       return qtrue; //reached the end of this particle ejector
     else
     {
-      CG_Printf( S_COLOR_RED "ERROR: unknown token '%s' in particle ejector\n", token );
+      CG_Printf( _(S_COLOR_RED "ERROR: unknown token '%s' in particle ejector\n"), token );
       return qfalse;
     }
   }
@@ -1555,7 +1555,7 @@ static qboolean CG_ParseParticleSystem( baseParticleSystem_t *bps, char **text_p
     {
       if( !CG_ParseParticleEjector( &baseParticleEjectors[ numBaseParticleEjectors ], text_p ) )
       {
-        CG_Printf( S_COLOR_RED "ERROR: failed to parse particle ejector\n" );
+        CG_Printf( _(S_COLOR_RED "ERROR: failed to parse particle ejector\n") );
         return qfalse;
       }
 
@@ -1565,18 +1565,18 @@ static qboolean CG_ParseParticleSystem( baseParticleSystem_t *bps, char **text_p
       if( bpe->totalParticles == PARTICLES_INFINITE &&
           ( bpe->eject.initial == 0.0f || bpe->eject.final == 0.0f ) )
       {
-        CG_Printf( S_COLOR_RED "ERROR: ejector with 'count infinite' potentially has zero period\n" );
+        CG_Printf( _(S_COLOR_RED "ERROR: ejector with 'count infinite' potentially has zero period\n") );
         return qfalse;
       }
 
       if( bps->numEjectors == MAX_EJECTORS_PER_SYSTEM )
       {
-        CG_Printf( S_COLOR_RED "ERROR: particle system has > %d ejectors\n", MAX_EJECTORS_PER_SYSTEM );
+        CG_Printf( _(S_COLOR_RED "ERROR: particle system has > %d ejectors\n"), MAX_EJECTORS_PER_SYSTEM );
         return qfalse;
       }
       else if( numBaseParticleEjectors == MAX_BASEPARTICLE_EJECTORS )
       {
-        CG_Printf( S_COLOR_RED "ERROR: maximum number of particle ejectors (%d) reached\n",
+        CG_Printf( _(S_COLOR_RED "ERROR: maximum number of particle ejectors (%d) reached\n"),
             MAX_BASEPARTICLE_EJECTORS );
         return qfalse;
       }
@@ -1596,13 +1596,13 @@ static qboolean CG_ParseParticleSystem( baseParticleSystem_t *bps, char **text_p
     else if( !Q_stricmp( token, "}" ) )
     {
       if( cg_debugParticles.integer >= 1 )
-        CG_Printf( "Parsed particle system %s\n", name );
+        CG_Printf( _("Parsed particle system %s\n"), name );
 
       return qtrue; //reached the end of this particle system
     }
     else
     {
-      CG_Printf( S_COLOR_RED "ERROR: unknown token '%s' in particle system %s\n", token, bps->name );
+      CG_Printf( _(S_COLOR_RED "ERROR: unknown token '%s' in particle system %s\n"), token, bps->name );
       return qfalse;
     }
   }
@@ -1636,7 +1636,7 @@ static qboolean CG_ParseParticleFile( const char *fileName )
   if( len == 0 || len >= sizeof( text ) - 1 )
   {
     trap_FS_FCloseFile( f );
-    CG_Printf( S_COLOR_RED "ERROR: particle file %s is %s\n", fileName,
+    CG_Printf( _(S_COLOR_RED "ERROR: particle file %s is %s\n"), fileName,
       len == 0 ? "empty" : "too long" );
     return qfalse;
   }
@@ -1665,7 +1665,7 @@ static qboolean CG_ParseParticleFile( const char *fileName )
         {
           if( !Q_stricmp( baseParticleSystems[ i ].name, psName ) )
           {
-            CG_Printf( S_COLOR_RED "ERROR: a particle system is already named %s\n", psName );
+            CG_Printf( _(S_COLOR_RED "ERROR: a particle system is already named %s\n"), psName );
             return qfalse;
           }
         }
@@ -1674,7 +1674,7 @@ static qboolean CG_ParseParticleFile( const char *fileName )
 
         if( !CG_ParseParticleSystem( &baseParticleSystems[ numBaseParticleSystems ], &text_p, psName ) )
         {
-          CG_Printf( S_COLOR_RED "ERROR: %s: failed to parse particle system %s\n", fileName, psName );
+          CG_Printf( _(S_COLOR_RED "ERROR: %s: failed to parse particle system %s\n"), fileName, psName );
           return qfalse;
         }
 
@@ -1683,7 +1683,7 @@ static qboolean CG_ParseParticleFile( const char *fileName )
 
         if( numBaseParticleSystems == MAX_BASEPARTICLE_SYSTEMS )
         {
-          CG_Printf( S_COLOR_RED "ERROR: maximum number of particle systems (%d) reached\n",
+          CG_Printf( _(S_COLOR_RED "ERROR: maximum number of particle systems (%d) reached\n"),
               MAX_BASEPARTICLE_SYSTEMS );
           return qfalse;
         }
@@ -1694,7 +1694,7 @@ static qboolean CG_ParseParticleFile( const char *fileName )
       }
       else
       {
-        CG_Printf( S_COLOR_RED "ERROR: unamed particle system\n" );
+        CG_Printf( _(S_COLOR_RED "ERROR: unamed particle system\n") );
         return qfalse;
       }
     }
@@ -1706,7 +1706,7 @@ static qboolean CG_ParseParticleFile( const char *fileName )
     }
     else
     {
-      CG_Printf( S_COLOR_RED "ERROR: particle system already named\n" );
+      CG_Printf( _(S_COLOR_RED "ERROR: particle system already named\n") );
       return qfalse;
     }
   }
@@ -1763,7 +1763,7 @@ void CG_LoadParticleSystems( void )
     fileLen = strlen( filePtr );
     strcpy( fileName, "scripts/" );
     strcat( fileName, filePtr );
-    CG_Printf( "...loading '%s'\n", fileName );
+    CG_Printf( _("...loading '%s'\n"), fileName );
     CG_ParseParticleFile( fileName );
   }
 
@@ -1792,7 +1792,7 @@ void CG_LoadParticleSystems( void )
       if( j == numBaseParticleSystems )
       {
         //couldn't find named particle system
-        CG_Printf( S_COLOR_YELLOW "WARNING: failed to find child %s\n", bp->childSystemName );
+        CG_Printf( _(S_COLOR_YELLOW "WARNING: failed to find child %s\n"), bp->childSystemName );
         bp->childSystemName[ 0 ] = '\0';
       }
     }
@@ -1817,7 +1817,7 @@ void CG_LoadParticleSystems( void )
       if( j == numBaseParticleSystems )
       {
         //couldn't find named particle system
-        CG_Printf( S_COLOR_YELLOW "WARNING: failed to find onDeath system %s\n", bp->onDeathSystemName );
+        CG_Printf( _(S_COLOR_YELLOW "WARNING: failed to find onDeath system %s\n"), bp->onDeathSystemName );
         bp->onDeathSystemName[ 0 ] = '\0';
       }
     }
@@ -1833,7 +1833,7 @@ void CG_SetParticleSystemNormal( particleSystem_t *ps, vec3_t normal )
 {
   if( ps == NULL || !ps->valid )
   {
-    CG_Printf( S_COLOR_YELLOW "WARNING: tried to modify a NULL particle system\n" );
+    CG_Printf( _(S_COLOR_YELLOW "WARNING: tried to modify a NULL particle system\n") );
     return;
   }
 
@@ -1863,12 +1863,12 @@ void CG_DestroyParticleSystem( particleSystem_t **ps )
 
   if( *ps == NULL || !(*ps)->valid )
   {
-    CG_Printf( S_COLOR_YELLOW "WARNING: tried to destroy a NULL particle system\n" );
+    CG_Printf( _(S_COLOR_YELLOW "WARNING: tried to destroy a NULL particle system\n") );
     return;
   }
 
   if( cg_debugParticles.integer >= 1 )
-    CG_Printf( "PS destroyed\n" );
+    CG_Printf( _("PS destroyed\n") );
 
   for( i = 0; i < MAX_PARTICLE_EJECTORS; i++ )
   {
@@ -1895,13 +1895,13 @@ qboolean CG_IsParticleSystemInfinite( particleSystem_t *ps )
 
   if( ps == NULL )
   {
-    CG_Printf( S_COLOR_YELLOW "WARNING: tried to test a NULL particle system\n" );
+    CG_Printf( _(S_COLOR_YELLOW "WARNING: tried to test a NULL particle system\n") );
     return qfalse;
   }
 
   if( !ps->valid )
   {
-    CG_Printf( S_COLOR_YELLOW "WARNING: tried to test an invalid particle system\n" );
+    CG_Printf( _(S_COLOR_YELLOW "WARNING: tried to test an invalid particle system\n") );
     return qfalse;
   }
 
@@ -1987,7 +1987,7 @@ static void CG_GarbageCollectParticleSystems( void )
     }
 
     if( cg_debugParticles.integer >= 1 && !ps->valid )
-      CG_Printf( "PS %s garbage collected\n", ps->class->name );
+      CG_Printf( _("PS %s garbage collected\n"), ps->class->name );
   }
 }
 
diff --git a/src/cgame/cg_players.c b/src/cgame/cg_players.c
index c23d569..6ae2e72 100644
--- a/src/cgame/cg_players.c
+++ b/src/cgame/cg_players.c
@@ -69,7 +69,7 @@ sfxHandle_t CG_CustomSound( int clientNum, const char *soundName )
       return ci->sounds[ i ];
   }
 
-  CG_Error( "Unknown custom sound: %s", soundName );
+  CG_Error( _("Unknown custom sound: %s"), soundName );
   return 0;
 }
 
@@ -112,7 +112,7 @@ static qboolean CG_ParseAnimationFile( const char *filename, clientInfo_t *ci )
 
   if( len == 0 || len >= sizeof( text ) - 1 )
   {
-    CG_Printf( "File %s is %s\n", filename, len == 0 ? "empty" : "too long" );
+    CG_Printf( _("File %s is %s\n"), filename, len == 0 ? _("empty") : _("too long") );
     trap_FS_FCloseFile( f );
     return qfalse;
   }
@@ -156,7 +156,7 @@ static qboolean CG_ParseAnimationFile( const char *filename, clientInfo_t *ci )
       else if( !Q_stricmp( token, "custom" ) )
         ci->footsteps = FOOTSTEP_CUSTOM;
       else
-        CG_Printf( "Bad footsteps parm in %s: %s\n", filename, token );
+        CG_Printf( _("Bad footsteps parm in %s: %s\n"), filename, token );
 
       continue;
     }
@@ -212,7 +212,7 @@ static qboolean CG_ParseAnimationFile( const char *filename, clientInfo_t *ci )
       break;
     }
 
-    Com_Printf( "unknown token '%s' is %s\n", token, filename );
+    Com_Printf( _("unknown token '%s' is %s\n"), token, filename );
   }
 
   if( !ci->nonsegmented )
@@ -285,7 +285,7 @@ static qboolean CG_ParseAnimationFile( const char *filename, clientInfo_t *ci )
 
     if( i != MAX_PLAYER_ANIMATIONS )
     {
-      CG_Printf( "Error parsing animation file: %s", filename );
+      CG_Printf( _("Error parsing animation file: %s"), filename );
       return qfalse;
     }
     // crouch backward animation
@@ -365,7 +365,7 @@ static qboolean CG_ParseAnimationFile( const char *filename, clientInfo_t *ci )
 
     if( i != MAX_NONSEG_PLAYER_ANIMATIONS )
     {
-      CG_Printf( "Error parsing animation file: %s", filename );
+      CG_Printf( _("Error parsing animation file: %s"), filename );
       return qfalse;
     }
 
@@ -391,17 +391,17 @@ static qboolean CG_RegisterClientSkin( clientInfo_t *ci, const char *modelName,
     Com_sprintf( filename, sizeof( filename ), "models/players/%s/lower_%s.skin", modelName, skinName );
     ci->legsSkin = trap_R_RegisterSkin( filename );
     if( !ci->legsSkin )
-      Com_Printf( "Leg skin load failure: %s\n", filename );
+      Com_Printf( _("Leg skin load failure: %s\n"), filename );
 
     Com_sprintf( filename, sizeof( filename ), "models/players/%s/upper_%s.skin", modelName, skinName );
     ci->torsoSkin = trap_R_RegisterSkin( filename );
     if( !ci->torsoSkin )
-      Com_Printf( "Torso skin load failure: %s\n", filename );
+      Com_Printf( _("Torso skin load failure: %s\n"), filename );
 
     Com_sprintf( filename, sizeof( filename ), "models/players/%s/head_%s.skin", modelName, skinName );
     ci->headSkin = trap_R_RegisterSkin( filename );
     if( !ci->headSkin )
-      Com_Printf( "Head skin load failure: %s\n", filename );
+      Com_Printf( _("Head skin load failure: %s\n"), filename );
 
     if( !ci->legsSkin || !ci->torsoSkin || !ci->headSkin )
       return qfalse;
@@ -411,7 +411,7 @@ static qboolean CG_RegisterClientSkin( clientInfo_t *ci, const char *modelName,
     Com_sprintf( filename, sizeof( filename ), "models/players/%s/nonseg_%s.skin", modelName, skinName );
     ci->nonSegSkin = trap_R_RegisterSkin( filename );
     if( !ci->nonSegSkin )
-      Com_Printf( "Non-segmented skin load failure: %s\n", filename );
+      Com_Printf( _("Non-segmented skin load failure: %s\n"), filename );
 
     if( !ci->nonSegSkin )
       return qfalse;
@@ -434,7 +434,7 @@ static qboolean CG_RegisterClientModelname( clientInfo_t *ci, const char *modelN
   Com_sprintf( filename, sizeof( filename ), "models/players/%s/animation.cfg", modelName );
   if( !CG_ParseAnimationFile( filename, ci ) )
   {
-    Com_Printf( "Failed to load animation file %s\n", filename );
+    Com_Printf( _("Failed to load animation file %s\n"), filename );
     return qfalse;
   }
 
@@ -446,7 +446,7 @@ static qboolean CG_RegisterClientModelname( clientInfo_t *ci, const char *modelN
     ci->legsModel = trap_R_RegisterModel( filename );
     if( !ci->legsModel )
     {
-      Com_Printf( "Failed to load model file %s\n", filename );
+      Com_Printf( _("Failed to load model file %s\n"), filename );
       return qfalse;
     }
 
@@ -454,7 +454,7 @@ static qboolean CG_RegisterClientModelname( clientInfo_t *ci, const char *modelN
     ci->torsoModel = trap_R_RegisterModel( filename );
     if( !ci->torsoModel )
     {
-      Com_Printf( "Failed to load model file %s\n", filename );
+      Com_Printf( _("Failed to load model file %s\n"), filename );
       return qfalse;
     }
 
@@ -462,7 +462,7 @@ static qboolean CG_RegisterClientModelname( clientInfo_t *ci, const char *modelN
     ci->headModel = trap_R_RegisterModel( filename );
     if( !ci->headModel )
     {
-      Com_Printf( "Failed to load model file %s\n", filename );
+      Com_Printf( _("Failed to load model file %s\n"), filename );
       return qfalse;
     }
   }
@@ -472,7 +472,7 @@ static qboolean CG_RegisterClientModelname( clientInfo_t *ci, const char *modelN
     ci->nonSegModel = trap_R_RegisterModel( filename );
     if( !ci->nonSegModel )
     {
-      Com_Printf( "Failed to load model file %s\n", filename );
+      Com_Printf( _("Failed to load model file %s\n"), filename );
       return qfalse;
     }
   }
@@ -480,7 +480,7 @@ static qboolean CG_RegisterClientModelname( clientInfo_t *ci, const char *modelN
   // if any skins failed to load, return failure
   if( !CG_RegisterClientSkin( ci, modelName, skinName ) )
   {
-    Com_Printf( "Failed to load skin file: %s : %s\n", modelName, skinName );
+    Com_Printf( _("Failed to load skin file: %s : %s\n"), modelName, skinName );
     return qfalse;
   }
 
@@ -503,7 +503,7 @@ static void CG_LoadClientInfo( clientInfo_t *ci )
   int         clientNum;
 
   if( !CG_RegisterClientModelname( ci, ci->modelName, ci->skinName ) )
-    CG_Error( "CG_RegisterClientModelname( %s, %s ) failed", ci->modelName, ci->skinName );
+    CG_Error( _("CG_RegisterClientModelname( %s, %s ) failed"), ci->modelName, ci->skinName );
 
   // sounds
   dir = ci->modelName;
@@ -705,18 +705,18 @@ static void CG_StatusMessages( clientInfo_t *new, clientInfo_t *old )
     return;
 
   if( strcmp( new->name, old->name ) )
-    CG_Printf( "%s" S_COLOR_WHITE " renamed to %s\n", old->name, new->name );
+    CG_Printf( _("%s" S_COLOR_WHITE " renamed to %s\n"), old->name, new->name );
 
   if( old->team != new->team )
   {
     if( new->team == TEAM_NONE )
-      CG_Printf( "%s" S_COLOR_WHITE " left the %ss\n", new->name,
-        BG_TeamName( old->team ) );
+      CG_Printf( _("%s" S_COLOR_WHITE " left the %ss\n"), new->name,
+        _(BG_TeamName( old->team )) );
     else if( old->team == TEAM_NONE )
-      CG_Printf( "%s" S_COLOR_WHITE " joined the %ss\n", new->name,
-        BG_TeamName( new->team ) );
+      CG_Printf( _("%s" S_COLOR_WHITE " joined the %ss\n"), new->name,
+        _(BG_TeamName( new->team )) );
     else
-      CG_Printf( "%s" S_COLOR_WHITE " left the %ss and joined the %ss\n",
+      CG_Printf( _("%s" S_COLOR_WHITE " left the %ss and joined the %ss\n"),
         new->name, BG_TeamName( old->team ), BG_TeamName( new->team ) );
   }
 }
@@ -842,7 +842,7 @@ static void CG_SetLerpFrameAnimation( clientInfo_t *ci, lerpFrame_t *lf, int new
   newAnimation &= ~ANIM_TOGGLEBIT;
 
   if( newAnimation < 0 || newAnimation >= MAX_PLAYER_TOTALANIMATIONS )
-    CG_Error( "Bad animation number: %i", newAnimation );
+    CG_Error( _("Bad animation number: %i"), newAnimation );
 
   anim = &ci->animations[ newAnimation ];
 
@@ -850,7 +850,7 @@ static void CG_SetLerpFrameAnimation( clientInfo_t *ci, lerpFrame_t *lf, int new
   lf->animationTime = lf->frameTime + anim->initialLerp;
 
   if( cg_debugAnim.integer )
-    CG_Printf( "Anim: %i\n", newAnimation );
+    CG_Printf( _("Anim: %i\n"), newAnimation );
 }
 
 /*
@@ -1110,7 +1110,7 @@ static void CG_PlayerAngles( centity_t *cent, vec3_t srcAngles,
     // did use angles2.. now uses time2.. looks a bit funny but time2 isn't used othwise
     dir = cent->currentState.time2;
     if( dir < 0 || dir > 7 )
-      CG_Error( "Bad player movement angle" );
+      CG_Error( _("Bad player movement angle") );
   }
 
   legsAngles[ YAW ] = headAngles[ YAW ] + movementOffsets[ dir ];
@@ -1357,7 +1357,7 @@ static void CG_PlayerNonSegAngles( centity_t *cent, vec3_t srcAngles, vec3_t non
     // did use angles2.. now uses time2.. looks a bit funny but time2 isn't used othwise
     dir = cent->currentState.time2;
     if( dir < 0 || dir > 7 )
-      CG_Error( "Bad player movement angle" );
+      CG_Error( _("Bad player movement angle") );
   }
 
   // torso
@@ -1892,7 +1892,7 @@ void CG_Player( centity_t *cent )
   // multiple corpses on the level using the same clientinfo
   clientNum = es->clientNum;
   if( clientNum < 0 || clientNum >= MAX_CLIENTS )
-    CG_Error( "Bad clientNum on player entity" );
+    CG_Error( _("Bad clientNum on player entity") );
 
   ci = &cgs.clientinfo[ clientNum ];
 
@@ -2166,7 +2166,7 @@ void CG_Corpse( centity_t *cent )
   corpseNum = CG_GetCorpseNum( es->clientNum );
 
   if( corpseNum < 0 || corpseNum >= MAX_CLIENTS )
-    CG_Error( "Bad corpseNum on corpse entity: %d", corpseNum );
+    CG_Error( _("Bad corpseNum on corpse entity: %d"), corpseNum );
 
   ci = &cgs.corpseinfo[ corpseNum ];
 
diff --git a/src/cgame/cg_playerstate.c b/src/cgame/cg_playerstate.c
index 8a8e739..49ab98b 100644
--- a/src/cgame/cg_playerstate.c
+++ b/src/cgame/cg_playerstate.c
@@ -232,7 +232,7 @@ void CG_CheckChangedPredictableEvents( playerState_t *ps )
         cg.predictableEvents[ i & ( MAX_PREDICTED_EVENTS - 1 ) ] = event;
 
         if( cg_showmiss.integer )
-          CG_Printf( "WARNING: changed predicted event\n" );
+          CG_Printf( _("WARNING: changed predicted event\n") );
       }
     }
   }
diff --git a/src/cgame/cg_public.h b/src/cgame/cg_public.h
index 9d197ff..ec7e16b 100644
--- a/src/cgame/cg_public.h
+++ b/src/cgame/cg_public.h
@@ -196,7 +196,15 @@ typedef enum
 
   CG_TESTPRINTINT,
   CG_TESTPRINTFLOAT,
-  CG_ACOS
+  CG_ACOS,
+
+  CG_GETTEXT = 300,
+  CG_R_LOADFACE,
+  CG_R_FREEFACE,
+  CG_R_LOADGLYPH,
+  CG_R_FREEGLYPH,
+  CG_R_GLYPH,
+  CG_R_FREECACHEDGLYPHS
 } cgameImport_t;
 
 
@@ -242,7 +250,7 @@ typedef enum
   // int (*CG_LastAttacker)( void );
 
   CG_KEY_EVENT,
-  // void  (*CG_KeyEvent)( int key, qboolean down );
+  // void  (*CG_KeyEvent)( int key, qboolean down, qboolean isChar );
 
   CG_MOUSE_EVENT,
   // void  (*CG_MouseEvent)( int dx, int dy );
diff --git a/src/cgame/cg_servercmds.c b/src/cgame/cg_servercmds.c
index b5a85a5..4859d71 100644
--- a/src/cgame/cg_servercmds.c
+++ b/src/cgame/cg_servercmds.c
@@ -91,7 +91,7 @@ static void CG_ParseTeamInfo( void )
     client = atoi( CG_Argv( i * 5 + 1 ) );
     if( client < 0 || client >= MAX_CLIENTS )
     {
-      CG_Printf( "[skipnotify]CG_ParseTeamInfo: bad client number: %d\n", client );
+      CG_Printf( _("[skipnotify]CG_ParseTeamInfo: bad client number: %d\n"), client );
       return;
     }
 
@@ -235,7 +235,7 @@ static void CG_AnnounceAlienStageTransistion( stage_t from, stage_t to )
     return;
 
   trap_S_StartLocalSound( cgs.media.alienStageTransition, CHAN_ANNOUNCER );
-  CG_CenterPrint( "We have evolved!", 200, GIANTCHAR_WIDTH * 4 );
+  CG_CenterPrint( _("We have evolved!"), 200, GIANTCHAR_WIDTH * 4 );
 }
 
 /*
@@ -249,7 +249,7 @@ static void CG_AnnounceHumanStageTransistion( stage_t from, stage_t to )
     return;
 
   trap_S_StartLocalSound( cgs.media.humanStageTransition, CHAN_ANNOUNCER );
-  CG_CenterPrint( "Reinforcements have arrived!", 200, GIANTCHAR_WIDTH * 4 );
+  CG_CenterPrint( _("Reinforcements have arrived!"), 200, GIANTCHAR_WIDTH * 4 );
 }
 
 /*
@@ -473,63 +473,63 @@ void CG_Menu( int menu, int arg )
       break;
 
     case MN_H_UNKNOWNITEM:
-      shortMsg  = "Unknown item";
+      shortMsg  = _("Unknown item");
       type      = DT_ARMOURYEVOLVE;
       break;
 
     case MN_A_TEAMFULL:
-      longMsg   = "The alien team has too many players. Please wait until slots "
-                  "become available or join the human team.";
-      shortMsg  = "The alien team has too many players";
+      longMsg   = _("The alien team has too many players. Please wait until slots "
+                  "become available or join the human team.");
+      shortMsg  = _("The alien team has too many players");
       type      = DT_COMMAND;
       break;
 
     case MN_H_TEAMFULL:
-      longMsg   = "The human team has too many players. Please wait until slots "
-                  "become available or join the alien team.";
-      shortMsg  = "The human team has too many players";
+      longMsg   = _("The human team has too many players. Please wait until slots "
+                  "become available or join the alien team.");
+      shortMsg  = _("The human team has too many players");
       type      = DT_COMMAND;
       break;
 
     case MN_A_TEAMLOCKED:
-      longMsg   = "The alien team is locked. You cannot join the aliens "
-                  "at this time.";
-      shortMsg  = "The alien team is locked";
+      longMsg   = _("The alien team is locked. You cannot join the aliens "
+                  "at this time.");
+      shortMsg  = _("The alien team is locked");
       type      = DT_COMMAND;
       break;
 
     case MN_H_TEAMLOCKED:
-      longMsg   = "The human team is locked. You cannot join the humans "
-                  "at this time.";
-      shortMsg  = "The human team is locked";
+      longMsg   = _("The human team is locked. You cannot join the humans "
+                  "at this time.");
+      shortMsg  = _("The human team is locked");
       type      = DT_COMMAND;
       break;
 
     case MN_PLAYERLIMIT:
-      longMsg   = "The maximum number of playing clients has been reached. "
-                  "Please wait until slots become available.";
-      shortMsg  = "No free player slots";
+      longMsg   = _("The maximum number of playing clients has been reached. "
+                  "Please wait until slots become available.");
+      shortMsg  = _("No free player slots");
       type      = DT_COMMAND;
       break;
 
     case MN_WARMUP:
-      longMsg   = "You must wait until the warmup time is finished "
-                  "before joining a team. ";
-      shortMsg  = "You cannot join a team during warmup.";
+      longMsg   = _("You must wait until the warmup time is finished "
+                  "before joining a team. ");
+      shortMsg  = _("You cannot join a team during warmup.");
       type      = DT_COMMAND;
       break;
 
     case MN_A_TEAMCHANGEBUILDTIMER:
-      longMsg   = "You cannot leave the Alien team until your build timer "
-                  "has expired.";
-      shortMsg  = "You cannot change teams until your build timer expires";
+      longMsg   = _("You cannot leave the Alien team until your build timer "
+                  "has expired.");
+      shortMsg  = _("You cannot change teams until your build timer expires");
       type      = DT_COMMAND;
       break;
 
     case MN_H_TEAMCHANGEBUILDTIMER:
-      longMsg   = "You cannot leave the Human team until your build timer "
-                  "has expired.";
-      shortMsg  = "You cannot change teams until your build timer expires";
+      longMsg   = _("You cannot leave the Human team until your build timer "
+                  "has expired.");
+      shortMsg  = _("You cannot change teams until your build timer expires");
       type      = DT_COMMAND;
       break;
 
@@ -541,45 +541,45 @@ void CG_Menu( int menu, int arg )
     case MN_CMD_CHEAT:
       //longMsg   = "This action is considered cheating. It can only be used "
       //            "in cheat mode, which is not enabled on this server.";
-      shortMsg  = "Cheats are not enabled on this server";
+      shortMsg  = _("Cheats are not enabled on this server");
       type      = DT_COMMAND;
       break;
 
     case MN_CMD_CHEAT_TEAM:
-      shortMsg  = "Cheats are not enabled on this server, so "
-                  "you may not use this command while on a team";
+      shortMsg  = _("Cheats are not enabled on this server, so "
+                  "you may not use this command while on a team");
       type      = DT_COMMAND;
       break;
 
     case MN_CMD_TEAM:
-      //longMsg   = "You must be on a team to perform this action. Join the alien"
-      //            "or human team and try again.";
-      shortMsg  = "Join a team first";
+      //longMsg   = _("You must be on a team to perform this action. Join the alien"
+      //            "or human team and try again.");
+      shortMsg  = _("Join a team first");
       type      = DT_COMMAND;
       break;
 
     case MN_CMD_SPEC:
-      //longMsg   = "You may not perform this action while on a team. Become a "
-      //            "spectator before trying again.";
-      shortMsg  = "You can only use this command when spectating";
+      //longMsg   = _("You may not perform this action while on a team. Become a "
+      //            "spectator before trying again.");
+      shortMsg  = _("You can only use this command when spectating");
       type      = DT_COMMAND;
       break;
 
     case MN_CMD_ALIEN:
-      //longMsg   = "You must be on the alien team to perform this action.";
-      shortMsg  = "Must be alien to use this command";
+      //longMsg   = _("You must be on the alien team to perform this action.");
+      shortMsg  = _("Must be alien to use this command");
       type      = DT_COMMAND;
       break;
 
     case MN_CMD_HUMAN:
-      //longMsg   = "You must be on the human team to perform this action.";
-      shortMsg  = "Must be human to use this command";
+      //longMsg   = "You must be on the human team to perform this action.");
+      shortMsg  = _("Must be human to use this command");
       type      = DT_COMMAND;
       break;
 
     case MN_CMD_LIVING:
-      //longMsg   = "You must be living to perform this action.";
-      shortMsg  = "Must be living to use this command";
+      //longMsg   = "You must be living to perform this action.");
+      shortMsg  = _("Must be living to use this command");
       type      = DT_COMMAND;
       break;
 
@@ -587,225 +587,225 @@ void CG_Menu( int menu, int arg )
     //===============================
     
     case MN_B_NOROOM:
-      longMsg   = "There is no room to build here. Move until the structure turns "
-                  "translucent green, indicating a valid build location.";
-      shortMsg  = "There is no room to build here";
+      longMsg   = _("There is no room to build here. Move until the structure turns "
+                  "translucent green, indicating a valid build location.");
+      shortMsg  = _("There is no room to build here");
       type      = DT_BUILD;
       break;
 
     case MN_B_NORMAL:
-      longMsg   = "Cannot build on this surface. The surface is too steep or "
+      longMsg   = _("Cannot build on this surface. The surface is too steep or "
                   "unsuitable for building. Please choose another site for this "
-                  "structure.";
-      shortMsg  = "Cannot build on this surface";
+                  "structure.");
+      shortMsg  = _("Cannot build on this surface");
       type      = DT_BUILD;
       break;
 
     case MN_B_CANNOT:
       longMsg   = NULL;
-      shortMsg  = "You cannot build that structure";
+      shortMsg  = _("You cannot build that structure");
       type      = DT_BUILD;
       break;
 
     // FIXME: MN_H_ and MN_A_?
     case MN_B_LASTSPAWN:
-      longMsg   = "This action would remove your team's last spawn point, "
+      longMsg   = _("This action would remove your team's last spawn point, "
                   "which often quickly results in a loss. Try building more "
-                  "spawns.";
-      shortMsg  = "You may not deconstruct the last spawn";
+                  "spawns.");
+      shortMsg  = _("You may not deconstruct the last spawn");
       break;
 
     case MN_B_SUDDENDEATH:
-      longMsg   = "Neither team has prevailed after a certain time and the "
+      longMsg   = _("Neither team has prevailed after a certain time and the "
                   "game has entered Sudden Death. During Sudden Death "
-                  "building is not allowed.";
-      shortMsg  = "Cannot build during Sudden Death";
+                  "building is not allowed.");
+      shortMsg  = _("Cannot build during Sudden Death");
       type      = DT_BUILD;
       break;
 
     case MN_B_REVOKED:
-      longMsg   = "Your teammates have lost faith in your ability to build "
+      longMsg   = _("Your teammates have lost faith in your ability to build "
                   "for the team. You will not be allowed to build until your "
-                  "team votes to reinstate your building rights.";
-      shortMsg  = "Your building rights have been revoked";
+                  "team votes to reinstate your building rights.");
+      shortMsg  = _("Your building rights have been revoked");
       type      = DT_BUILD;
       break;
 
     case MN_B_SURRENDER:
-      longMsg   = "Your team has decided to admit defeat and concede the game:"
-                  "traitors and cowards are not allowed to build.";
+      longMsg   = _("Your team has decided to admit defeat and concede the game:"
+                  "traitors and cowards are not allowed to build.");
                   // too harsh?
-      shortMsg  = "Building is denied to traitorous cowards";
+      shortMsg  = _("Building is denied to traitorous cowards");
       break;
 
     //===============================
 
     case MN_H_NOBP:
       if( cgs.markDeconstruct )
-        longMsg   = "There is no power remaining. Free up power by marking "
-                    "existing buildable objects.";
+        longMsg   = _("There is no power remaining. Free up power by marking "
+                    "existing buildable objects.");
       else
-        longMsg   = "There is no power remaining. Free up power by deconstructing "
-                    "existing buildable objects.";
-      shortMsg  = "There is no power remaining";
+        longMsg   = _("There is no power remaining. Free up power by deconstructing "
+                    "existing buildable objects.");
+      shortMsg  = _("There is no power remaining");
       type      = DT_BUILD;
       break;
 
     case MN_H_NOTPOWERED:
-      longMsg   = "This buildable is not powered. Build a Reactor and/or Repeater "
-                  "in order to power it.";
-      shortMsg  = "This buildable is not powered";
+      longMsg   = _("This buildable is not powered. Build a Reactor and/or Repeater "
+                  "in order to power it.");
+      shortMsg  = _("This buildable is not powered");
       type      = DT_BUILD;
       break;
 
     case MN_H_ONEREACTOR:
-      longMsg   = "There can only be one Reactor. Deconstruct the existing one if you "
-                  "wish to move it.";
-      shortMsg  = "There can only be one Reactor";
+      longMsg   = _("There can only be one Reactor. Deconstruct the existing one if you "
+                  "wish to move it.");
+      shortMsg  = _("There can only be one Reactor");
       type      = DT_BUILD;
       break;
 
     case MN_H_NOPOWERHERE:
-      longMsg   = "There is no power here. If available, a Repeater may be used to "
-                  "transmit power to this location.";
-      shortMsg  = "There is no power here";
+      longMsg   = _("There is no power here. If available, a Repeater may be used to "
+                  "transmit power to this location.");
+      shortMsg  = _("There is no power here");
       type      = DT_BUILD;
       break;
 
     case MN_H_NODCC:
-      longMsg   = "There is no Defense Computer. A Defense Computer is needed to "
-                  "build this.";
-      shortMsg  = "There is no Defense Computer";
+      longMsg   = _("There is no Defense Computer. A Defense Computer is needed to "
+                  "build this.");
+      shortMsg  = _("There is no Defense Computer");
       type      = DT_BUILD;
       break;
 
     case MN_H_RPTPOWERHERE:
-      longMsg   = "This area already has power. A Repeater is not required here.";
-      shortMsg  = "This area already has power";
+      longMsg   = _("This area already has power. A Repeater is not required here.");
+      shortMsg  = _("This area already has power");
       type      = DT_BUILD;
       break;
 
     case MN_H_NOSLOTS:
-      longMsg   = "You have no room to carry this. Please sell any conflicting "
-                  "upgrades before purchasing this item.";
-      shortMsg  = "You have no room to carry this";
+      longMsg   = _("You have no room to carry this. Please sell any conflicting "
+                  "upgrades before purchasing this item.");
+      shortMsg  = _("You have no room to carry this");
       type      = DT_ARMOURYEVOLVE;
       break;
 
     case MN_H_NOFUNDS:
-      longMsg   = "Insufficient funds. You do not have enough credits to perform "
-                  "this action.";
-      shortMsg  = "Insufficient funds";
+      longMsg   = _("Insufficient funds. You do not have enough credits to perform "
+                  "this action.");
+      shortMsg  = _("Insufficient funds");
       type      = DT_ARMOURYEVOLVE;
       break;
 
     case MN_H_ITEMHELD:
-      longMsg   = "You already hold this item. It is not possible to carry multiple "
-                  "items of the same type.";
-      shortMsg  = "You already hold this item";
+      longMsg   = _("You already hold this item. It is not possible to carry multiple "
+                  "items of the same type.");
+      shortMsg  = _("You already hold this item");
       type      = DT_ARMOURYEVOLVE;
       break;
 
     case MN_H_NOARMOURYHERE:
-      longMsg   = "You must be near a powered Armoury in order to purchase "
-                  "weapons, upgrades or ammunition.";
-      shortMsg  = "You must be near a powered Armoury";
+      longMsg   = _("You must be near a powered Armoury in order to purchase "
+                  "weapons, upgrades or ammunition.");
+      shortMsg  = _("You must be near a powered Armoury");
       type      = DT_ARMOURYEVOLVE;
       break;
 
     case MN_H_NOENERGYAMMOHERE:
-      longMsg   = "You must be near a Reactor or a powered Armoury or Repeater "
-                  "in order to purchase energy ammunition.";
-      shortMsg  = "You must be near a Reactor or a powered Armoury or Repeater";
+      longMsg   = _("You must be near a Reactor or a powered Armoury or Repeater "
+                  "in order to purchase energy ammunition.");
+      shortMsg  = _("You must be near a Reactor or a powered Armoury or Repeater");
       type      = DT_ARMOURYEVOLVE;
       break;
 
     case MN_H_NOROOMBSUITON:
-      longMsg   = "There is not enough room here to put on a Battle Suit. "
-                  "Make sure you have enough head room to climb in.";
-      shortMsg  = "Not enough room here to put on a Battle Suit";
+      longMsg   = _("There is not enough room here to put on a Battle Suit. "
+                  "Make sure you have enough head room to climb in.");
+      shortMsg  = _("Not enough room here to put on a Battle Suit");
       type      = DT_ARMOURYEVOLVE;
       break;
 
     case MN_H_NOROOMBSUITOFF:
-      longMsg   = "There is not enough room here to take off your Battle Suit. "
-                  "Make sure you have enough head room to climb out.";
-      shortMsg  = "Not enough room here to take off your Battle Suit";
+      longMsg   = _("There is not enough room here to take off your Battle Suit. "
+                  "Make sure you have enough head room to climb out.");
+      shortMsg  = _("Not enough room here to take off your Battle Suit");
       type      = DT_ARMOURYEVOLVE;
       break;
 
     case MN_H_ARMOURYBUILDTIMER:
-      longMsg   = "You are not allowed to buy or sell weapons until your "
-                  "build timer has expired.";
-      shortMsg  = "You can not buy or sell weapons until your build timer "
-                  "expires";
+      longMsg   = _("You are not allowed to buy or sell weapons until your "
+                  "build timer has expired.");
+      shortMsg  = _("You can not buy or sell weapons until your build timer "
+                  "expires");
       type      = DT_ARMOURYEVOLVE;
       break;
 
     case MN_H_DEADTOCLASS:
-      shortMsg  = "You must be dead to use the class command";
+      shortMsg  = _("You must be dead to use the class command");
       type      = DT_COMMAND;
       break;
 
     case MN_H_UNKNOWNSPAWNITEM:
-      shortMsg  = "Unknown starting item";
+      shortMsg  = _("Unknown starting item");
       type      = DT_COMMAND;
       break;
 
     //===============================
 
     case MN_A_NOCREEP:
-      longMsg   = "There is no creep here. You must build near existing Eggs or "
-                  "the Overmind. Alien structures will not support themselves.";
-      shortMsg  = "There is no creep here";
+      longMsg   = _("There is no creep here. You must build near existing Eggs or "
+                  "the Overmind. Alien structures will not support themselves.");
+      shortMsg  = _("There is no creep here");
       type      = DT_BUILD;
       break;
 
     case MN_A_NOOVMND:
-      longMsg   = "There is no Overmind. An Overmind must be built to control "
-                  "the structure you tried to place.";
-      shortMsg  = "There is no Overmind";
+      longMsg   = _("There is no Overmind. An Overmind must be built to control "
+                  "the structure you tried to place.");
+      shortMsg  = _("There is no Overmind");
       type      = DT_BUILD;
       break;
 
     case MN_A_ONEOVERMIND:
-      longMsg   = "There can only be one Overmind. Deconstruct the existing one if you "
-                  "wish to move it.";
-      shortMsg  = "There can only be one Overmind";
+      longMsg   = _("There can only be one Overmind. Deconstruct the existing one if you "
+                  "wish to move it.");
+      shortMsg  = _("There can only be one Overmind");
       type      = DT_BUILD;
       break;
 
     case MN_A_NOBP:
-      longMsg   = "The Overmind cannot control any more structures. Deconstruct existing "
-                  "structures to build more.";
-      shortMsg  = "The Overmind cannot control any more structures";
+      longMsg   = _("The Overmind cannot control any more structures. Deconstruct existing "
+                  "structures to build more.");
+      shortMsg  = _("The Overmind cannot control any more structures");
       type      = DT_BUILD;
       break;
 
     case MN_A_NOEROOM:
-      longMsg   = "There is no room to evolve here. Move away from walls or other "
-                  "nearby objects and try again.";
-      shortMsg  = "There is no room to evolve here";
+      longMsg   = _("There is no room to evolve here. Move away from walls or other "
+                  "nearby objects and try again.");
+      shortMsg  = _("There is no room to evolve here");
       type      = DT_ARMOURYEVOLVE;
       break;
 
     case MN_A_TOOCLOSE:
-      longMsg   = "This location is too close to the enemy to evolve. Move away "
-                  "from the enemy's presence and try again.";
-      shortMsg  = "This location is too close to the enemy to evolve";
+      longMsg   = _("This location is too close to the enemy to evolve. Move away "
+                  "from the enemy's presence and try again.");
+      shortMsg  = _("This location is too close to the enemy to evolve");
       type      = DT_ARMOURYEVOLVE;
       break;
 
     case MN_A_NOOVMND_EVOLVE:
-      longMsg   = "There is no Overmind. An Overmind must be built to allow "
-                  "you to upgrade.";
-      shortMsg  = "There is no Overmind";
+      longMsg   = _("There is no Overmind. An Overmind must be built to allow "
+                  "you to upgrade.");
+      shortMsg  = _("There is no Overmind");
       type      = DT_ARMOURYEVOLVE;
       break;
 
     case MN_A_EVOLVEBUILDTIMER:
-      longMsg   = "You cannot evolve until your build timer has expired.";
-      shortMsg  = "You cannot evolve until your build timer expires";
+      longMsg   = _("You cannot evolve until your build timer has expired.");
+      shortMsg  = _("You cannot evolve until your build timer expires");
       type      = DT_ARMOURYEVOLVE;
       break;
 
@@ -819,44 +819,44 @@ void CG_Menu( int menu, int arg )
       break;
 
     case MN_A_CANTEVOLVE:
-      shortMsg  = va( "You cannot evolve into a %s", 
-                      BG_ClassConfig( arg )->humanName );
+      shortMsg  = va( _("You cannot evolve into a %s"), 
+                      _(BG_ClassConfig( arg )->humanName) );
       type      = DT_ARMOURYEVOLVE;
       break;
 
     case MN_A_EVOLVEWALLWALK:
-      shortMsg  = "You cannot evolve while wallwalking";
+      shortMsg  = _("You cannot evolve while wallwalking");
       type      = DT_ARMOURYEVOLVE;
       break;
 
     case MN_A_UNKNOWNCLASS:
-      shortMsg  = "Unknown class";
+      shortMsg  = _("Unknown class");
       type      = DT_ARMOURYEVOLVE;
       break;
       
     case MN_A_CLASSNOTSPAWN:
-      shortMsg  = va( "You cannot spawn as a %s", 
-                      BG_ClassConfig( arg )->humanName );
+      shortMsg  = va( _("You cannot spawn as a %s"), 
+                      _(BG_ClassConfig( arg )->humanName) );
       type      = DT_ARMOURYEVOLVE;
       break;
     
     case MN_A_CLASSNOTALLOWED:
-      shortMsg  = va( "The %s is not allowed",
-                      BG_ClassConfig( arg )->humanName );
+      shortMsg  = va( _("The %s is not allowed"),
+                      _(BG_ClassConfig( arg )->humanName) );
       type      = DT_ARMOURYEVOLVE;
       break;
 
     case MN_A_CLASSNOTATSTAGE:
-      shortMsg  = va( "The %s is not allowed at Stage %d",
-                      BG_ClassConfig( arg )->humanName,
+      shortMsg  = va( _("The %s is not allowed at Stage %d"),
+                      _(BG_ClassConfig( arg )->humanName),
                       cgs.alienStage + 1 );
       type      = DT_ARMOURYEVOLVE;
       break;
 
     default:
-      Com_Printf( "cgame: debug: no such menu %d\n", menu );
+      Com_Printf( _("cgame: debug: no such menu %d\n"), menu );
   }
-  
+
   if( type == DT_ARMOURYEVOLVE && cg_disableUpgradeDialogs.integer )
     return;
 
@@ -986,7 +986,7 @@ static void CG_Say( int clientNum, saymode_t mode, const char *text )
                  ignore, prefix, name, cgs.clientinfo[ cg.clientNum ].name,
                  maybeColon, INDENT_MARKER, color, text );
       if( !ignore[0] )
-        CG_CenterPrint( va( "%sPrivate message from: " S_COLOR_WHITE "%s", 
+        CG_CenterPrint( va( _("%sPrivate message from: " S_COLOR_WHITE "%s"), 
                             color, name ), 200, GIANTCHAR_WIDTH * 4 );
       break;
     case SAY_RAW:
@@ -1032,21 +1032,21 @@ static voiceTrack_t *CG_VoiceTrack( char *voice, int cmd, int track )
   v = BG_VoiceByName( cgs.voices, voice );
   if( !v )
   {
-    CG_Printf( "[skipnotify]WARNING: could not find voice \"%s\"\n", voice );
+    CG_Printf( _("[skipnotify]WARNING: could not find voice \"%s\"\n"), voice );
     return NULL;
   }
   c = BG_VoiceCmdByNum( v->cmds, cmd );
   if( !c )
   {
-    CG_Printf( "[skipnotify]WARNING: could not find command %d "
-      "in voice \"%s\"\n", cmd, voice );
+    CG_Printf( _("[skipnotify]WARNING: could not find command %d "
+      "in voice \"%s\"\n"), cmd, voice );
     return NULL;
   }
   t = BG_VoiceTrackByNum( c->tracks, track );
   if( !t )
   {
-    CG_Printf( "[skipnotify]WARNING: could not find track %d for command %d in "
-      "voice \"%s\"\n", track, cmd, voice );
+    CG_Printf( _("[skipnotify]WARNING: could not find track %d for command %d in "
+      "voice \"%s\"\n"), track, cmd, voice );
     return NULL;
   }
   return t;
@@ -1295,7 +1295,7 @@ static void CG_ServerCommand( void )
     return;
   }
 
-  CG_Printf( "Unknown client game command: %s\n", cmd );
+  CG_Printf( _("Unknown client game command: %s\n"), cmd );
 }
 
 
diff --git a/src/cgame/cg_snapshot.c b/src/cgame/cg_snapshot.c
index 31cc02e..6837641 100644
--- a/src/cgame/cg_snapshot.c
+++ b/src/cgame/cg_snapshot.c
@@ -134,10 +134,10 @@ static void CG_TransitionSnapshot( void )
   int         i;
 
   if( !cg.snap )
-    CG_Error( "CG_TransitionSnapshot: NULL cg.snap" );
+    CG_Error( _("CG_TransitionSnapshot: NULL cg.snap") );
 
   if( !cg.nextSnap )
-    CG_Error( "CG_TransitionSnapshot: NULL cg.nextSnap" );
+    CG_Error( _("CG_TransitionSnapshot: NULL cg.nextSnap") );
 
   // execute any server string commands before transitioning entities
   CG_ExecuteNewServerCommands( cg.nextSnap->serverCommandSequence );
@@ -259,7 +259,7 @@ static snapshot_t *CG_ReadNextSnapshot( void )
 
   if( cg.latestSnapshotNum > cgs.processedSnapshotNum + 1000 )
   {
-    CG_Printf( "WARNING: CG_ReadNextSnapshot: way out of range, %i > %i",
+    CG_Printf( _("WARNING: CG_ReadNextSnapshot: way out of range, %i > %i"),
       cg.latestSnapshotNum, cgs.processedSnapshotNum );
   }
 
@@ -337,7 +337,7 @@ void CG_ProcessSnapshots( void )
     if( n < cg.latestSnapshotNum )
     {
       // this should never happen
-      CG_Error( "CG_ProcessSnapshots: n < cg.latestSnapshotNum" );
+      CG_Error( _("CG_ProcessSnapshots: n < cg.latestSnapshotNum") );
     }
 
     cg.latestSnapshotNum = n;
@@ -381,7 +381,7 @@ void CG_ProcessSnapshots( void )
 
       // if time went backwards, we have a level restart
       if( cg.nextSnap->serverTime < cg.snap->serverTime )
-        CG_Error( "CG_ProcessSnapshots: Server time went backwards" );
+        CG_Error( _("CG_ProcessSnapshots: Server time went backwards") );
     }
 
     // if our time is < nextFrame's, we have a nice interpolating state
@@ -394,7 +394,7 @@ void CG_ProcessSnapshots( void )
 
   // assert our valid conditions upon exiting
   if( cg.snap == NULL )
-    CG_Error( "CG_ProcessSnapshots: cg.snap == NULL" );
+    CG_Error( _("CG_ProcessSnapshots: cg.snap == NULL") );
 
   if( cg.time < cg.snap->serverTime )
   {
@@ -403,6 +403,6 @@ void CG_ProcessSnapshots( void )
   }
 
   if( cg.nextSnap != NULL && cg.nextSnap->serverTime <= cg.time )
-    CG_Error( "CG_ProcessSnapshots: cg.nextSnap->serverTime <= cg.time" );
+    CG_Error( _("CG_ProcessSnapshots: cg.nextSnap->serverTime <= cg.time") );
 }
 
diff --git a/src/cgame/cg_syscalls.asm b/src/cgame/cg_syscalls.asm
index 2537c91..18bc72d 100644
--- a/src/cgame/cg_syscalls.asm
+++ b/src/cgame/cg_syscalls.asm
@@ -119,3 +119,11 @@ equ ceil                              -209
 equ testPrintInt                      -210
 equ testPrintFloat                    -211
 
+equ trap_Gettext                      -301
+equ trap_R_LoadFace                   -302
+equ trap_R_FreeFace                   -303
+equ trap_R_LoadGlyph                  -304
+equ trap_R_FreeGlyph                  -305
+equ trap_R_Glyph                      -306
+equ trap_R_FreeCachedGlyphs           -307
+
diff --git a/src/cgame/cg_syscalls.c b/src/cgame/cg_syscalls.c
index 0c0b722..3649003 100644
--- a/src/cgame/cg_syscalls.c
+++ b/src/cgame/cg_syscalls.c
@@ -330,6 +330,36 @@ void trap_R_RegisterFont( const char *fontName, int pointSize, fontInfo_t *font
   syscall(CG_R_REGISTERFONT, fontName, pointSize, font );
 }
 
+void trap_R_LoadFace( const char *fileName, int pointSize, const char *name, face_t *face )
+{
+  syscall( CG_R_LOADFACE, fileName, pointSize, name, face );
+}
+
+void trap_R_FreeFace( face_t *face )
+{
+  syscall( CG_R_FREEFACE, face );
+}
+
+void trap_R_LoadGlyph( face_t *face, const char *str, int img, glyphInfo_t *glyphInfo )
+{
+  syscall( CG_R_LOADGLYPH, face, str, img, glyphInfo );
+}
+
+void trap_R_FreeGlyph( face_t *face, int img, glyphInfo_t *glyphInfo )
+{
+  syscall( CG_R_FREEGLYPH, face, img, glyphInfo );
+}
+
+void trap_R_Glyph( fontInfo_t *font, face_t *face, const char *str, glyphInfo_t *glyph )
+{
+  syscall( CG_R_GLYPH, font, face, str, glyph );
+}
+
+void trap_R_FreeCachedGlyphs( face_t *face )
+{
+  syscall( CG_R_FREECACHEDGLYPHS, face );
+}
+
 void  trap_R_ClearScene( void )
 {
   syscall( CG_R_CLEARSCENE );
@@ -590,3 +620,25 @@ void trap_Key_SetOverstrikeMode( qboolean state ) {
 qboolean trap_Key_GetOverstrikeMode( void ) {
   return syscall( CG_KEY_GETOVERSTRIKEMODE );
 }
+
+void trap_Gettext( char *buffer, const char *msgid, int bufferLength )
+{
+  static int engineState = 0;
+
+  if( !( engineState & 0x01 ) )
+  {
+    char t[2];
+
+    engineState |= 0x01;
+
+    trap_Cvar_VariableStringBuffer( "\\IS_GETTEXT_SUPPORTED", t, 2 );
+
+    if( t[0] == '1' )
+      engineState |= 0x02;
+  }
+
+  if( !( engineState & 0x02 ) )
+    syscall( CG_STRNCPY, buffer, msgid, bufferLength );
+  else
+    syscall( CG_GETTEXT, buffer, msgid, bufferLength );
+}
diff --git a/src/cgame/cg_trails.c b/src/cgame/cg_trails.c
index 05f5ef5..b55121c 100644
--- a/src/cgame/cg_trails.c
+++ b/src/cgame/cg_trails.c
@@ -712,7 +712,7 @@ static qboolean CG_ParseTrailBeam( baseTrailBeam_t *btb, char **text_p )
       if( btb->numSegments >= MAX_TRAIL_BEAM_NODES )
       {
         btb->numSegments = MAX_TRAIL_BEAM_NODES - 1;
-        CG_Printf( S_COLOR_YELLOW "WARNING: too many segments in trail beam\n" );
+        CG_Printf( _(S_COLOR_YELLOW "WARNING: too many segments in trail beam\n") );
       }
       continue;
     }
@@ -766,7 +766,7 @@ static qboolean CG_ParseTrailBeam( baseTrailBeam_t *btb, char **text_p )
         token = COM_Parse( text_p );
         if( Q_stricmp( token, "}" ) )
         {
-          CG_Printf( S_COLOR_RED "ERROR: missing '}'\n" );
+          CG_Printf( _(S_COLOR_RED "ERROR: missing '}'\n") );
           break;
         }
 
@@ -788,19 +788,19 @@ static qboolean CG_ParseTrailBeam( baseTrailBeam_t *btb, char **text_p )
           token = COM_Parse( text_p );
           if( Q_stricmp( token, "}" ) )
           {
-            CG_Printf( S_COLOR_RED "ERROR: missing '}'\n" );
+            CG_Printf( _(S_COLOR_RED "ERROR: missing '}'\n") );
             break;
           }
         }
         else
         {
-          CG_Printf( S_COLOR_RED "ERROR: missing '{'\n" );
+          CG_Printf( _(S_COLOR_RED "ERROR: missing '{'\n") );
           break;
         }
       }
       else
       {
-        CG_Printf( S_COLOR_RED "ERROR: missing '{'\n" );
+        CG_Printf( _(S_COLOR_RED "ERROR: missing '{'\n") );
         break;
       }
 
@@ -870,7 +870,7 @@ static qboolean CG_ParseTrailBeam( baseTrailBeam_t *btb, char **text_p )
           btb->clampToBack = qtrue;
         else
         {
-          CG_Printf( S_COLOR_RED "ERROR: unknown textureType clamp \"%s\"\n", token );
+          CG_Printf( _(S_COLOR_RED "ERROR: unknown textureType clamp \"%s\"\n"), token );
           break;
         }
 
@@ -882,7 +882,7 @@ static qboolean CG_ParseTrailBeam( baseTrailBeam_t *btb, char **text_p )
       }
       else
       {
-        CG_Printf( S_COLOR_RED "ERROR: unknown textureType \"%s\"\n", token );
+        CG_Printf( _(S_COLOR_RED "ERROR: unknown textureType \"%s\"\n"), token );
         break;
       }
 
@@ -898,7 +898,7 @@ static qboolean CG_ParseTrailBeam( baseTrailBeam_t *btb, char **text_p )
     {
       if( btb->numJitters == MAX_TRAIL_BEAM_JITTERS )
       {
-        CG_Printf( S_COLOR_RED "ERROR: too many jitters\n", token );
+        CG_Printf( _(S_COLOR_RED "ERROR: too many jitters\n"), token );
         break;
       }
 
@@ -928,7 +928,7 @@ static qboolean CG_ParseTrailBeam( baseTrailBeam_t *btb, char **text_p )
       return qtrue; //reached the end of this trail beam
     else
     {
-      CG_Printf( S_COLOR_RED "ERROR: unknown token '%s' in trail beam\n", token );
+      CG_Printf( _(S_COLOR_RED "ERROR: unknown token '%s' in trail beam\n"), token );
       return qfalse;
     }
   }
@@ -983,18 +983,18 @@ static qboolean CG_ParseTrailSystem( baseTrailSystem_t *bts, char **text_p, cons
 
       if( !CG_ParseTrailBeam( &baseTrailBeams[ numBaseTrailBeams ], text_p ) )
       {
-        CG_Printf( S_COLOR_RED "ERROR: failed to parse trail beam\n" );
+        CG_Printf( _(S_COLOR_RED "ERROR: failed to parse trail beam\n") );
         return qfalse;
       }
 
       if( bts->numBeams == MAX_BEAMS_PER_SYSTEM )
       {
-        CG_Printf( S_COLOR_RED "ERROR: trail system has > %d beams\n", MAX_BEAMS_PER_SYSTEM );
+        CG_Printf( _(S_COLOR_RED "ERROR: trail system has > %d beams\n"), MAX_BEAMS_PER_SYSTEM );
         return qfalse;
       }
       else if( numBaseTrailBeams == MAX_BASETRAIL_BEAMS )
       {
-        CG_Printf( S_COLOR_RED "ERROR: maximum number of trail beams (%d) reached\n",
+        CG_Printf( _(S_COLOR_RED "ERROR: maximum number of trail beams (%d) reached\n"),
             MAX_BASETRAIL_BEAMS );
         return qfalse;
       }
@@ -1023,13 +1023,13 @@ static qboolean CG_ParseTrailSystem( baseTrailSystem_t *bts, char **text_p, cons
     else if( !Q_stricmp( token, "}" ) )
     {
       if( cg_debugTrails.integer >= 1 )
-        CG_Printf( "Parsed trail system %s\n", name );
+        CG_Printf( _("Parsed trail system %s\n"), name );
 
       return qtrue; //reached the end of this trail system
     }
     else
     {
-      CG_Printf( S_COLOR_RED "ERROR: unknown token '%s' in trail system %s\n", token, bts->name );
+      CG_Printf( _(S_COLOR_RED "ERROR: unknown token '%s' in trail system %s\n"), token, bts->name );
       return qfalse;
     }
   }
@@ -1063,8 +1063,8 @@ static qboolean CG_ParseTrailFile( const char *fileName )
   if( len == 0 || len >= sizeof( text ) - 1 )
   {
     trap_FS_FCloseFile( f );
-    CG_Printf( S_COLOR_RED "ERROR: trail file %s is %s\n", fileName,
-      len == 0 ? "empty" : "too long" );
+    CG_Printf( _(S_COLOR_RED "ERROR: trail file %s is %s\n"), fileName,
+      len == 0 ? _("empty") : _("too long") );
     return qfalse;
   }
 
@@ -1092,7 +1092,7 @@ static qboolean CG_ParseTrailFile( const char *fileName )
         {
           if( !Q_stricmp( baseTrailSystems[ i ].name, tsName ) )
           {
-            CG_Printf( S_COLOR_RED "ERROR: a trail system is already named %s\n", tsName );
+            CG_Printf( _(S_COLOR_RED "ERROR: a trail system is already named %s\n"), tsName );
             return qfalse;
           }
         }
@@ -1101,7 +1101,7 @@ static qboolean CG_ParseTrailFile( const char *fileName )
 
         if( !CG_ParseTrailSystem( &baseTrailSystems[ numBaseTrailSystems ], &text_p, tsName ) )
         {
-          CG_Printf( S_COLOR_RED "ERROR: %s: failed to parse trail system %s\n", fileName, tsName );
+          CG_Printf( _(S_COLOR_RED "ERROR: %s: failed to parse trail system %s\n"), fileName, tsName );
           return qfalse;
         }
 
@@ -1110,7 +1110,7 @@ static qboolean CG_ParseTrailFile( const char *fileName )
 
         if( numBaseTrailSystems == MAX_BASETRAIL_SYSTEMS )
         {
-          CG_Printf( S_COLOR_RED "ERROR: maximum number of trail systems (%d) reached\n",
+          CG_Printf( _(S_COLOR_RED "ERROR: maximum number of trail systems (%d) reached\n"),
               MAX_BASETRAIL_SYSTEMS );
           return qfalse;
         }
@@ -1121,7 +1121,7 @@ static qboolean CG_ParseTrailFile( const char *fileName )
       }
       else
       {
-        CG_Printf( S_COLOR_RED "ERROR: unamed trail system\n" );
+        CG_Printf( _(S_COLOR_RED "ERROR: unamed trail system\n") );
         return qfalse;
       }
     }
@@ -1133,7 +1133,7 @@ static qboolean CG_ParseTrailFile( const char *fileName )
     }
     else
     {
-      CG_Printf( S_COLOR_RED "ERROR: trail system already named\n" );
+      CG_Printf( _(S_COLOR_RED "ERROR: trail system already named\n") );
       return qfalse;
     }
   }
@@ -1181,7 +1181,7 @@ void CG_LoadTrailSystems( void )
     fileLen = strlen( filePtr );
     strcpy( fileName, "scripts/" );
     strcat( fileName, filePtr );
-    CG_Printf( "...loading '%s'\n", fileName );
+    CG_Printf( _("...loading '%s'\n"), fileName );
     CG_ParseTrailFile( fileName );
   }
 }
@@ -1217,7 +1217,7 @@ qhandle_t CG_RegisterTrailSystem( char *name )
       }
 
       if( cg_debugTrails.integer >= 1 )
-        CG_Printf( "Registered trail system %s\n", name );
+        CG_Printf( _("Registered trail system %s\n"), name );
 
       bts->registered = qtrue;
 
@@ -1226,7 +1226,7 @@ qhandle_t CG_RegisterTrailSystem( char *name )
     }
   }
 
-  CG_Printf( S_COLOR_RED "ERROR: failed to register trail system %s\n", name );
+  CG_Printf( _(S_COLOR_RED "ERROR: failed to register trail system %s\n"), name );
   return 0;
 }
 
@@ -1260,14 +1260,14 @@ static trailBeam_t *CG_SpawnNewTrailBeam( baseTrailBeam_t *btb,
       tb->valid = qtrue;
 
       if( cg_debugTrails.integer >= 1 )
-        CG_Printf( "TB %s created\n", ts->class->name );
+        CG_Printf( _("TB %s created\n"), ts->class->name );
 
       return tb;
     }
   }
 
   if( cg_debugTrails.integer >= 1 )
-    CG_Printf( "MAX_TRAIL_BEAMS\n" );
+    CG_Printf( _("MAX_TRAIL_BEAMS\n") );
 
   return NULL;
 }
@@ -1288,7 +1288,7 @@ trailSystem_t *CG_SpawnNewTrailSystem( qhandle_t psHandle )
 
   if( !bts->registered )
   {
-    CG_Printf( S_COLOR_RED "ERROR: a trail system has not been registered yet\n" );
+    CG_Printf( _(S_COLOR_RED "ERROR: a trail system has not been registered yet\n") );
     return NULL;
   }
 
@@ -1311,14 +1311,14 @@ trailSystem_t *CG_SpawnNewTrailSystem( qhandle_t psHandle )
         CG_SpawnNewTrailBeam( bts->beams[ j ], ts );
 
       if( cg_debugTrails.integer >= 1 )
-        CG_Printf( "TS %s created\n", bts->name );
+        CG_Printf( _("TS %s created\n"), bts->name );
 
       return ts;
     }
   }
 
   if( cg_debugTrails.integer >= 1 )
-    CG_Printf( "MAX_TRAIL_SYSTEMS\n" );
+    CG_Printf( _("MAX_TRAIL_SYSTEMS\n") );
 
   return NULL;
 }
@@ -1432,13 +1432,13 @@ static void CG_GarbageCollectTrailSystems( void )
 
       CG_DestroyTrailSystem( &tempTS );
       if( cg_debugTrails.integer >= 1 )
-        CG_Printf( "TS %s expired (born %d, lives %d, now %d)\n",
+        CG_Printf( _("TS %s expired (born %d, lives %d, now %d)\n"),
                    ts->class->name, ts->birthTime, ts->class->lifeTime,
                    cg.time );
     }
 
     if( cg_debugTrails.integer >= 1 && !ts->valid )
-      CG_Printf( "TS %s garbage collected\n", ts->class->name );
+      CG_Printf( _("TS %s garbage collected\n"), ts->class->name );
   }
 }
 
@@ -1479,7 +1479,7 @@ void CG_AddTrails( void )
       if( trailBeams[ i ].valid )
         numTB++;
 
-    CG_Printf( "TS: %d  TB: %d\n", numTS, numTB );
+    CG_Printf( _("TS: %d  TB: %d\n"), numTS, numTB );
   }
 }
 
diff --git a/src/cgame/cg_tutorial.c b/src/cgame/cg_tutorial.c
index 1bc4ac8..6144ec6 100644
--- a/src/cgame/cg_tutorial.c
+++ b/src/cgame/cg_tutorial.c
@@ -94,7 +94,6 @@ static const char *CG_KeyNameForCommand( const char *command )
 {
   int         i, j;
   static char buffer[ MAX_STRING_CHARS ];
-  int         firstKeyLength;
 
   buffer[ 0 ] = '\0';
 
@@ -104,26 +103,34 @@ static const char *CG_KeyNameForCommand( const char *command )
     {
       if( bindings[ i ].keys[ 0 ] != K_NONE )
       {
+        static char first[ MAX_STRING_CHARS ];
         trap_Key_KeynumToStringBuf( bindings[ i ].keys[ 0 ],
-            buffer, MAX_STRING_CHARS );
-        firstKeyLength = strlen( buffer );
+            first, MAX_STRING_CHARS );
 
-        for( j = 0; j < firstKeyLength; j++ )
-          buffer[ j ] = toupper( buffer[ j ] );
+        for( j = 0; j < strlen( first ); j++ )
+          first[ j ] = toupper( first[ j ] );
 
         if( bindings[ i ].keys[ 1 ] != K_NONE )
         {
-          Q_strcat( buffer, MAX_STRING_CHARS, " or " );
+          static char second[ MAX_STRING_CHARS ];
+
+          Q_strcat( second, MAX_STRING_CHARS, _(" or ") );
           trap_Key_KeynumToStringBuf( bindings[ i ].keys[ 1 ],
-              buffer + strlen( buffer ), MAX_STRING_CHARS - strlen( buffer ) );
+              second, MAX_STRING_CHARS );
+
+          for( j = 0; j < strlen( second ); j++ )
+            second[ j ] = toupper( second[ j ] );
 
-          for( j = firstKeyLength + 4; j < strlen( buffer ); j++ )
-            buffer[ j ] = toupper( buffer[ j ] );
+          Com_sprintf( buffer, MAX_STRING_CHARS, _("^K^E^Y^7%s or %s"), first, second );
+        }
+        else
+        {
+          Com_sprintf( buffer, MAX_STRING_CHARS, _("^K^E^Y^7%s"), first );
         }
       }
       else
       {
-        Com_sprintf( buffer, MAX_STRING_CHARS, "\"%s\" (unbound)",
+        Com_sprintf( buffer, MAX_STRING_CHARS, _("\"%s\" (unbound)"),
           bindings[ i ].humanName );
       }
 
@@ -181,19 +188,19 @@ static void CG_AlienBuilderText( char *text, playerState_t *ps )
   if( buildable > BA_NONE )
   {
     Q_strcat( text, MAX_TUTORIAL_TEXT,
-        va( "Press %s to place the %s\n",
+        va( _("Press %s to place the %s\n"),
           CG_KeyNameForCommand( "+attack" ),
-          BG_Buildable( buildable )->humanName ) );
+          _(BG_Buildable( buildable )->humanName) ) );
 
     Q_strcat( text, MAX_TUTORIAL_TEXT,
-        va( "Press %s to cancel placing the %s\n",
+        va( _("Press %s to cancel placing the %s\n"),
           CG_KeyNameForCommand( "+button5" ),
-          BG_Buildable( buildable )->humanName ) );
+          _(BG_Buildable( buildable )->humanName) ) );
   }
   else
   {
     Q_strcat( text, MAX_TUTORIAL_TEXT,
-        va( "Press %s to build a structure\n",
+        va( _("Press %s to build a structure\n"),
           CG_KeyNameForCommand( "+attack" ) ) );
   }
 
@@ -204,20 +211,20 @@ static void CG_AlienBuilderText( char *text, playerState_t *ps )
       if( es->eFlags & EF_B_MARKED )
       {
         Q_strcat( text, MAX_TUTORIAL_TEXT,
-            va( "Press %s to unmark this structure\n",
+            va( _("Press %s to unmark this structure\n"),
               CG_KeyNameForCommand( "deconstruct" ) ) );
       }
       else
       {
         Q_strcat( text, MAX_TUTORIAL_TEXT,
-            va( "Press %s to mark this structure\n",
+            va( _("Press %s to mark this structure\n"),
               CG_KeyNameForCommand( "deconstruct" ) ) );
       }
     }
     else
     {
       Q_strcat( text, MAX_TUTORIAL_TEXT,
-          va( "Press %s to destroy this structure\n",
+          va( _("Press %s to destroy this structure\n"),
             CG_KeyNameForCommand( "deconstruct" ) ) );
     }
   }
@@ -225,18 +232,18 @@ static void CG_AlienBuilderText( char *text, playerState_t *ps )
   if( ( ps->stats[ STAT_BUILDABLE ] & ~SB_VALID_TOGGLEBIT ) == BA_NONE )
   {
     Q_strcat( text, MAX_TUTORIAL_TEXT,
-        va( "Press %s to swipe\n",
+        va( _("Press %s to swipe\n"),
           CG_KeyNameForCommand( "+button5" ) ) );
   }
 
   if( ps->stats[ STAT_CLASS ] == PCL_ALIEN_BUILDER0_UPG )
   {
     Q_strcat( text, MAX_TUTORIAL_TEXT,
-        va( "Press %s to launch a projectile\n",
+        va( _("Press %s to launch a projectile\n"),
         CG_KeyNameForCommand( "+button2" ) ) );
 
     Q_strcat( text, MAX_TUTORIAL_TEXT,
-        va( "Press %s to walk on walls\n",
+        va( _("Press %s to walk on walls\n"),
         CG_KeyNameForCommand( "+movedown" ) ) );
   }
 }
@@ -249,10 +256,10 @@ CG_AlienLevel0Text
 static void CG_AlienLevel0Text( char *text, playerState_t *ps )
 {
   Q_strcat( text, MAX_TUTORIAL_TEXT,
-      "Touch humans to damage them\n" );
+      _("Touch humans to damage them\n") );
 
   Q_strcat( text, MAX_TUTORIAL_TEXT,
-      va( "Press %s to walk on walls\n",
+      va( _("Press %s to walk on walls\n"),
         CG_KeyNameForCommand( "+movedown" ) ) );
 }
 
@@ -264,21 +271,21 @@ CG_AlienLevel1Text
 static void CG_AlienLevel1Text( char *text, playerState_t *ps )
 {
   Q_strcat( text, MAX_TUTORIAL_TEXT,
-      "Touch humans to grab them\n" );
+      _("Touch humans to grab them\n") );
 
   Q_strcat( text, MAX_TUTORIAL_TEXT,
-      va( "Press %s to swipe\n",
+      va( _("Press %s to swipe\n"),
         CG_KeyNameForCommand( "+attack" ) ) );
 
   if( ps->stats[ STAT_CLASS ] == PCL_ALIEN_LEVEL1_UPG )
   {
     Q_strcat( text, MAX_TUTORIAL_TEXT,
-        va( "Press %s to spray poisonous gas\n",
+        va( _("Press %s to spray poisonous gas\n"),
           CG_KeyNameForCommand( "+button5" ) ) );
   }
 
   Q_strcat( text, MAX_TUTORIAL_TEXT,
-      va( "Press %s to walk on walls\n",
+      va( _("Press %s to walk on walls\n"),
         CG_KeyNameForCommand( "+movedown" ) ) );
 }
 
@@ -290,18 +297,18 @@ CG_AlienLevel2Text
 static void CG_AlienLevel2Text( char *text, playerState_t *ps )
 {
   Q_strcat( text, MAX_TUTORIAL_TEXT,
-      va( "Press %s to bite\n",
+      va( _("Press %s to bite\n"),
         CG_KeyNameForCommand( "+attack" ) ) );
 
   if( ps->stats[ STAT_CLASS ] == PCL_ALIEN_LEVEL2_UPG )
   {
     Q_strcat( text, MAX_TUTORIAL_TEXT,
-        va( "Press %s to invoke an electrical attack\n",
+        va( _("Press %s to invoke an electrical attack\n"),
           CG_KeyNameForCommand( "+button5" ) ) );
   }
 
   Q_strcat( text, MAX_TUTORIAL_TEXT,
-      va( "Hold down %s then touch a wall to wall jump\n",
+      va( _("Hold down %s then touch a wall to wall jump\n"),
         CG_KeyNameForCommand( "+moveup" ) ) );
 }
 
@@ -313,18 +320,18 @@ CG_AlienLevel3Text
 static void CG_AlienLevel3Text( char *text, playerState_t *ps )
 {
   Q_strcat( text, MAX_TUTORIAL_TEXT,
-      va( "Press %s to bite\n",
+      va( _("Press %s to bite\n"),
         CG_KeyNameForCommand( "+attack" ) ) );
 
   if( ps->stats[ STAT_CLASS ] == PCL_ALIEN_LEVEL3_UPG )
   {
     Q_strcat( text, MAX_TUTORIAL_TEXT,
-        va( "Press %s to launch a projectile\n",
+        va( _("Press %s to launch a projectile\n"),
           CG_KeyNameForCommand( "+button2" ) ) );
   }
 
   Q_strcat( text, MAX_TUTORIAL_TEXT,
-      va( "Hold down and release %s to pounce\n",
+      va( _("Hold down and release %s to pounce\n"),
         CG_KeyNameForCommand( "+button5" ) ) );
 }
 
@@ -336,11 +343,11 @@ CG_AlienLevel4Text
 static void CG_AlienLevel4Text( char *text, playerState_t *ps )
 {
   Q_strcat( text, MAX_TUTORIAL_TEXT,
-      va( "Press %s to swipe\n",
+      va( _("Press %s to swipe\n"),
         CG_KeyNameForCommand( "+attack" ) ) );
 
   Q_strcat( text, MAX_TUTORIAL_TEXT,
-      va( "Hold down and release %s to trample\n",
+      va( _("Hold down and release %s to trample\n"),
         CG_KeyNameForCommand( "+button5" ) ) );
 }
 
@@ -357,19 +364,19 @@ static void CG_HumanCkitText( char *text, playerState_t *ps )
   if( buildable > BA_NONE )
   {
     Q_strcat( text, MAX_TUTORIAL_TEXT,
-        va( "Press %s to place the %s\n",
+        va( _("Press %s to place the %s\n"),
           CG_KeyNameForCommand( "+attack" ),
           BG_Buildable( buildable )->humanName ) );
 
     Q_strcat( text, MAX_TUTORIAL_TEXT,
-        va( "Press %s to cancel placing the %s\n",
+        va( _("Press %s to cancel placing the %s\n"),
           CG_KeyNameForCommand( "+button5" ),
           BG_Buildable( buildable )->humanName ) );
   }
   else
   {
     Q_strcat( text, MAX_TUTORIAL_TEXT,
-        va( "Press %s to build a structure\n",
+        va( _("Press %s to build a structure\n"),
           CG_KeyNameForCommand( "+attack" ) ) );
   }
 
@@ -380,20 +387,20 @@ static void CG_HumanCkitText( char *text, playerState_t *ps )
       if( es->eFlags & EF_B_MARKED )
       {
         Q_strcat( text, MAX_TUTORIAL_TEXT,
-            va( "Press %s to unmark this structure\n",
+            va( _("Press %s to unmark this structure\n"),
               CG_KeyNameForCommand( "deconstruct" ) ) );
       }
       else
       {
         Q_strcat( text, MAX_TUTORIAL_TEXT,
-            va( "Press %s to mark this structure\n",
+            va( _("Press %s to mark this structure\n"),
               CG_KeyNameForCommand( "deconstruct" ) ) );
       }
     }
     else
     {
       Q_strcat( text, MAX_TUTORIAL_TEXT,
-          va( "Press %s to destroy this structure\n",
+          va( _("Press %s to destroy this structure\n"),
             CG_KeyNameForCommand( "deconstruct" ) ) );
     }
   }
@@ -413,7 +420,7 @@ static void CG_HumanText( char *text, playerState_t *ps )
     name = cg_weapons[ cg.weaponSelect ].humanName;
   else
   {
-    name = cg_upgrades[ cg.weaponSelect - 32 ].humanName;
+    name = _(cg_upgrades[ cg.weaponSelect - 32 ].humanName);
     upgrade = cg.weaponSelect - 32;
   }
 
@@ -427,7 +434,7 @@ static void CG_HumanText( char *text, playerState_t *ps )
       case WP_SHOTGUN:
       case WP_FLAMER:
         Q_strcat( text, MAX_TUTORIAL_TEXT,
-            va( "Find an Armoury and press %s for more ammo\n",
+            va( _("Find an Armoury and press %s for more ammo\n"),
               CG_KeyNameForCommand( "buy ammo" ) ) );
         break;
 
@@ -436,7 +443,7 @@ static void CG_HumanText( char *text, playerState_t *ps )
       case WP_MASS_DRIVER:
       case WP_LUCIFER_CANNON:
         Q_strcat( text, MAX_TUTORIAL_TEXT,
-            va( "Find a Reactor or Repeater and press %s for more ammo\n",
+            va( _("Find a Reactor or Repeater and press %s for more ammo\n"),
               CG_KeyNameForCommand( "buy ammo" ) ) );
         break;
 
@@ -456,38 +463,38 @@ static void CG_HumanText( char *text, playerState_t *ps )
       case WP_PULSE_RIFLE:
       case WP_FLAMER:
         Q_strcat( text, MAX_TUTORIAL_TEXT,
-            va( "Press %s to fire the %s\n",
+            va( _("Press %s to fire the %s\n"),
               CG_KeyNameForCommand( "+attack" ),
-              BG_Weapon( ps->weapon )->humanName ) );
+              _(BG_Weapon( ps->weapon )->humanName) ) );
         break;
 
       case WP_MASS_DRIVER:
         Q_strcat( text, MAX_TUTORIAL_TEXT,
-            va( "Press %s to fire the %s\n",
+            va( _("Press %s to fire the %s\n"),
               CG_KeyNameForCommand( "+attack" ),
               BG_Weapon( ps->weapon )->humanName ) );
 
         Q_strcat( text, MAX_TUTORIAL_TEXT,
-            va( "Hold %s to zoom\n",
+            va( _("Hold %s to zoom\n"),
               CG_KeyNameForCommand( "+button5" ) ) );
         break;
 
       case WP_PAIN_SAW:
         Q_strcat( text, MAX_TUTORIAL_TEXT,
-            va( "Hold %s to activate the %s\n",
+            va( _("Hold %s to activate the %s\n"),
               CG_KeyNameForCommand( "+attack" ),
               BG_Weapon( ps->weapon )->humanName ) );
         break;
 
       case WP_LUCIFER_CANNON:
         Q_strcat( text, MAX_TUTORIAL_TEXT,
-            va( "Hold and release %s to fire a charged shot\n",
+            va( _("Hold and release %s to fire a charged shot\n"),
               CG_KeyNameForCommand( "+attack" ) ) );
 
         Q_strcat( text, MAX_TUTORIAL_TEXT,
-            va( "Press %s to fire the %s\n",
+            va( _("Press %s to fire the %s\n"),
               CG_KeyNameForCommand( "+button5" ),
-              BG_Weapon( ps->weapon )->humanName ) );
+              _(BG_Weapon( ps->weapon )->humanName) ) );
         break;
 
       case WP_HBUILD:
@@ -500,17 +507,17 @@ static void CG_HumanText( char *text, playerState_t *ps )
   }
 
   Q_strcat( text, MAX_TUTORIAL_TEXT,
-      va( "Press %s and ",
+      va( _("Press %s and "),
           CG_KeyNameForCommand( "weapprev" ) ) );
   Q_strcat( text, MAX_TUTORIAL_TEXT,
-      va( "%s to select an upgrade\n",
+      va( _("%s to select an upgrade\n"),
           CG_KeyNameForCommand( "weapnext" ) ) );
 
   if( upgrade == UP_NONE ||
       ( upgrade > UP_NONE && BG_Upgrade( upgrade )->usable ) )
   {
     Q_strcat( text, MAX_TUTORIAL_TEXT,
-        va( "Press %s to use the %s\n",
+        va( _("Press %s to use the %s\n"),
             CG_KeyNameForCommand( "+button2" ),
             name ) );
   }
@@ -519,35 +526,35 @@ static void CG_HumanText( char *text, playerState_t *ps )
       BG_InventoryContainsUpgrade( UP_MEDKIT, ps->stats ) )
   {
     Q_strcat( text, MAX_TUTORIAL_TEXT,
-        va( "Press %s to use your %s\n",
+        va( _("Press %s to use your %s\n"),
           CG_KeyNameForCommand( "itemact medkit" ),
-          BG_Upgrade( UP_MEDKIT )->humanName ) );
+          _(BG_Upgrade( UP_MEDKIT )->humanName) ) );
   }
 
   if( ps->stats[ STAT_STAMINA ] <= STAMINA_BLACKOUT_LEVEL )
   {
     Q_strcat( text, MAX_TUTORIAL_TEXT,
-        "You are blacking out. Stop sprinting to recover stamina.\n" );
+        _("You are blacking out. Stop sprinting to recover stamina.\n") );
   }
   else if( ps->stats[ STAT_STAMINA ] <= STAMINA_SLOW_LEVEL )
   {
     Q_strcat( text, MAX_TUTORIAL_TEXT,
-        "Your stamina is low. Stop sprinting to recover.\n" );
+        _("Your stamina is low. Stop sprinting to recover.\n") );
   }
 
   if( cg.nearUsableBuildable )
   {
     Q_strcat( text, MAX_TUTORIAL_TEXT,
-        va( "Press %s to use this structure\n",
+        va( _("Press %s to use this structure\n"),
           CG_KeyNameForCommand( "+button7" ) ) );
   }
 
   Q_strcat( text, MAX_TUTORIAL_TEXT,
-      va( "Press %s and any direction to sprint\n",
+      va( _("Press %s and any direction to sprint\n"),
         CG_KeyNameForCommand( "+button8" ) ) );
 
   Q_strcat( text, MAX_TUTORIAL_TEXT,
-      va( "Press %s and back or strafe to dodge\n",
+      va( _("Press %s and back or strafe to dodge\n"),
         CG_KeyNameForCommand( "+button6" ) ) );
 }
 
@@ -562,17 +569,17 @@ static void CG_SpectatorText( char *text, playerState_t *ps )
   {
     if( ps->pm_flags & PMF_QUEUED )
       Q_strcat( text, MAX_TUTORIAL_TEXT,
-                va( "Press %s to leave spawn queue\n",
+                va( _("Press %s to leave spawn queue\n"),
                     CG_KeyNameForCommand( "+attack" ) ) );
     else
       Q_strcat( text, MAX_TUTORIAL_TEXT,
-                va( "Press %s to spawn\n",
+                va( _("Press %s to spawn\n"),
                     CG_KeyNameForCommand( "+attack" ) ) );
   }
   else 
   {
     Q_strcat( text, MAX_TUTORIAL_TEXT,
-        va( "Press %s to join a team\n",
+        va( _("Press %s to join a team\n"),
           CG_KeyNameForCommand( "+attack" ) ) );
   }
 
@@ -580,24 +587,24 @@ static void CG_SpectatorText( char *text, playerState_t *ps )
   {
     if( !cg.chaseFollow )
       Q_strcat( text, MAX_TUTORIAL_TEXT,
-                va( "Press %s to switch to chase-cam spectator mode\n",
+                va( _("Press %s to switch to chase-cam spectator mode\n"),
                     CG_KeyNameForCommand( "+button2" ) ) );
     else
       Q_strcat( text, MAX_TUTORIAL_TEXT,
-                va( "Press %s to return to free spectator mode\n",
+                va( _("Press %s to return to free spectator mode\n"),
                     CG_KeyNameForCommand( "+button2" ) ) );
 
       Q_strcat( text, MAX_TUTORIAL_TEXT,
-          va( "Press %s or ",
+          va( _("Press %s or "),
             CG_KeyNameForCommand( "weapprev" ) ) );
       Q_strcat( text, MAX_TUTORIAL_TEXT,
-          va( "%s to change player\n",
+          va( _("%s to change player\n"),
             CG_KeyNameForCommand( "weapnext" ) ) );
     }
   else
   {
     Q_strcat( text, MAX_TUTORIAL_TEXT,
-        va( "Press %s to follow a player\n",
+        va( _("Press %s to follow a player\n"),
             CG_KeyNameForCommand( "+button2" ) ) );
     }
   }
@@ -674,13 +681,13 @@ const char *CG_TutorialText( void )
                                     cgs.alienStage ) )
         {
           Q_strcat( text, MAX_TUTORIAL_TEXT,
-              va( "Press %s to evolve\n",
+              va( _("Press %s to evolve\n"),
                 CG_KeyNameForCommand( "+button7" ) ) );
         }
       }
     }
 
-    Q_strcat( text, MAX_TUTORIAL_TEXT, "Press ESC for the menu" );
+    Q_strcat( text, MAX_TUTORIAL_TEXT, _("Press ESC for the menu") );
   }
 
   return text;
diff --git a/src/cgame/cg_view.c b/src/cgame/cg_view.c
index ed74e9c..15fe7a9 100644
--- a/src/cgame/cg_view.c
+++ b/src/cgame/cg_view.c
@@ -98,7 +98,7 @@ void CG_TestModel_f( void )
 
   if( !cg.testModelEntity.hModel )
   {
-    CG_Printf( "Can't register model\n" );
+    CG_Printf( _("Can't register model\n") );
     return;
   }
 
@@ -177,7 +177,7 @@ static void CG_AddTestModel( void )
 
   if( !cg.testModelEntity.hModel )
   {
-    CG_Printf( "Can't register model\n" );
+    CG_Printf( _("Can't register model\n") );
     return;
   }
 
@@ -1497,6 +1497,6 @@ void CG_DrawActiveFrame( int serverTime, stereoFrame_t stereoView, qboolean demo
   CG_DrawActive( stereoView );
 
   if( cg_stats.integer )
-    CG_Printf( "cg.clientFrame:%i\n", cg.clientFrame );
+    CG_Printf( _("cg.clientFrame:%i\n"), cg.clientFrame );
 }
 
diff --git a/src/cgame/cg_weapons.c b/src/cgame/cg_weapons.c
index a166bf9..8ca6a72 100644
--- a/src/cgame/cg_weapons.c
+++ b/src/cgame/cg_weapons.c
@@ -50,7 +50,7 @@ void CG_RegisterUpgrade( int upgradeNum )
   upgradeInfo->registered = qtrue;
 
   if( strlen( BG_Upgrade( upgradeNum )->name ) <= 0 )
-    CG_Error( "Couldn't find upgrade %i", upgradeNum );
+    CG_Error( _("Couldn't find upgrade %i"), upgradeNum );
 
   upgradeInfo->humanName = BG_Upgrade( upgradeNum )->humanName;
 
@@ -108,7 +108,7 @@ static qboolean CG_ParseWeaponAnimationFile( const char *filename, weaponInfo_t
   if( len == 0 || len >= sizeof( text ) - 1 )
   {
     trap_FS_FCloseFile( f );
-    CG_Printf( "File %s is %s\n", filename, len == 0 ? "empty" : "too long" );
+    CG_Printf( _("File %s is %s\n"), filename, len == 0 ? _("empty") : _("too long") );
     return qfalse;
   }
 
@@ -170,7 +170,7 @@ static qboolean CG_ParseWeaponAnimationFile( const char *filename, weaponInfo_t
 
   if( i != MAX_WEAPON_ANIMATIONS )
   {
-    CG_Printf( "Error parsing animation file: %s\n", filename );
+    CG_Printf( _("Error parsing animation file: %s\n"), filename );
     return qfalse;
   }
 
@@ -210,7 +210,7 @@ static qboolean CG_ParseWeaponModeSection( weaponInfoMode_t *wim, char **text_p
       wim->missileModel = trap_R_RegisterModel( token );
 
       if( !wim->missileModel )
-        CG_Printf( S_COLOR_RED "ERROR: missile model not found %s\n", token );
+        CG_Printf( _(S_COLOR_RED "ERROR: missile model not found %s\n"), token );
 
       continue;
     }
@@ -236,7 +236,7 @@ static qboolean CG_ParseWeaponModeSection( weaponInfoMode_t *wim, char **text_p
       wim->usesSpriteMissle = qtrue;
 
       if( !wim->missileSprite )
-        CG_Printf( S_COLOR_RED "ERROR: missile sprite not found %s\n", token );
+        CG_Printf( _(S_COLOR_RED "ERROR: missile sprite not found %s\n"), token );
 
       continue;
     }
@@ -295,7 +295,7 @@ static qboolean CG_ParseWeaponModeSection( weaponInfoMode_t *wim, char **text_p
       wim->missileParticleSystem = CG_RegisterParticleSystem( token );
 
       if( !wim->missileParticleSystem )
-        CG_Printf( S_COLOR_RED "ERROR: missile particle system not found %s\n", token );
+        CG_Printf( _(S_COLOR_RED "ERROR: missile particle system not found %s\n"), token );
 
       continue;
     }
@@ -308,7 +308,7 @@ static qboolean CG_ParseWeaponModeSection( weaponInfoMode_t *wim, char **text_p
       wim->missileTrailSystem = CG_RegisterTrailSystem( token );
 
       if( !wim->missileTrailSystem )
-        CG_Printf( S_COLOR_RED "ERROR: missile trail system not found %s\n", token );
+        CG_Printf( _(S_COLOR_RED "ERROR: missile trail system not found %s\n"), token );
 
       continue;
     }
@@ -321,7 +321,7 @@ static qboolean CG_ParseWeaponModeSection( weaponInfoMode_t *wim, char **text_p
       wim->muzzleParticleSystem = CG_RegisterParticleSystem( token );
 
       if( !wim->muzzleParticleSystem )
-        CG_Printf( S_COLOR_RED "ERROR: muzzle particle system not found %s\n", token );
+        CG_Printf( _(S_COLOR_RED "ERROR: muzzle particle system not found %s\n"), token );
 
       continue;
     }
@@ -334,7 +334,7 @@ static qboolean CG_ParseWeaponModeSection( weaponInfoMode_t *wim, char **text_p
       wim->impactParticleSystem = CG_RegisterParticleSystem( token );
 
       if( !wim->impactParticleSystem )
-        CG_Printf( S_COLOR_RED "ERROR: impact particle system not found %s\n", token );
+        CG_Printf( _(S_COLOR_RED "ERROR: impact particle system not found %s\n"), token );
 
       continue;
     }
@@ -359,7 +359,7 @@ static qboolean CG_ParseWeaponModeSection( weaponInfoMode_t *wim, char **text_p
       wim->impactMarkSize = size;
 
       if( !wim->impactMark )
-        CG_Printf( S_COLOR_RED "ERROR: impact mark shader not found %s\n", token );
+        CG_Printf( _(S_COLOR_RED "ERROR: impact mark shader not found %s\n"), token );
 
       continue;
     }
@@ -511,7 +511,7 @@ static qboolean CG_ParseWeaponModeSection( weaponInfoMode_t *wim, char **text_p
       return qtrue; //reached the end of this weapon section
     else
     {
-      CG_Printf( S_COLOR_RED "ERROR: unknown token '%s' in weapon section\n", token );
+      CG_Printf( _(S_COLOR_RED "ERROR: unknown token '%s' in weapon section\n"), token );
       return qfalse;
     }
   }
@@ -544,7 +544,7 @@ static qboolean CG_ParseWeaponFile( const char *filename, weaponInfo_t *wi )
   if( len == 0 || len >= sizeof( text ) - 1 )
   {
     trap_FS_FCloseFile( f );
-    CG_Printf( "File %s is %s\n", filename, len == 0 ? "empty" : "too long" );
+    CG_Printf( _("File %s is %s\n"), filename, len == 0 ? _("empty") : _("too long") );
     return qfalse;
   }
 
@@ -570,12 +570,12 @@ static qboolean CG_ParseWeaponFile( const char *filename, weaponInfo_t *wi )
     {
       if( weaponMode == WPM_NONE )
       {
-        CG_Printf( S_COLOR_RED "ERROR: weapon mode section started without a declaration\n" );
+        CG_Printf( _(S_COLOR_RED "ERROR: weapon mode section started without a declaration\n") );
         return qfalse;
       }
       else if( !CG_ParseWeaponModeSection( &wi->wim[ weaponMode ], &text_p ) )
       {
-        CG_Printf( S_COLOR_RED "ERROR: failed to parse weapon mode section\n" );
+        CG_Printf( _(S_COLOR_RED "ERROR: failed to parse weapon mode section\n") );
         return qfalse;
       }
 
@@ -610,7 +610,7 @@ static qboolean CG_ParseWeaponFile( const char *filename, weaponInfo_t *wi )
       wi->weaponModel = trap_R_RegisterModel( token );
 
       if( !wi->weaponModel )
-        CG_Printf( S_COLOR_RED "ERROR: weapon model not found %s\n", token );
+        CG_Printf( _(S_COLOR_RED "ERROR: weapon model not found %s\n"), token );
 
       strcpy( path, token );
       COM_StripExtension( path, path, MAX_QPATH );
@@ -641,8 +641,8 @@ static qboolean CG_ParseWeaponFile( const char *filename, weaponInfo_t *wi )
 
       if( !wi->weaponModel3rdPerson )
       {
-        CG_Printf( S_COLOR_RED "ERROR: 3rd person weapon "
-            "model not found %s\n", token );
+        CG_Printf( _(S_COLOR_RED "ERROR: 3rd person weapon "
+            "model not found %s\n"), token );
       }
 
       strcpy( path, token );
@@ -676,7 +676,7 @@ static qboolean CG_ParseWeaponFile( const char *filename, weaponInfo_t *wi )
       wi->weaponIcon = wi->ammoIcon = trap_R_RegisterShader( token );
 
       if( !wi->weaponIcon )
-        CG_Printf( S_COLOR_RED "ERROR: weapon icon not found %s\n", token );
+        CG_Printf( _(S_COLOR_RED "ERROR: weapon icon not found %s\n"), token );
 
       continue;
     }
@@ -701,7 +701,7 @@ static qboolean CG_ParseWeaponFile( const char *filename, weaponInfo_t *wi )
       wi->crossHairSize = size;
 
       if( !wi->crossHair )
-        CG_Printf( S_COLOR_RED "ERROR: weapon crosshair not found %s\n", token );
+        CG_Printf( _(S_COLOR_RED "ERROR: weapon crosshair not found %s\n"), token );
 
       continue;
     }
@@ -712,7 +712,7 @@ static qboolean CG_ParseWeaponFile( const char *filename, weaponInfo_t *wi )
       continue;
     }
 
-    Com_Printf( S_COLOR_RED "ERROR: unknown token '%s'\n", token );
+    Com_Printf( _(S_COLOR_RED "ERROR: unknown token '%s'\n"), token );
     return qfalse;
   }
 
@@ -743,19 +743,19 @@ void CG_RegisterWeapon( int weaponNum )
   weaponInfo->registered = qtrue;
 
   if( strlen( BG_Weapon( weaponNum )->name ) <= 0 )
-    CG_Error( "Couldn't find weapon %i", weaponNum );
+    CG_Error( _("Couldn't find weapon %i"), weaponNum );
 
   Com_sprintf( path, MAX_QPATH, "models/weapons/%s/weapon.cfg", BG_Weapon( weaponNum )->name );
 
   weaponInfo->humanName = BG_Weapon( weaponNum )->humanName;
 
   if( !CG_ParseWeaponFile( path, weaponInfo ) )
-    Com_Printf( S_COLOR_RED "ERROR: failed to parse %s\n", path );
+    Com_Printf( _(S_COLOR_RED "ERROR: failed to parse %s\n"), path );
 
   Com_sprintf( path, MAX_QPATH, "models/weapons/%s/animation.cfg", BG_Weapon( weaponNum )->name );
 
   if( !CG_ParseWeaponAnimationFile( path, weaponInfo ) )
-    Com_Printf( S_COLOR_RED "ERROR: failed to parse %s\n", path );
+    Com_Printf( _(S_COLOR_RED "ERROR: failed to parse %s\n"), path );
 
   // calc midpoint for rotation
   trap_R_ModelBounds( weaponInfo->weaponModel, mins, maxs );
@@ -810,7 +810,7 @@ static void CG_SetWeaponLerpFrameAnimation( weapon_t weapon, lerpFrame_t *lf, in
   newAnimation &= ~ANIM_TOGGLEBIT;
 
   if( newAnimation < 0 || newAnimation >= MAX_WEAPON_ANIMATIONS )
-    CG_Error( "Bad animation number: %i", newAnimation );
+    CG_Error( _("Bad animation number: %i"), newAnimation );
 
   anim = &cg_weapons[ weapon ].animations[ newAnimation ];
 
@@ -818,7 +818,7 @@ static void CG_SetWeaponLerpFrameAnimation( weapon_t weapon, lerpFrame_t *lf, in
   lf->animationTime = lf->frameTime + anim->initialLerp;
 
   if( cg_debugAnim.integer )
-    CG_Printf( "Anim: %i\n", newAnimation );
+    CG_Printf( _("Anim: %i\n"), newAnimation );
 }
 
 /*
@@ -1698,7 +1698,7 @@ void CG_FireWeapon( centity_t *cent, weaponMode_t weaponMode )
 
   if( weaponNum >= WP_NUM_WEAPONS )
   {
-    CG_Error( "CG_FireWeapon: ent->weapon >= WP_NUM_WEAPONS" );
+    CG_Error( _("CG_FireWeapon: ent->weapon >= WP_NUM_WEAPONS") );
     return;
   }
 
diff --git a/src/client/cl_avi.c b/src/client/cl_avi.c
index c968052..67ea4d2 100644
--- a/src/client/cl_avi.c
+++ b/src/client/cl_avi.c
@@ -82,7 +82,7 @@ SafeFS_Write
 static ID_INLINE void SafeFS_Write( const void *buffer, int len, fileHandle_t f )
 {
   if( FS_Write( buffer, len, f ) < len )
-    Com_Error( ERR_DROP, "Failed to write avi file\n" );
+    Com_Error( ERR_DROP, _("Failed to write avi file\n") );
 }
 
 /*
@@ -142,7 +142,7 @@ static ID_INLINE void START_CHUNK( const char *s )
 {
   if( afd.chunkStackTop == MAX_RIFF_CHUNKS )
   {
-    Com_Error( ERR_DROP, "ERROR: Top of chunkstack breached\n" );
+    Com_Error( ERR_DROP, _("ERROR: Top of chunkstack breached\n") );
   }
 
   afd.chunkStack[ afd.chunkStackTop ] = bufIndex;
@@ -162,7 +162,7 @@ static ID_INLINE void END_CHUNK( void )
 
   if( afd.chunkStackTop <= 0 )
   {
-    Com_Error( ERR_DROP, "ERROR: Bottom of chunkstack breached\n" );
+    Com_Error( ERR_DROP, _("ERROR: Bottom of chunkstack breached\n") );
   }
 
   afd.chunkStackTop--;
@@ -384,8 +384,8 @@ qboolean CL_OpenAVIForWriting( const char *fileName )
     while( ( afd.a.rate % suggestRate ) && suggestRate >= 1 )
       suggestRate--;
 
-    Com_Printf( S_COLOR_YELLOW "WARNING: cl_aviFrameRate is not a divisor "
-        "of the audio rate, suggest %d\n", suggestRate );
+    Com_Printf( _(S_COLOR_YELLOW "WARNING: cl_aviFrameRate is not a divisor "
+        "of the audio rate, suggest %d\n"), suggestRate );
   }
 
   if( !Cvar_VariableIntegerValue( "s_initsound" ) )
@@ -396,7 +396,7 @@ qboolean CL_OpenAVIForWriting( const char *fileName )
   {
     if( afd.a.bits != 16 || afd.a.channels != 2 )
     {
-      Com_Printf( S_COLOR_YELLOW "WARNING: Audio format of %d bit/%d channels not supported",
+      Com_Printf( _(S_COLOR_YELLOW "WARNING: Audio format of %d bit/%d channels not supported"),
           afd.a.bits, afd.a.channels );
       afd.audio = qfalse;
     }
@@ -406,8 +406,8 @@ qboolean CL_OpenAVIForWriting( const char *fileName )
   else
   {
     afd.audio = qfalse;
-    Com_Printf( S_COLOR_YELLOW "WARNING: Audio capture is not supported "
-        "with OpenAL. Set s_useOpenAL to 0 for audio capture\n" );
+    Com_Printf( _(S_COLOR_YELLOW "WARNING: Audio capture is not supported "
+        "with OpenAL. Set s_useOpenAL to 0 for audio capture\n") );
   }
 
   // This doesn't write a real header, but allocates the
@@ -527,8 +527,8 @@ void CL_WriteAVIAudioFrame( const byte *pcmBuffer, int size )
 
   if( bytesInBuffer + size > PCM_BUFFER_SIZE )
   {
-    Com_Printf( S_COLOR_YELLOW
-        "WARNING: Audio capture buffer overflow -- truncating\n" );
+    Com_Printf( _(S_COLOR_YELLOW
+        "WARNING: Audio capture buffer overflow -- truncating\n") );
     size = PCM_BUFFER_SIZE - bytesInBuffer;
   }
 
@@ -655,7 +655,7 @@ qboolean CL_CloseAVI( void )
   Z_Free( afd.eBuffer );
   FS_FCloseFile( afd.f );
 
-  Com_Printf( "Wrote %d:%d frames to %s\n", afd.numVideoFrames, afd.numAudioFrames, afd.fileName );
+  Com_Printf( _("Wrote %d:%d frames to %s\n"), afd.numVideoFrames, afd.numAudioFrames, afd.fileName );
 
   return qtrue;
 }
diff --git a/src/client/cl_cgame.c b/src/client/cl_cgame.c
index 9f983cd..a5a7f2a 100644
--- a/src/client/cl_cgame.c
+++ b/src/client/cl_cgame.c
@@ -148,7 +148,7 @@ qboolean	CL_GetSnapshot( int snapshotNumber, snapshot_t *snapshot ) {
 	snapshot->ps = clSnap->ps;
 	count = clSnap->numEntities;
 	if ( count > MAX_ENTITIES_IN_SNAPSHOT ) {
-		Com_DPrintf( "CL_GetSnapshot: truncated %i entities to %i\n", count, MAX_ENTITIES_IN_SNAPSHOT );
+		Com_DPrintf( _("CL_GetSnapshot: truncated %i entities to %i\n"), count, MAX_ENTITIES_IN_SNAPSHOT );
 		count = MAX_ENTITIES_IN_SNAPSHOT;
 	}
 	snapshot->numEntities = count;
@@ -236,7 +236,7 @@ void CL_ConfigstringModified( void ) {
 		len = strlen( dup );
 
 		if ( len + 1 + cl.gameState.dataCount > MAX_GAMESTATE_CHARS ) {
-			Com_Error( ERR_DROP, "MAX_GAMESTATE_CHARS exceeded" );
+			Com_Error( ERR_DROP, _("MAX_GAMESTATE_CHARS exceeded") );
 		}
 
 		// append it to the gameState string buffer
@@ -272,12 +272,12 @@ qboolean CL_GetServerCommand( int serverCommandNumber ) {
 		// reliable commands then the client never got those first reliable commands
 		if ( clc.demoplaying )
 			return qfalse;
-		Com_Error( ERR_DROP, "CL_GetServerCommand: a reliable command was cycled out" );
+		Com_Error( ERR_DROP, _("CL_GetServerCommand: a reliable command was cycled out") );
 		return qfalse;
 	}
 
 	if ( serverCommandNumber > clc.serverCommandSequence ) {
-		Com_Error( ERR_DROP, "CL_GetServerCommand: requested a command not received" );
+		Com_Error( ERR_DROP, _("CL_GetServerCommand: requested a command not received") );
 		return qfalse;
 	}
 
@@ -295,9 +295,9 @@ rescan:
 		// https://zerowing.idsoftware.com/bugzilla/show_bug.cgi?id=552
 		// allow server to indicate why they were disconnected
 		if ( argc >= 2 )
-			Com_Error( ERR_SERVERDISCONNECT, "Server disconnected - %s", Cmd_Argv( 1 ) );
+			Com_Error( ERR_SERVERDISCONNECT, _("Server disconnected - %s"), Cmd_Argv( 1 ) );
 		else
-			Com_Error( ERR_SERVERDISCONNECT, "Server disconnected\n" );
+			Com_Error( ERR_SERVERDISCONNECT, _("Server disconnected\n") );
 	}
 
 	if ( !strcmp( cmd, "bcs0" ) ) {
@@ -308,7 +308,7 @@ rescan:
 	if ( !strcmp( cmd, "bcs1" ) ) {
 		s = Cmd_Argv(2);
 		if( strlen(bigConfigString) + strlen(s) >= BIG_INFO_STRING ) {
-			Com_Error( ERR_DROP, "bcs exceeded BIG_INFO_STRING" );
+			Com_Error( ERR_DROP, _("bcs exceeded BIG_INFO_STRING") );
 		}
 		strcat( bigConfigString, s );
 		return qfalse;
@@ -317,7 +317,7 @@ rescan:
 	if ( !strcmp( cmd, "bcs2" ) ) {
 		s = Cmd_Argv(2);
 		if( strlen(bigConfigString) + strlen(s) + 1 >= BIG_INFO_STRING ) {
-			Com_Error( ERR_DROP, "bcs exceeded BIG_INFO_STRING" );
+			Com_Error( ERR_DROP, _("bcs exceeded BIG_INFO_STRING") );
 		}
 		strcat( bigConfigString, s );
 		strcat( bigConfigString, "\"" );
@@ -737,9 +737,37 @@ intptr_t CL_CgameSystemCalls( intptr_t *args ) {
 	case CG_R_INPVS:
 		return re.inPVS( VMA(1), VMA(2) );
 
+  case CG_GETTEXT:
+    strncpy( VMA(1), _(VMA(2)), args[3] );
+    return 0;
+
+  case CG_R_LOADFACE:
+    re.LoadFace( VMA(1), args[2], VMA(3), VMA(4) );
+    return 0;
+
+  case CG_R_FREEFACE:
+    re.FreeFace( VMA(1) );
+    return 0;
+
+  case CG_R_LOADGLYPH:
+    re.LoadGlyph( VMA(1), VMA(2), args[3], VMA(4) );
+    break;
+
+  case CG_R_FREEGLYPH:
+    re.FreeGlyph( VMA(1), args[2], VMA(3) );
+    break;
+
+  case CG_R_GLYPH:
+    re.Glyph( VMA(1), VMA(2), VMA(3), VMA(4) );
+    break;
+
+  case CG_R_FREECACHEDGLYPHS:
+    re.FreeCachedGlyphs( VMA(1) );
+    break;
+
 	default:
 	        assert(0);
-		Com_Error( ERR_DROP, "Bad cgame system trap: %ld", (long int) args[0] );
+		Com_Error( ERR_DROP, _("Bad cgame system trap: %ld"), (long int) args[0] );
 	}
 	return 0;
 }
@@ -778,7 +806,7 @@ void CL_InitCGame( void ) {
 	}
 	cgvm = VM_Create( "cgame", CL_CgameSystemCalls, interpret );
 	if ( !cgvm ) {
-		Com_Error( ERR_DROP, "VM_Create on cgame failed" );
+		Com_Error( ERR_DROP, _("VM_Create on cgame failed") );
 	}
 	cls.state = CA_LOADING;
 
@@ -797,7 +825,7 @@ void CL_InitCGame( void ) {
 
 	t2 = Sys_Milliseconds();
 
-	Com_Printf( "CL_InitCGame: %5.2f seconds\n", (t2-t1)/1000.0 );
+	Com_Printf( _("CL_InitCGame: %5.2f seconds\n"), (t2-t1)/1000.0 );
 
 	// have the renderer touch all its images, so they are present
 	// on the card even if the driver does deferred loading
@@ -963,7 +991,7 @@ void CL_FirstSnapshot( void ) {
 #ifdef USE_MUMBLE
 	if ((cl_useMumble->integer) && !mumble_islinked()) {
 		int ret = mumble_link(CLIENT_WINDOW_TITLE);
-		Com_Printf("Mumble: Linking to Mumble application %s\n", ret==0?"ok":"failed");
+		Com_Printf(_("Mumble: Linking to Mumble application %s\n"), ret==0?"ok":"failed");
 	}
 #endif
 
diff --git a/src/client/cl_cin.c b/src/client/cl_cin.c
index f1fde54..d8e865f 100644
--- a/src/client/cl_cin.c
+++ b/src/client/cl_cin.c
@@ -157,7 +157,7 @@ static int CIN_HandleForVideo(void) {
 			return i;
 		}
 	}
-	Com_Error( ERR_DROP, "CIN_HandleForVideo: none free" );
+	Com_Error( ERR_DROP, _("CIN_HandleForVideo: none free") );
 	return -1;
 }
 
@@ -1004,7 +1004,7 @@ static void readQuadInfo( byte *qData )
                         cinTable[currentHandle].drawY = 256;
                 }
 		if (cinTable[currentHandle].CIN_WIDTH != 256 || cinTable[currentHandle].CIN_HEIGHT != 256) {
-			Com_Printf("HACK: approxmimating cinematic for Rage Pro or Voodoo\n");
+			Com_Printf(_("HACK: approxmimating cinematic for Rage Pro or Voodoo\n"));
 		}
 	}
 }
@@ -1271,7 +1271,7 @@ static void RoQShutdown( void ) {
 	if ( cinTable[currentHandle].status == FMV_IDLE ) {
 		return;
 	}
-	Com_DPrintf("finished cinematic\n");
+	Com_DPrintf(_("finished cinematic\n"));
 	cinTable[currentHandle].status = FMV_IDLE;
 
 	if (cinTable[currentHandle].iFile) {
diff --git a/src/client/cl_console.c b/src/client/cl_console.c
index 88ced07..bc330e4 100644
--- a/src/client/cl_console.c
+++ b/src/client/cl_console.c
@@ -30,11 +30,12 @@ int g_console_field_width = 78;
 
 #define	NUM_CON_TIMES 4
 
-#define		CON_TEXTSIZE	163840
+#define		CON_TEXTSIZE	32768
 typedef struct {
 	qboolean	initialized;
 
-	short	text[CON_TEXTSIZE];
+	char  text[CON_TEXTSIZE];
+	char  tcolor[CON_TEXTSIZE];
 	int		current;		// line where next message will be printed
 	int		x;				// offset in current line for next print
 	int		display;		// bottom of console displays this line
@@ -60,9 +61,6 @@ cvar_t		*con_conspeed;
 
 #define	DEFAULT_CONSOLE_WIDTH	78
 
-vec4_t	console_color = {1.0, 1.0, 1.0, 1.0};
-
-
 /*
 ================
 Con_ToggleConsole_f
@@ -89,7 +87,8 @@ void Con_Clear_f (void) {
 	int		i;
 
 	for ( i = 0 ; i < CON_TEXTSIZE ; i++ ) {
-		con.text[i] = (ColorIndex(COLOR_WHITE)<<8) | ' ';
+    con.text[i] = ' ';
+    con.tcolor[i] = ColorIndex(COLOR_WHITE);
 	}
 
 	Con_Bottom();		// go to end
@@ -105,23 +104,23 @@ Save the console contents out to a file
 */
 void Con_Dump_f (void)
 {
-	int		l, x, i;
-	short	*line;
+	int		l, x;
+	char  *line;
 	fileHandle_t	f;
 	char	buffer[1024];
 
 	if (Cmd_Argc() != 2)
 	{
-		Com_Printf ("usage: condump <filename>\n");
+		Com_Printf (_("usage: condump <filename>\n"));
 		return;
 	}
 
-	Com_Printf ("Dumped console text to %s.\n", Cmd_Argv(1) );
+	Com_Printf (_("Dumped console text to %s.\n"), Cmd_Argv(1) );
 
 	f = FS_FOpenFileWrite( Cmd_Argv( 1 ) );
 	if (!f)
 	{
-		Com_Printf ("ERROR: couldn't open.\n");
+		Com_Printf (_("ERROR: couldn't open.\n"));
 		return;
 	}
 
@@ -130,7 +129,7 @@ void Con_Dump_f (void)
 	{
 		line = con.text + (l%con.totallines)*con.linewidth;
 		for (x=0 ; x<con.linewidth ; x++)
-			if ((line[x] & 0xff) != ' ')
+			if (line[x] != ' ')
 				break;
 		if (x != con.linewidth)
 			break;
@@ -141,8 +140,7 @@ void Con_Dump_f (void)
 	for ( ; l <= con.current ; l++)
 	{
 		line = con.text + (l%con.totallines)*con.linewidth;
-		for(i=0; i<con.linewidth; i++)
-			buffer[i] = line[i] & 0xff;
+    Com_Memcpy( buffer, line, con.linewidth );
 		for (x=con.linewidth-1 ; x>=0 ; x--)
 		{
 			if (buffer[x] == ' ')
@@ -179,8 +177,9 @@ If the line width has changed, reformat the buffer.
 */
 void Con_CheckResize (void)
 {
-	int		i, j, width, oldwidth, oldtotallines, numlines, numchars;
-	short	tbuf[CON_TEXTSIZE];
+	int  i, j, width, oldwidth, oldtotallines, numlines, numchars;
+	char tbuf[CON_TEXTSIZE];
+	char cbuf[CON_TEXTSIZE];
 
 	width = (SCREEN_WIDTH / SMALLCHAR_WIDTH) - 2;
 
@@ -193,8 +192,10 @@ void Con_CheckResize (void)
 		con.linewidth = width;
 		con.totallines = CON_TEXTSIZE / con.linewidth;
 		for(i=0; i<CON_TEXTSIZE; i++)
-
-			con.text[i] = (ColorIndex(COLOR_WHITE)<<8) | ' ';
+    {
+      con.text[i] = ' ';
+      con.tcolor[i] = ColorIndex(COLOR_WHITE);
+    }
 	}
 	else
 	{
@@ -212,10 +213,13 @@ void Con_CheckResize (void)
 		if (con.linewidth < numchars)
 			numchars = con.linewidth;
 
-		Com_Memcpy (tbuf, con.text, CON_TEXTSIZE * sizeof(short));
+		Com_Memcpy (tbuf, con.text, CON_TEXTSIZE);
+		Com_Memcpy (cbuf, con.tcolor, CON_TEXTSIZE);
 		for(i=0; i<CON_TEXTSIZE; i++)
-
-			con.text[i] = (ColorIndex(COLOR_WHITE)<<8) | ' ';
+    {
+      con.text[i] = ' ';
+      con.tcolor[i] = ColorIndex(COLOR_WHITE);
+    }
 
 
 		for (i=0 ; i<numlines ; i++)
@@ -225,6 +229,9 @@ void Con_CheckResize (void)
 				con.text[(con.totallines - 1 - i) * con.linewidth + j] =
 						tbuf[((con.current - i + oldtotallines) %
 							  oldtotallines) * oldwidth + j];
+				con.tcolor[(con.totallines - 1 - i) * con.linewidth + j] =
+						cbuf[((con.current - i + oldtotallines) %
+							  oldtotallines) * oldwidth + j];
 			}
 		}
 	}
@@ -284,7 +291,10 @@ void Con_Linefeed (qboolean skipnotify)
 		con.display++;
 	con.current++;
 	for(i=0; i<con.linewidth; i++)
-		con.text[(con.current%con.totallines)*con.linewidth+i] = (ColorIndex(COLOR_WHITE)<<8) | ' ';
+  {
+		con.text[(con.current%con.totallines)*con.linewidth+i] = ' ';
+		con.tcolor[(con.current%con.totallines)*con.linewidth+i] = ColorIndex(COLOR_WHITE);
+  }
 }
 
 /*
@@ -371,7 +381,8 @@ void CL_ConsolePrint( char *txt ) {
 			break;
 		default:	// display character and advance
 			y = con.current % con.totallines;
-			con.text[y*con.linewidth+con.x] = (color << 8) | c;
+			con.text[y*con.linewidth+con.x] = c;
+			con.tcolor[y*con.linewidth+con.x] = color;
 			con.x++;
 			if (con.x >= con.linewidth) {
 				Con_Linefeed(skipnotify);
@@ -406,14 +417,14 @@ void Con_DrawInput (void) {
 		return;
 	}
 
-	y = con.vislines - ( SMALLCHAR_HEIGHT * 2 );
+	y = con.vislines - ( SCR_ConsoleFontCharHeight() * 2 ) + 2 ;
 
 	re.SetColor( con.color );
 
-	SCR_DrawSmallChar( con.xadjust + 1 * SMALLCHAR_WIDTH, y, ']' );
+	SCR_DrawConsoleFontChar( con.xadjust + cl_conXOffset->integer, y, "]" );
 
-	Field_Draw( &g_consoleField, con.xadjust + 2 * SMALLCHAR_WIDTH, y,
-		SCREEN_WIDTH - 3 * SMALLCHAR_WIDTH, qtrue, qtrue );
+	Field_Draw( &g_consoleField, con.xadjust + cl_conXOffset->integer + SCR_ConsoleFontCharWidth("]"), y,
+		SCREEN_WIDTH - 3 * SCR_ConsoleFontCharWidth(" "), qtrue, qtrue );
 }
 
 /*
@@ -426,12 +437,15 @@ Draws the console with the solid background
 void Con_DrawSolidConsole( float frac ) {
 	int				i, x, y;
 	int				rows;
-	short			*text;
+	char      *text;
+	char      *tcolor;
 	int				row;
 	int				lines;
 //	qhandle_t		conShader;
 	int				currentColor;
 	vec4_t			color;
+    char            *s, *end;
+	float           totalWidth, currentWidthLocation;
 
 	lines = cls.glconfig.vidHeight * frac;
 	if (lines <= 0)
@@ -444,6 +458,20 @@ void Con_DrawSolidConsole( float frac ) {
 	con.xadjust = 0;
 	SCR_AdjustFrom640( &con.xadjust, NULL, NULL, NULL );
 
+    // read from cl_consoleColor, default to black on failure
+	s = cl_consoleColor->string;
+    for( i=0; i<4; i++)
+    {
+        color[ i ] = strtod( s, &end );
+        if( s == end) //no digits read
+        {
+            if( i < 3 ) color[ i ] = 0.0;
+            else color [ i ] = 1.0;
+        }
+        else
+            s = end;
+    }
+
 	// draw the background
 	y = frac * SCREEN_HEIGHT;
 	if ( y < 1 ) {
@@ -451,44 +479,48 @@ void Con_DrawSolidConsole( float frac ) {
 	}
 	else {
 		SCR_DrawPic( 0, 0, SCREEN_WIDTH, y, cls.consoleShader );
+        re.SetColor( color );
+        SCR_DrawPic( 0, 0, SCREEN_WIDTH, y, cls.consoleShader );
+        re.SetColor( NULL );
 	}
 
 	color[0] = 1;
 	color[1] = 0;
 	color[2] = 0;
-	color[3] = 1;
 	SCR_FillRect( 0, y, SCREEN_WIDTH, 2, color );
 
 
 	// draw the version number
 
 	re.SetColor( g_color_table[ColorIndex(COLOR_RED)] );
+    totalWidth = SCR_ConsoleFontStringWidth( Q3_VERSION, i ) + cl_conXOffset->integer;
+    currentWidthLocation = 0;
 
 	i = strlen( Q3_VERSION );
 
 	for (x=0 ; x<i ; x++) {
 		SCR_DrawSmallChar( cls.glconfig.vidWidth - ( i - x + 1 ) * SMALLCHAR_WIDTH,
-			lines - SMALLCHAR_HEIGHT, Q3_VERSION[x] );
+			lines - SMALLCHAR_HEIGHT, &Q3_VERSION[x] );
 	}
 
 
 	// draw the text
 	con.vislines = lines;
-	rows = (lines-SMALLCHAR_WIDTH)/SMALLCHAR_WIDTH;		// rows of text to draw
+	rows = (lines)/SCR_ConsoleFontCharHeight();		// rows of text to draw
 
-	y = lines - (SMALLCHAR_HEIGHT*3);
+	y = lines - (SCR_ConsoleFontCharHeight()*3);
 
 	// draw from the bottom up
 	if (con.display != con.current)
 	{
 	// draw arrows to show the buffer is backscrolled
-		re.SetColor( g_color_table[ColorIndex(COLOR_RED)] );
-		for (x=0 ; x<con.linewidth ; x+=4)
-			SCR_DrawSmallChar( con.xadjust + (x+1)*SMALLCHAR_WIDTH, y, '^' );
-		y -= SMALLCHAR_HEIGHT;
-		rows--;
+	    re.SetColor( g_color_table[ColorIndex(COLOR_RED)] );
+        for (x=0 ; x<con.linewidth ; x+=4)
+            SCR_DrawConsoleFontChar( con.xadjust + (x+1)*SMALLCHAR_WIDTH, y, "^" );
+        y -= SCR_ConsoleFontCharHeight();
+        rows--;
 	}
-	
+
 	row = con.display;
 
 	if ( con.x == 0 ) {
@@ -498,8 +530,10 @@ void Con_DrawSolidConsole( float frac ) {
 	currentColor = 7;
 	re.SetColor( g_color_table[currentColor] );
 
-	for (i=0 ; i<rows ; i++, y -= SMALLCHAR_HEIGHT, row--)
+	for (i=0 ; i<rows ; i++, y -= SCR_ConsoleFontCharHeight(), row--)
 	{
+		float currentWidthLocation;
+
 		if (row < 0)
 			break;
 		if (con.current - row >= con.totallines) {
@@ -508,18 +542,24 @@ void Con_DrawSolidConsole( float frac ) {
 		}
 
 		text = con.text + (row % con.totallines)*con.linewidth;
+		tcolor = con.tcolor + (row % con.totallines)*con.linewidth;
 
-		for (x=0 ; x<con.linewidth ; x++) {
-			if ( ( text[x] & 0xff ) == ' ' ) {
-				continue;
-			}
+    currentWidthLocation = cl_conXOffset->integer;
 
-			if ( ( (text[x]>>8)&7 ) != currentColor ) {
-				currentColor = (text[x]>>8)&7;
-				re.SetColor( g_color_table[currentColor] );
-			}
-			SCR_DrawSmallChar(  con.xadjust + (x+1)*SMALLCHAR_WIDTH, y, text[x] & 0xff );
-		}
+    x = 0;
+    while( x < con.linewidth )
+    {
+      if( ( tcolor[x] & 0x07 ) != currentColor )
+      {
+        currentColor = tcolor[x] & 0x07;
+        re.SetColor( g_color_table[currentColor] );
+      }
+
+      SCR_DrawConsoleFontChar( con.xadjust + currentWidthLocation, y, text + x );
+      currentWidthLocation += SCR_ConsoleFontCharWidth( text + x );
+
+      x += Q_UTF8Width( text + x);
+    }
 	}
 
 	// draw the input prompt, user text, and cursor if desired
@@ -567,7 +607,7 @@ Scroll it up or down
 void Con_RunConsole (void) {
 	// decide on the destination height of the console
 	if ( Key_GetCatcher( ) & KEYCATCH_CONSOLE )
-		con.finalFrac = 0.5;		// half screen
+		con.finalFrac = MAX(0.10, 0.01 * cl_consoleHeight->integer);  // configured console percentage
 	else
 		con.finalFrac = 0;				// none visible
 	
diff --git a/src/client/cl_curl.c b/src/client/cl_curl.c
index 3a59f19..55edb43 100644
--- a/src/client/cl_curl.c
+++ b/src/client/cl_curl.c
@@ -70,13 +70,13 @@ static void *GPA(char *str)
 	rv = Sys_LoadFunction(cURLLib, str);
 	if(!rv)
 	{
-		Com_Printf("Can't load symbol %s\n", str);
+		Com_Printf(_("Can't load symbol %s\n"), str);
 		clc.cURLEnabled = qfalse;
 		return NULL;
 	}
 	else
 	{
-		Com_DPrintf("Loaded symbol %s (0x%p)\n", str, rv);
+		Com_DPrintf(_("Loaded symbol %s (0x%p)\n"), str, rv);
         return rv;
 	}
 }
@@ -94,7 +94,7 @@ qboolean CL_cURL_Init()
 		return qtrue;
 
 
-	Com_Printf("Loading \"%s\"...", cl_cURLLib->string);
+	Com_Printf(_("Loading \"%s\"..."), cl_cURLLib->string);
 	if( (cURLLib = Sys_LoadLibrary(cl_cURLLib->string)) == 0 )
 	{
 #ifdef _WIN32
@@ -146,10 +146,10 @@ qboolean CL_cURL_Init()
 	if(!clc.cURLEnabled)
 	{
 		CL_cURL_Shutdown();
-		Com_Printf("FAIL One or more symbols not found\n");
+		Com_Printf(_("FAIL One or more symbols not found\n"));
 		return qfalse;
 	}
-	Com_Printf("OK\n");
+	Com_Printf(_("OK\n"));
 
 	return qtrue;
 #else
@@ -229,7 +229,7 @@ static size_t CL_cURL_CallbackWrite(void *buffer, size_t size, size_t nmemb,
 void CL_cURL_BeginDownload( const char *localName, const char *remoteURL )
 {
 	clc.cURLUsed = qtrue;
-	Com_Printf("URL: %s\n", remoteURL);
+	Com_Printf(_("URL: %s\n"), remoteURL);
 	Com_DPrintf("***** CL_cURL_BeginDownload *****\n"
 		"Localname: %s\n"
 		"RemoteURL: %s\n"
@@ -257,8 +257,8 @@ void CL_cURL_BeginDownload( const char *localName, const char *remoteURL )
 	}
 	clc.download = FS_SV_FOpenFileWrite(clc.downloadTempName);
 	if(!clc.download) {
-		Com_Error(ERR_DROP, "CL_cURL_BeginDownload: failed to open "
-			"%s for writing\n", clc.downloadTempName);
+		Com_Error(ERR_DROP, _("CL_cURL_BeginDownload: failed to open "
+			"%s for writing\n"), clc.downloadTempName);
 		return;
 	}
 	qcurl_easy_setopt(clc.downloadCURL, CURLOPT_WRITEDATA, clc.download);
@@ -284,8 +284,8 @@ void CL_cURL_BeginDownload( const char *localName, const char *remoteURL )
 	if(!clc.downloadCURLM) {
 		qcurl_easy_cleanup(clc.downloadCURL);
 		clc.downloadCURL = NULL;
-		Com_Error(ERR_DROP, "CL_cURL_BeginDownload: qcurl_multi_init() "
-			"failed\n");
+		Com_Error(ERR_DROP, _("CL_cURL_BeginDownload: qcurl_multi_init() "
+			"failed\n"));
 		return;
 	}
 	qcurl_multi_add_handle(clc.downloadCURLM, clc.downloadCURL);
@@ -329,7 +329,7 @@ void CL_cURL_PerformDownload(void)
 
 		qcurl_easy_getinfo(msg->easy_handle, CURLINFO_RESPONSE_CODE,
 			&code);	
-		Com_Error(ERR_DROP, "Download Error: %s Code: %ld URL: %s",
+		Com_Error(ERR_DROP, _("Download Error: %s Code: %ld URL: %s"),
 			qcurl_easy_strerror(msg->data.result),
 			code, clc.downloadURL);
 	}
diff --git a/src/client/cl_input.c b/src/client/cl_input.c
index 2f06316..10566cc 100644
--- a/src/client/cl_input.c
+++ b/src/client/cl_input.c
@@ -94,7 +94,7 @@ void IN_KeyDown( kbutton_t *b ) {
 	} else if ( !b->down[1] ) {
 		b->down[1] = k;
 	} else {
-		Com_Printf ("Three keys down for a button!\n");
+		Com_Printf (_("Three keys down for a button!\n"));
 		return;
 	}
 	
@@ -389,7 +389,7 @@ Joystick values stay set until changed
 */
 void CL_JoystickEvent( int axis, int value, int time ) {
 	if ( axis < 0 || axis >= MAX_JOYSTICK_AXIS ) {
-		Com_Error( ERR_DROP, "CL_JoystickEvent: bad axis %i", axis );
+		Com_Error( ERR_DROP, _("CL_JoystickEvent: bad axis %i"), axis );
 	}
 	cl.joystickAxis[axis] = value;
 }
diff --git a/src/client/cl_keys.c b/src/client/cl_keys.c
index db8dfd8..e6c89f9 100644
--- a/src/client/cl_keys.c
+++ b/src/client/cl_keys.c
@@ -327,6 +327,10 @@ void Field_VariableSizeDraw( field_t *edit, int x, int y, int width, int size, q
 			if ( edit->scroll < 0 ) {
 				edit->scroll = 0;
 			}
+      while( Q_UTF8ContByte( edit->buffer[ edit->scroll ] ) && edit->scroll > 0 )
+      {
+        edit->scroll--;
+      }
 		}
 		prestep = edit->scroll;
 	}
@@ -335,6 +339,9 @@ void Field_VariableSizeDraw( field_t *edit, int x, int y, int width, int size, q
 		drawLen = len - prestep;
 	}
 
+  while( Q_UTF8ContByte( edit->buffer[ prestep + drawLen ] ) && prestep + drawLen < len )
+    drawLen++;
+
 	// extract <drawLen> characters from the field at <prestep>
 	if ( drawLen >= MAX_STRING_CHARS ) {
 		Com_Error( ERR_DROP, "drawLen >= MAX_STRING_CHARS" );
@@ -366,10 +373,13 @@ void Field_VariableSizeDraw( field_t *edit, int x, int y, int width, int size, q
 			cursorChar = 10;
 		}
 
-		i = drawLen - strlen( str );
+		i = drawLen - Q_UTF8Strlen( str );
 
-		if ( size == SMALLCHAR_WIDTH ) {
-			SCR_DrawSmallChar( x + ( edit->cursor - prestep - i ) * size, y, cursorChar );
+		if ( SMALLCHAR_WIDTH ) {
+            static char c;
+            float xlocation = x + SCR_ConsoleFontStringWidth( str, edit->cursor) ;
+            c = (char) cursorChar & 0x7F;
+            SCR_DrawConsoleFontChar( xlocation , y, &c );
 		} else {
 			str[0] = cursorChar;
 			str[1] = 0;
@@ -395,8 +405,9 @@ Field_Paste
 ================
 */
 void Field_Paste( field_t *edit ) {
-	char	*cbd;
-	int		pasteLen, i;
+	char *cbd;
+	int  width;
+	int	 pasteLen;
 
 	cbd = Sys_GetClipboardData();
 
@@ -406,8 +417,12 @@ void Field_Paste( field_t *edit ) {
 
 	// send as if typed, so insert / overstrike works properly
 	pasteLen = strlen( cbd );
-	for ( i = 0 ; i < pasteLen ; i++ ) {
-		Field_CharEvent( edit, cbd[i] );
+	while( pasteLen >= ( width = ( Q_UTF8Width( cbd ) > 0 ? Q_UTF8Width( cbd ) : 1 ) ) )
+	{
+		Field_CharEvent( edit, cbd );
+
+		cbd += width;
+		pasteLen -= width;
 	}
 
 	Z_Free( cbd );
@@ -424,7 +439,8 @@ Key events are used for non-printable characters, others are gotten from char ev
 =================
 */
 void Field_KeyDownEvent( field_t *edit, int key ) {
-	int		len;
+	int	len, width;
+  char *s;
 
 	// shift-insert is paste
 	if ( ( ( key == K_INS ) || ( key == K_KP_INS ) ) && keys[K_SHIFT].down ) {
@@ -434,24 +450,28 @@ void Field_KeyDownEvent( field_t *edit, int key ) {
 
 	key = tolower( key );
 	len = strlen( edit->buffer );
+  s = &edit->buffer[ edit->cursor ];
+  width = Q_UTF8Width( edit->buffer + edit->cursor );
 
 	switch ( key ) {
 		case K_DEL:
-			if ( edit->cursor < len ) {
+			if ( edit->cursor + width <= len ) {
 				memmove( edit->buffer + edit->cursor, 
-					edit->buffer + edit->cursor + 1, len - edit->cursor );
+					edit->buffer + edit->cursor + width, len - edit->cursor );
 			}
 			break;
 
 		case K_RIGHTARROW:
-			if ( edit->cursor < len ) {
-				edit->cursor++;
+			if ( edit->cursor + width <= len ) {
+				edit->cursor += width;
 			}
 			break;
 
 		case K_LEFTARROW:
-			if ( edit->cursor > 0 ) {
+			while ( edit->cursor > 0 ) {
 				edit->cursor--;
+        if( !Q_UTF8ContByte( edit->buffer[ edit->cursor ] ) )
+          break;
 			}
 			break;
 
@@ -460,8 +480,13 @@ void Field_KeyDownEvent( field_t *edit, int key ) {
 			break;
 
 		case K_END:
-			edit->cursor = len;
-			break;
+      edit->cursor = len;
+      while( s > edit->buffer && edit->cursor > 0 && Q_UTF8ContByte( *s ) )
+      {
+        edit->cursor--;
+        s--;
+      }
+      break;
 
 		case K_INS:
 			key_overstrikeMode = !key_overstrikeMode;
@@ -474,8 +499,10 @@ void Field_KeyDownEvent( field_t *edit, int key ) {
 	// Change scroll if cursor is no longer visible
 	if ( edit->cursor < edit->scroll ) {
 		edit->scroll = edit->cursor;
-	} else if ( edit->cursor >= edit->scroll + edit->widthInChars && edit->cursor <= len ) {
+	} else if ( edit->cursor >= edit->scroll + edit->widthInChars + Q_UTF8Width( edit->buffer + edit->scroll ) && edit->cursor <= len ) {
 		edit->scroll = edit->cursor - edit->widthInChars + 1;
+		while( Q_UTF8ContByte( edit->buffer[ edit->scroll ] && edit->scroll > 0 ) )
+      edit->scroll--;
 	}
 }
 
@@ -484,23 +511,24 @@ void Field_KeyDownEvent( field_t *edit, int key ) {
 Field_CharEvent
 ==================
 */
-void Field_CharEvent( field_t *edit, int ch ) {
-	int		len;
+void Field_CharEvent( field_t *edit, const char *s ) {
+	int len, width;
 
-	if ( ch == 'v' - 'a' + 1 ) {	// ctrl-v is paste
+	if ( *s == 'v' - 'a' + 1 ) {	// ctrl-v is paste
 		Field_Paste( edit );
 		return;
 	}
 
-	if ( ch == 'c' - 'a' + 1 ) {	// ctrl-c clears the field
+	if ( *s == 'c' - 'a' + 1 ) {	// ctrl-c clears the field
 		Field_Clear( edit );
 		return;
 	}
 
 	len = strlen( edit->buffer );
 
-	if ( ch == 'h' - 'a' + 1 )	{	// ctrl-h is backspace
-		if ( edit->cursor > 0 ) {
+	if ( *s == 'h' - 'a' + 1 )	{	// ctrl-h is backspace
+		while ( edit->cursor > 0 ) {
+      qboolean isContinue = Q_UTF8ContByte( edit->buffer[ edit->cursor - 1 ] );
 			memmove( edit->buffer + edit->cursor - 1, 
 				edit->buffer + edit->cursor, len + 1 - edit->cursor );
 			edit->cursor--;
@@ -508,17 +536,19 @@ void Field_CharEvent( field_t *edit, int ch ) {
 			{
 				edit->scroll--;
 			}
+      if( !isContinue )
+        break;
 		}
 		return;
 	}
 
-	if ( ch == 'a' - 'a' + 1 ) {	// ctrl-a is home
+	if ( *s == 'a' - 'a' + 1 ) {	// ctrl-a is home
 		edit->cursor = 0;
 		edit->scroll = 0;
 		return;
 	}
 
-	if ( ch == 'e' - 'a' + 1 ) {	// ctrl-e is end
+	if ( *s == 'e' - 'a' + 1 ) {	// ctrl-e is end
 		edit->cursor = len;
 		edit->scroll = edit->cursor - edit->widthInChars;
 		return;
@@ -527,28 +557,34 @@ void Field_CharEvent( field_t *edit, int ch ) {
 	//
 	// ignore any other non printable chars
 	//
-	if ( ch < 32 ) {
+	if ( *(unsigned char *)s < 32 ) {
 		return;
 	}
 
 	if ( key_overstrikeMode ) {	
 		if ( edit->cursor == MAX_EDIT_LINE - 1 )
 			return;
-		edit->buffer[edit->cursor] = ch;
+		edit->buffer[edit->cursor] = *s;
 		edit->cursor++;
 	} else {	// insert mode
-		if ( len == MAX_EDIT_LINE - 1 ) {
+    width = Q_UTF8Width( s );
+		if ( len == MAX_EDIT_LINE - 1 )
 			return; // all full
-		}
-		memmove( edit->buffer + edit->cursor + 1, 
-			edit->buffer + edit->cursor, len + 1 - edit->cursor );
-		edit->buffer[edit->cursor] = ch;
-		edit->cursor++;
+		if( edit->cursor + width >= MAX_EDIT_LINE )
+			return;
+    memmove( edit->buffer + edit->cursor + width, 
+      edit->buffer + edit->cursor, len + 1 - edit->cursor );
+
+    Com_Memcpy( edit->buffer + edit->cursor, s, width );
+    edit->cursor += width;
 	}
 
 
 	if ( edit->cursor >= edit->widthInChars ) {
-		edit->scroll++;
+    do
+    {
+      edit->scroll++;
+    } while( Q_UTF8ContByte( edit->buffer[ edit->scroll ] ) && edit->scroll < edit->cursor );
 	}
 
 	if ( edit->cursor == len + 1) {
@@ -885,14 +921,14 @@ void Key_Unbind_f (void)
 
 	if (Cmd_Argc() != 2)
 	{
-		Com_Printf ("unbind <key> : remove commands from a key\n");
+		Com_Printf (_("unbind <key> : remove commands from a key\n"));
 		return;
 	}
 	
 	b = Key_StringToKeynum (Cmd_Argv(1));
 	if (b==-1)
 	{
-		Com_Printf ("\"%s\" isn't a valid key\n", Cmd_Argv(1));
+		Com_Printf (_("\"%s\" isn't a valid key\n"), Cmd_Argv(1));
 		return;
 	}
 
@@ -928,13 +964,13 @@ void Key_Bind_f (void)
 
 	if (c < 2)
 	{
-		Com_Printf ("bind <key> [command] : attach a command to a key\n");
+		Com_Printf (_("bind <key> [command] : attach a command to a key\n"));
 		return;
 	}
 	b = Key_StringToKeynum (Cmd_Argv(1));
 	if (b==-1)
 	{
-		Com_Printf ("\"%s\" isn't a valid key\n", Cmd_Argv(1));
+		Com_Printf (_("\"%s\" isn't a valid key\n"), Cmd_Argv(1));
 		return;
 	}
 
@@ -943,7 +979,7 @@ void Key_Bind_f (void)
 		if (keys[b].binding)
 			Com_Printf ("\"%s\" = \"%s\"\n", Cmd_Argv(1), keys[b].binding );
 		else
-			Com_Printf ("\"%s\" is not bound\n", Cmd_Argv(1) );
+			Com_Printf (_("\"%s\" is not bound\n"), Cmd_Argv(1) );
 		return;
 	}
 	
@@ -1254,26 +1290,27 @@ CL_CharEvent
 Normal keyboard characters, already shifted / capslocked / etc
 ===================
 */
-void CL_CharEvent( int key ) {
+void CL_CharEvent( const char *key ) {
 	// delete is not a printable character and is
 	// otherwise handled by Field_KeyDownEvent
-	if ( key == 127 ) {
+	if ( *key == 127 ) {
 		return;
 	}
 
 	// distribute the key down event to the apropriate handler
 	if ( Key_GetCatcher( ) & KEYCATCH_CONSOLE )
-	{
 		Field_CharEvent( &g_consoleField, key );
-	}
 	else if ( Key_GetCatcher( ) & KEYCATCH_UI )
-	{
-		VM_Call( uivm, UI_KEY_EVENT, key | K_CHAR_FLAG, qtrue );
-	}
+		// VMs that don't support i18n distinguish between char and key events by looking at the 11th least significant bit.
+		// Patched vms look at the second least significant bit to determine whether the event is a char event, and at the third bit
+		// to determine the original 11th least significant bit of the key.
+		VM_Call( uivm, UI_KEY_EVENT, Q_UTF8Store( key ) | (1 << (K_CHAR_BIT - 1)),
+				(qtrue << KEYEVSTATE_DOWN) |
+        (qtrue << KEYEVSTATE_CHAR) |
+        ((Q_UTF8Store( key ) & (1 << (K_CHAR_BIT - 1))) >> ((K_CHAR_BIT - 1) - KEYEVSTATE_BIT)) |
+        (qtrue << KEYEVSTATE_SUP) );
 	else if ( cls.state == CA_DISCONNECTED )
-	{
 		Field_CharEvent( &g_consoleField, key );
-	}
 }
 
 
@@ -1370,7 +1407,7 @@ void CL_LoadConsoleHistory( void )
 	consoleSaveBufferSize = FS_FOpenFileRead( CONSOLE_HISTORY_FILE, &f, qfalse );
 	if( !f )
 	{
-		Com_Printf( "Couldn't read %s.\n", CONSOLE_HISTORY_FILE );
+		Com_Printf( _("Couldn't read %s.\n"), CONSOLE_HISTORY_FILE );
 		return;
 	}
 
@@ -1398,7 +1435,7 @@ void CL_LoadConsoleHistory( void )
 			text_p++;
 			if( numChars > ( strlen( consoleSaveBuffer ) -	( text_p - consoleSaveBuffer ) ) )
 			{
-				Com_DPrintf( S_COLOR_YELLOW "WARNING: probable corrupt history\n" );
+				Com_DPrintf( _(S_COLOR_YELLOW "WARNING: probable corrupt history\n") );
 				break;
 			}
 			Com_Memcpy( historyEditLines[ i ].buffer,
@@ -1417,7 +1454,7 @@ void CL_LoadConsoleHistory( void )
 		historyLine = nextHistoryLine = numLines;
 	}
 	else
-		Com_Printf( "Couldn't read %s.\n", CONSOLE_HISTORY_FILE );
+		Com_Printf( _("Couldn't read %s.\n"), CONSOLE_HISTORY_FILE );
 
 	FS_FCloseFile( f );
 }
@@ -1470,12 +1507,12 @@ void CL_SaveConsoleHistory( void )
 	f = FS_FOpenFileWrite( CONSOLE_HISTORY_FILE );
 	if( !f )
 	{
-		Com_Printf( "Couldn't write %s.\n", CONSOLE_HISTORY_FILE );
+		Com_Printf( _("Couldn't write %s.\n"), CONSOLE_HISTORY_FILE );
 		return;
 	}
 
 	if( FS_Write( consoleSaveBuffer, consoleSaveBufferSize, f ) < consoleSaveBufferSize )
-		Com_Printf( "Couldn't write %s.\n", CONSOLE_HISTORY_FILE );
+		Com_Printf( _("Couldn't write %s.\n"), CONSOLE_HISTORY_FILE );
 
 	FS_FCloseFile( f );
 }
diff --git a/src/client/cl_main.c b/src/client/cl_main.c
index 15df946..9b3f726 100644
--- a/src/client/cl_main.c
+++ b/src/client/cl_main.c
@@ -102,6 +102,14 @@ cvar_t	*cl_guidServerUniq;
 
 cvar_t	*cl_consoleKeys;
 
+cvar_t  *cl_consoleColor;
+cvar_t  *cl_consoleHeight;
+cvar_t  *cl_consoleFont;
+cvar_t  *cl_consoleFontSize;
+cvar_t  *cl_consoleFontKerning;
+cvar_t  *cl_consoleDynFont;
+
+
 clientActive_t		cl;
 clientConnection_t	clc;
 clientStatic_t		cls;
@@ -194,12 +202,12 @@ void CL_UpdateVoipIgnore(const char *idstr, qboolean ignore)
 			clc.voipIgnore[id] = ignore;
 			CL_AddReliableCommand(va("voip %s %d",
 			                         ignore ? "ignore" : "unignore", id), qfalse);
-			Com_Printf("VoIP: %s ignoring player #%d\n",
+			Com_Printf(("VoIP: %s ignoring player #%d\n"),
 			            ignore ? "Now" : "No longer", id);
 			return;
 		}
 	}
-	Com_Printf("VoIP: invalid player ID#\n");
+	Com_Printf(_("VoIP: invalid player ID#\n"));
 }
 
 static
@@ -211,7 +219,7 @@ void CL_UpdateVoipGain(const char *idstr, float gain)
 			gain = 0.0f;
 		if ((id >= 0) && (id < MAX_CLIENTS)) {
 			clc.voipGain[id] = gain;
-			Com_Printf("VoIP: player #%d gain now set to %f\n", id, gain);
+			Com_Printf(_("VoIP: player #%d gain now set to %f\n"), id, gain);
 		}
 	}
 }
@@ -255,8 +263,8 @@ static void CL_VoipParseTargets( void )
       val = strtol( target, &end, 10 );
       assert( target != end );
       if( val < 0 || val >= MAX_CLIENTS )
-        Com_Printf( S_COLOR_YELLOW "WARNING: VoIP target %d is not a valid "
-                    "client number\n", val );
+        Com_Printf( _(S_COLOR_YELLOW "WARNING: VoIP target %d is not a valid "
+                    "client number\n"), val );
       else if( val < 31 )
         clc.voipTarget1 |= 1 << val;
       else if( ( val -= 31 ) < 31 )
@@ -281,7 +289,7 @@ void CL_Voip_f( void )
 		reason = "Server doesn't support VoIP";
 
 	if (reason != NULL) {
-		Com_Printf("VoIP: command ignored: %s\n", reason);
+		Com_Printf(_("VoIP: command ignored: %s\n"), reason);
 		return;
 	}
 
@@ -295,26 +303,26 @@ void CL_Voip_f( void )
 		} else if (Q_isanumber(Cmd_Argv(2))) {
 			int id = atoi(Cmd_Argv(2));
 			if (id >= 0 && id < MAX_CLIENTS) {
-				Com_Printf("VoIP: current gain for player #%d "
-					"is %f\n", id, clc.voipGain[id]);
+				Com_Printf(_("VoIP: current gain for player #%d "
+					"is %f\n"), id, clc.voipGain[id]);
 			} else {
-				Com_Printf("VoIP: invalid player ID#\n");
+				Com_Printf(_("VoIP: invalid player ID#\n"));
 			}
 		} else {
-			Com_Printf("usage: voip gain <playerID#> [value]\n");
+			Com_Printf(_("usage: voip gain <playerID#> [value]\n"));
 		}
 	} else if (strcmp(cmd, "muteall") == 0) {
-		Com_Printf("VoIP: muting incoming voice\n");
+		Com_Printf(_("VoIP: muting incoming voice\n"));
 		CL_AddReliableCommand("voip muteall", qfalse);
 		clc.voipMuteAll = qtrue;
 	} else if (strcmp(cmd, "unmuteall") == 0) {
-		Com_Printf("VoIP: unmuting incoming voice\n");
+		Com_Printf(_("VoIP: unmuting incoming voice\n"));
 		CL_AddReliableCommand("voip unmuteall", qfalse);
 		clc.voipMuteAll = qfalse;
 	} else {
-		Com_Printf("usage: voip [un]ignore <playerID#>\n"
-		           "       voip [un]muteall\n"
-		           "       voip gain <playerID#> [value]\n");
+		Com_Printf(_("usage: voip [un]ignore <playerID#>\n"
+		             "       voip [un]muteall\n"
+		             "       voip gain <playerID#> [value]\n"));
 	}
 }
 
@@ -471,7 +479,7 @@ void CL_CaptureVoip(void)
 				clc.voipOutgoingDataSize = wpos;
 				clc.voipOutgoingDataFrames = speexFrames;
 
-				Com_DPrintf("VoIP: Send %d frames, %d bytes, %f power\n",
+				Com_DPrintf(_("VoIP: Send %d frames, %d bytes, %f power\n"),
 				            speexFrames, wpos, clc.voipPower);
 
 				#if 0
@@ -526,7 +534,7 @@ void CL_AddReliableCommand(const char *cmd, qboolean isDisconnectCmd)
 		if(com_errorEntered)
 			return;
 		else
-			Com_Error(ERR_DROP, "Client command overflow");
+			Com_Error(ERR_DROP, _("Client command overflow"));
 	}
 
 	Q_strncpyz(clc.reliableCommands[++clc.reliableSequence & (MAX_RELIABLE_COMMANDS - 1)],
@@ -593,7 +601,7 @@ void CL_StopRecord_f( void ) {
 	int		len;
 
 	if ( !clc.demorecording ) {
-		Com_Printf ("Not recording a demo.\n");
+		Com_Printf (_("Not recording a demo.\n"));
 		return;
 	}
 
@@ -605,7 +613,7 @@ void CL_StopRecord_f( void ) {
 	clc.demofile = 0;
 	clc.demorecording = qfalse;
 	clc.spDemoRecording = qfalse;
-	Com_Printf ("Stopped demo.\n");
+	Com_Printf (_("Stopped demo.\n"));
 }
 
 /* 
@@ -658,19 +666,19 @@ void CL_Record_f( void ) {
 
 	if ( clc.demorecording ) {
 		if (!clc.spDemoRecording) {
-			Com_Printf ("Already recording.\n");
+			Com_Printf (_("Already recording.\n"));
 		}
 		return;
 	}
 
 	if ( cls.state != CA_ACTIVE ) {
-		Com_Printf ("You must be in a level to record.\n");
+		Com_Printf (_("You must be in a level to record.\n"));
 		return;
 	}
 
   // sync 0 doesn't prevent recording, so not forcing it off .. everyone does g_sync 1 ; record ; g_sync 0 ..
 	if ( NET_IsLocalAddress( clc.serverAddress ) && !Cvar_VariableValue( "g_synchronousClients" ) ) {
-		Com_Printf (S_COLOR_YELLOW "WARNING: You should set 'g_synchronousClients 1' for smoother demo recording\n");
+		Com_Printf (_(S_COLOR_YELLOW "WARNING: You should set 'g_synchronousClients 1' for smoother demo recording\n"));
 	}
 
 	if ( Cmd_Argc() == 2 ) {
@@ -692,10 +700,10 @@ void CL_Record_f( void ) {
 
 	// open the demo file
 
-	Com_Printf ("recording to %s.\n", name);
+	Com_Printf (_("recording to %s.\n"), name);
 	clc.demofile = FS_FOpenFileWrite( name );
 	if ( !clc.demofile ) {
-		Com_Printf ("ERROR: couldn't open.\n");
+		Com_Printf (_("ERROR: couldn't open.\n"));
 		return;
 	}
 	clc.demorecording = qtrue;
@@ -860,7 +868,7 @@ void CL_DemoCompleted( void )
 				}
 				else
 				{
-					Com_Printf( "Couldn't open %s for writing\n",
+					Com_Printf( _("Couldn't open %s for writing\n"),
 							cl_timedemoLog->string );
 				}
 			}
@@ -914,7 +922,7 @@ void CL_ReadDemoMessage( void ) {
 	}
 	r = FS_Read( buf.data, buf.cursize, clc.demofile );
 	if ( r != buf.cursize ) {
-		Com_Printf( "Demo file was truncated.\n");
+		Com_Printf( _("Demo file was truncated.\n"));
 		CL_DemoCompleted ();
 		return;
 	}
@@ -1012,7 +1020,7 @@ void CL_PlayDemo_f( void ) {
 			Com_sprintf (name, sizeof(name), "demos/%s", arg);
 			FS_FOpenFileRead( name, &clc.demofile, qtrue );
 		} else {
-			Com_Printf("Protocol %d not supported for demos\n", protocol);
+			Com_Printf(_("Protocol %d not supported for demos\n"), protocol);
 			Q_strncpyz(retry, arg, sizeof(retry));
 			retry[strlen(retry)-6] = 0;
 			CL_WalkDemoExt( retry, name, &clc.demofile );
@@ -1022,7 +1030,7 @@ void CL_PlayDemo_f( void ) {
 	}
 	
 	if (!clc.demofile) {
-		Com_Error( ERR_DROP, "couldn't open %s", name);
+		Com_Error( ERR_DROP, _("couldn't open %s"), name);
 		return;
 	}
 	Q_strncpyz( clc.demoName, Cmd_Argv(1), sizeof( clc.demoName ) );
@@ -1299,7 +1307,7 @@ void CL_Disconnect( qboolean showMainMenu ) {
 
 #ifdef USE_MUMBLE
 	if (cl_useMumble->integer && mumble_islinked()) {
-		Com_Printf("Mumble: Unlinking from Mumble application\n");
+		Com_Printf(_("Mumble: Unlinking from Mumble application\n"));
 		mumble_unlink();
 	}
 #endif
@@ -1399,7 +1407,7 @@ void CL_ForwardCommandToServer( const char *string ) {
 	}
 
 	if ( clc.demoplaying || cls.state < CA_CONNECTED || cmd[0] == '+' ) {
-		Com_Printf ("Unknown command \"%s" S_COLOR_WHITE "\"\n", cmd);
+		Com_Printf (_("Unknown command \"%s" S_COLOR_WHITE "\"\n"), cmd);
 		return;
 	}
 
@@ -1422,13 +1430,13 @@ void CL_RequestMotd( void ) {
 	if ( !cl_motd->integer ) {
 		return;
 	}
-	Com_Printf( "Resolving %s\n", MASTER_SERVER_NAME );
+	Com_Printf( _("Resolving %s\n"), MASTER_SERVER_NAME );
 
 	switch( NET_StringToAdr( MASTER_SERVER_NAME, &cls.updateServer,
 	                         NA_UNSPEC ) )
 	{
 		case 0:
-			Com_Printf( "Couldn't resolve master address\n" );
+			Com_Printf( _("Couldn't resolve master address\n") );
 			return;
 
 		case 2:
@@ -1437,7 +1445,7 @@ void CL_RequestMotd( void ) {
 			break;
 	}
 
-	Com_Printf( "%s resolved to %s\n", MASTER_SERVER_NAME,
+	Com_Printf( _("%s resolved to %s\n"), MASTER_SERVER_NAME,
 	            NET_AdrToStringwPort( cls.updateServer ) );
 
 	info[0] = 0;
@@ -1467,7 +1475,7 @@ CL_ForwardToServer_f
 */
 void CL_ForwardToServer_f( void ) {
 	if ( cls.state != CA_ACTIVE || clc.demoplaying ) {
-		Com_Printf ("Not connected to a server.\n");
+		Com_Printf (_("Not connected to a server.\n"));
 		return;
 	}
 	
@@ -1486,7 +1494,7 @@ void CL_Disconnect_f( void ) {
 	SCR_StopCinematic();
 	Cvar_Set("ui_singlePlayerActive", "0");
 	if ( cls.state != CA_DISCONNECTED && cls.state != CA_CINEMATIC ) {
-		Com_Error (ERR_DISCONNECT, "Disconnected from server");
+		Com_Error (ERR_DISCONNECT, _("Disconnected from server"));
 	}
 }
 
@@ -1499,7 +1507,7 @@ CL_Reconnect_f
 */
 void CL_Reconnect_f( void ) {
 	if ( !strlen( cls.servername ) || !strcmp( cls.servername, "localhost" ) ) {
-		Com_Printf( "Can't reconnect to localhost.\n" );
+		Com_Printf( _("Can't reconnect to localhost.\n") );
 		return;
 	}
 	Cvar_Set("ui_singlePlayerActive", "0");
@@ -1532,7 +1540,7 @@ void CL_Connect_f( void ) {
 		else if(!strcmp(Cmd_Argv(1), "-6"))
 			family = NA_IP6;
 		else
-			Com_Printf( "warning: only -4 or -6 as address type understood.\n");
+			Com_Printf( _("warning: only -4 or -6 as address type understood.\n"));
 		
 		server = Cmd_Argv(2);
 	}
@@ -1560,7 +1568,7 @@ void CL_Connect_f( void ) {
 	Q_strncpyz( cls.servername, server, sizeof(cls.servername) );
 
 	if (!NET_StringToAdr(cls.servername, &clc.serverAddress, family) ) {
-		Com_Printf ("Bad server address\n");
+		Com_Printf (_("Bad server address\n"));
 		cls.state = CA_DISCONNECTED;
 		return;
 	}
@@ -1570,7 +1578,7 @@ void CL_Connect_f( void ) {
 
 	serverString = NET_AdrToStringwPort(clc.serverAddress);
 
-	Com_Printf( "%s resolved to %s\n", cls.servername, serverString);
+	Com_Printf( _("%s resolved to %s\n"), cls.servername, serverString);
 
 	if( cl_guidServerUniq->integer )
 		CL_UpdateGUID( serverString, strlen( serverString ) );
@@ -1629,8 +1637,8 @@ void CL_Rcon_f( void ) {
 	netadr_t	to;
 
 	if ( !rcon_client_password->string ) {
-		Com_Printf ("You must set 'rconpassword' before\n"
-					"issuing an rcon command.\n");
+		Com_Printf (_("You must set 'rconpassword' before\n"
+					  "issuing an rcon command.\n"));
 		return;
 	}
 
@@ -1652,9 +1660,9 @@ void CL_Rcon_f( void ) {
 		to = clc.netchan.remoteAddress;
 	} else {
 		if (!strlen(rconAddress->string)) {
-			Com_Printf ("You must either be connected,\n"
-						"or set the 'rconAddress' cvar\n"
-						"to issue rcon commands\n");
+			Com_Printf (_("You must either be connected,\n"
+						  "or set the 'rconAddress' cvar\n"
+						  "to issue rcon commands\n"));
 
 			return;
 		}
@@ -1716,6 +1724,9 @@ void CL_Vid_Restart_f( void ) {
 	CL_ShutdownUI();
 	// shutdown the CGame
 	CL_ShutdownCGame();
+  // free face
+  re.FreeCachedGlyphs( &cls.consoleFace );
+  re.FreeFace( &cls.consoleFace );
 	// shutdown the renderer and clear the renderer interface
 	CL_ShutdownRef();
 	// client is no longer pure untill new checksums are sent
@@ -1793,7 +1804,7 @@ CL_PK3List_f
 ==================
 */
 void CL_OpenedPK3List_f( void ) {
-	Com_Printf("Opened PK3 Names: %s\n", FS_LoadedPakNames());
+	Com_Printf(_("Opened PK3 Names: %s\n"), FS_LoadedPakNames());
 }
 
 /*
@@ -1802,7 +1813,7 @@ CL_PureList_f
 ==================
 */
 void CL_ReferencedPK3List_f( void ) {
-	Com_Printf("Referenced PK3 Names: %s\n", FS_ReferencedPakNames());
+	Com_Printf(_("Referenced PK3 Names: %s\n"), FS_ReferencedPakNames());
 }
 
 /*
@@ -1815,7 +1826,7 @@ void CL_Configstrings_f( void ) {
 	int		ofs;
 
 	if ( cls.state != CA_ACTIVE ) {
-		Com_Printf( "Not connected to a server.\n");
+		Com_Printf( _("Not connected to a server.\n"));
 		return;
 	}
 
@@ -1834,12 +1845,12 @@ CL_Clientinfo_f
 ==============
 */
 void CL_Clientinfo_f( void ) {
-	Com_Printf( "--------- Client Information ---------\n" );
-	Com_Printf( "state: %i\n", cls.state );
-	Com_Printf( "Server: %s\n", cls.servername );
-	Com_Printf ("User info settings:\n");
+	Com_Printf( _("--------- Client Information ---------\n") );
+	Com_Printf( _("state: %i\n"), cls.state );
+	Com_Printf( _("Server: %s\n"), cls.servername );
+	Com_Printf (_("User info settings:\n"));
 	Info_Print( Cvar_InfoString( CVAR_USERINFO ) );
-	Com_Printf( "--------------------------------------\n" );
+	Com_Printf( _("--------------------------------------\n") );
 }
 
 
@@ -1853,7 +1864,7 @@ Called when all downloading has been completed
 =================
 */
 void CL_DownloadsComplete( void ) {
-	Com_Printf("Downloads complete\n");
+	Com_Printf(_("Downloads complete\n"));
 
 #ifdef USE_CURL
 	// if we downloaded with cURL
@@ -1931,10 +1942,10 @@ game directory.
 */
 void CL_BeginDownload( const char *localName, const char *remoteName ) {
 
-	Com_DPrintf("***** CL_BeginDownload *****\n"
-				"Localname: %s\n"
-				"Remotename: %s\n"
-				"****************************\n", localName, remoteName);
+	Com_DPrintf(_("***** CL_BeginDownload *****\n"
+				  "Localname: %s\n"
+				  "Remotename: %s\n"
+				  "****************************\n"), localName, remoteName);
 
 	Q_strncpyz ( clc.downloadName, localName, sizeof(clc.downloadName) );
 	Com_sprintf( clc.downloadTempName, sizeof(clc.downloadTempName), "%s.tmp", localName );
@@ -1975,7 +1986,7 @@ void CL_NextDownload(void)
 		zippath[strlen(zippath)-1] = '\0';
 
 		if(!FS_CompareZipChecksum(zippath))
-			Com_Error(ERR_DROP, "Incorrect checksum for file: %s", clc.downloadName);
+			Com_Error(ERR_DROP, _("Incorrect checksum for file: %s"), clc.downloadName);
 	}
 
 	*clc.downloadTempName = *clc.downloadName = 0;
@@ -2093,21 +2104,21 @@ void CL_NextDownload(void)
 		if( ( ( cl_allowDownload->integer & DLF_ENABLE ) &&
 		    !( cl_allowDownload->integer & DLF_NO_REDIRECT ) ) ||
 		    prompt == DLP_CURL ) {
-			Com_Printf("Trying CURL download: %s; %s\n", localName, remoteName);
+			Com_Printf(_("Trying CURL download: %s; %s\n"), localName, remoteName);
 			if(clc.sv_allowDownload & DLF_NO_REDIRECT) {
-				Com_Printf("WARNING: server does not "
-				           "allow download redirection "
-				           "(sv_allowDownload is %d)\n",
+				Com_Printf(_("WARNING: server does not "
+				             "allow download redirection "
+				             "(sv_allowDownload is %d)\n"),
 				           clc.sv_allowDownload);
 			}
 			else if(!*clc.sv_dlURL) {
-				Com_Printf("WARNING: server allows "
-				           "download redirection, but does not "
-				           "have sv_dlURL set\n");
+				Com_Printf(_("WARNING: server allows "
+				             "download redirection, but does not "
+				             "have sv_dlURL set\n"));
 			}
 			else if(!CL_cURL_Init()) {
-				Com_Printf("WARNING: could not load "
-				           "cURL library\n");
+				Com_Printf(_("WARNING: could not load "
+				             "cURL library\n"));
 			}
 			else {
 				CL_cURL_BeginDownload(localName, va("%s/%s",
@@ -2116,28 +2127,28 @@ void CL_NextDownload(void)
 			}
 		}
 		else if(!(clc.sv_allowDownload & DLF_NO_REDIRECT)) {
-		        Com_Printf("WARNING: server allows download "
+		        Com_Printf(_("WARNING: server allows download "
 			           "redirection, but it disabled by client "
-			           "configuration (cl_allowDownload is %d)\n",
+			           "configuration (cl_allowDownload is %d)\n"),
 			           cl_allowDownload->integer);
 		}
 #endif /* USE_CURL */
 		if(!useCURL) {
-			Com_Printf("Trying UDP download: %s; %s\n", localName, remoteName);
+			Com_Printf(_("Trying UDP download: %s; %s\n"), localName, remoteName);
 
 			if( ( !( cl_allowDownload->integer & DLF_ENABLE ) ||
 			    ( cl_allowDownload->integer & DLF_NO_UDP ) ) &&
 			    prompt != DLP_UDP ) {
 				if( cl_connectedToPureServer ) {
-					Com_Error(ERR_DROP, "Automatic downloads are "
+					Com_Error(ERR_DROP, _("Automatic downloads are "
 					          "disabled on your client (cl_allowDownload is %d). "
 					          "You can enable automatic downloads in the Options "
-					          "menu.",
+					          "menu."),
 				                  cl_allowDownload->integer);
 					return;
 				}
 
-				Com_Printf("WARNING: UDP downloads are disabled.\n");
+				Com_Printf(_("WARNING: UDP downloads are disabled.\n"));
 				CL_DownloadsComplete();
 				return;
 			}
@@ -2166,7 +2177,7 @@ and determine if we need to download them
 */
 void CL_InitDownloads(void) {
 	if ( FS_ComparePaks( clc.downloadList, sizeof( clc.downloadList ) , qtrue ) ) {
-    Com_Printf("Need paks: %s\n", clc.downloadList );
+    Com_Printf(_("Need paks: %s\n"), clc.downloadList );
 		Cvar_Set( "com_downloadPrompt", "0" );
 		if ( *clc.downloadList ) {
 			cls.state = CA_CONNECTED;
@@ -2280,8 +2291,8 @@ void CL_DisconnectPacket( netadr_t from ) {
 	}
 
 	// drop the connection
-	Com_Printf( "Server disconnected for unknown reason\n" );
-	Cvar_Set("com_errorMessage", "Server disconnected for unknown reason\n" );
+	Com_Printf( _("Server disconnected for unknown reason\n") );
+	Cvar_Set("com_errorMessage", _("Server disconnected for unknown reason\n") );
 	CL_Disconnect( qtrue );
 }
 
@@ -2297,7 +2308,7 @@ void CL_MotdPacket( netadr_t from, const char *info ) {
 
 	// if not from our server, ignore it
 	if ( !NET_CompareAdr( from, cls.updateServer ) ) {
-		Com_DPrintf( "MOTD packet from unexpected source\n" );
+		Com_DPrintf( _("MOTD packet from unexpected source\n") );
 		return;
 	}
 
@@ -2308,8 +2319,8 @@ void CL_MotdPacket( netadr_t from, const char *info ) {
 	// check challenge
 	v = Info_ValueForKey( info, "challenge" );
 	if ( strcmp( v, cls.updateChallenge ) ) {
-		Com_DPrintf( "MOTD packet mismatched challenge: "
-		             "'%s' != '%s'\n", v, cls.updateChallenge );
+		Com_DPrintf( _("MOTD packet mismatched challenge: "
+		               "'%s' != '%s'\n"), v, cls.updateChallenge );
 		return;
 	}
 
@@ -2374,7 +2385,7 @@ int CL_GSRSequenceInformation( byte **data )
 	{
 		// Assume we sent two getservers and somehow they changed in
 		// between - only use the results that arrive later
-		Com_DPrintf( "Master changed its mind about packet count!\n" );
+		Com_DPrintf( _("Master changed its mind about packet count!\n") );
 		cls.receivedMasterPackets = 0;
 		cls.numglobalservers = 0;
 		cls.numGlobalServerAddresses = 0;
@@ -2407,8 +2418,8 @@ void CL_GSRFeaturedLabel( byte **data, char *buf, int size )
 		if( l < &buf[ size - 1 ] )
 			*l = **data;
 		else if( l == &buf[ size - 1 ] )
-			Com_DPrintf( S_COLOR_YELLOW "Warning: "
-				"CL_GSRFeaturedLabel: overflow\n" );
+			Com_DPrintf( _(S_COLOR_YELLOW "Warning: "
+				"CL_GSRFeaturedLabel: overflow\n") );
 		l++, (*data)++;
 	}
 }
@@ -2467,15 +2478,15 @@ void CL_ServersResponsePacket( const netadr_t* from, msg_t *msg, qboolean extend
 			// have we already received this packet?
 			if( cls.receivedMasterPackets & ( 1 << ( ind - 1 ) ) )
 			{
-				Com_DPrintf( "CL_ServersResponsePacket: "
-					"received packet %d again, ignoring\n",
+				Com_DPrintf( _("CL_ServersResponsePacket: "
+					"received packet %d again, ignoring\n"),
 					ind );
 				return;
 			}
 			// TODO: detect dropped packets and make another
 			// request
-			Com_DPrintf( "CL_ServersResponsePacket: packet "
-				"%d of %d\n", ind, cls.numMasterPackets );
+			Com_DPrintf( _("CL_ServersResponsePacket: packet "
+				"%d of %d\n"), ind, cls.numMasterPackets );
 			cls.receivedMasterPackets |= ( 1 << ( ind - 1 ) );
 
 			CL_GSRFeaturedLabel( &buffptr, label, sizeof( label ) );
@@ -2558,7 +2569,7 @@ void CL_ServersResponsePacket( const netadr_t* from, msg_t *msg, qboolean extend
 	cls.numglobalservers = count;
 	total = count + cls.numGlobalServerAddresses;
 
-	Com_Printf("%d servers parsed (total %d)\n", numservers, total);
+	Com_Printf(_("%d servers parsed (total %d)\n"), numservers, total);
 }
 
 /*
@@ -2588,7 +2599,7 @@ void CL_ConnectionlessPacket( netadr_t from, msg_t *msg ) {
 	{
 		if (cls.state != CA_CONNECTING)
 		{
-			Com_DPrintf("Unwanted challenge response received.  Ignored.\n");
+			Com_DPrintf(_("Unwanted challenge response received.  Ignored.\n"));
 			return;
 		}
 		
@@ -2602,7 +2613,7 @@ void CL_ConnectionlessPacket( netadr_t from, msg_t *msg ) {
 			
 			if(!*c || atoi(c) != clc.challenge)
 			{
-				Com_DPrintf("Challenge response received from unexpected source. Ignored.\n");
+				Com_DPrintf(_("Challenge response received from unexpected source. Ignored.\n"));
 				return;
 			}
 		}
@@ -2623,15 +2634,15 @@ void CL_ConnectionlessPacket( netadr_t from, msg_t *msg ) {
 	// server connection
 	if ( !Q_stricmp(c, "connectResponse") ) {
 		if ( cls.state >= CA_CONNECTED ) {
-			Com_Printf ("Dup connect received.  Ignored.\n");
+			Com_Printf (_("Dup connect received.  Ignored.\n"));
 			return;
 		}
 		if ( cls.state != CA_CHALLENGING ) {
-			Com_Printf ("connectResponse packet while not connecting. Ignored.\n");
+			Com_Printf (_("connectResponse packet while not connecting. Ignored.\n"));
 			return;
 		}
 		if ( !NET_CompareAdr( from, clc.serverAddress ) ) {
-			Com_Printf( "connectResponse from wrong address. Ignored.\n" );
+			Com_Printf( _("connectResponse from wrong address. Ignored.\n") );
 			return;
 		}
 		Netchan_Setup (NS_CLIENT, &clc.netchan, from, Cvar_VariableValue( "net_qport" ) );
@@ -2696,7 +2707,7 @@ void CL_ConnectionlessPacket( netadr_t from, msg_t *msg ) {
 		return;
 	}
 
-	Com_DPrintf ("Unknown connectionless packet command.\n");
+	Com_DPrintf (_("Unknown connectionless packet command.\n"));
 }
 
 
@@ -2722,7 +2733,7 @@ void CL_PacketEvent( netadr_t from, msg_t *msg ) {
 	}
 
 	if ( msg->cursize < 4 ) {
-		Com_Printf ("%s: Runt packet\n", NET_AdrToStringwPort( from ));
+		Com_Printf (_("%s: Runt packet\n"), NET_AdrToStringwPort( from ));
 		return;
 	}
 
@@ -2730,7 +2741,7 @@ void CL_PacketEvent( netadr_t from, msg_t *msg ) {
 	// packet from server
 	//
 	if ( !NET_CompareAdr( from, clc.netchan.remoteAddress ) ) {
-		Com_DPrintf ("%s:sequenced packet without connection\n"
+		Com_DPrintf (_("%s:sequenced packet without connection\n")
 			, NET_AdrToStringwPort( from ) );
 		// FIXME: send a client disconnect?
 		return;
@@ -2774,7 +2785,7 @@ void CL_CheckTimeout( void ) {
 		&& cls.state >= CA_CONNECTED && cls.state != CA_CINEMATIC
 	    && cls.realtime - clc.lastPacketTime > cl_timeout->value*1000) {
 		if (++cl.timeoutcount > 5) {	// timeoutcount saves debugger
-			Com_Printf ("\nServer connection timed out.\n");
+			Com_Printf (_("\nServer connection timed out.\n"));
 			CL_Disconnect( qtrue );
 			return;
 		}
@@ -2840,7 +2851,7 @@ void CL_Frame ( int msec ) {
 	// We may have a download prompt ready
 	if( ( com_downloadPrompt->integer & DLP_TYPE_MASK ) &&
 	    !( com_downloadPrompt->integer & DLP_PROMPTED ) ) {
-		Com_Printf( "Download prompt returned %d\n",
+		Com_Printf( _("Download prompt returned %d\n"),
 		            com_downloadPrompt->integer );
 		CL_NextDownload( );
 	}
@@ -2850,7 +2861,7 @@ void CL_Frame ( int msec ) {
 		// One frame will always run between requesting and showing the prompt.
 
 		if( com_downloadPrompt->integer & DLP_STALE ) {
-			Com_Printf( "WARNING: UI VM does not support download prompt\n" );
+			Com_Printf( _("WARNING: UI VM does not support download prompt\n") );
 			Cvar_Set( "com_downloadPrompt", va( "%d", DLP_IGNORE ) );
 			CL_NextDownload( );
 		} else {
@@ -3035,13 +3046,49 @@ CL_InitRenderer
 ============
 */
 void CL_InitRenderer( void ) {
+	fileHandle_t f; 
+
 	// this sets up the renderer and calls R_Init
 	re.BeginRegistration( &cls.glconfig );
 
 	// load character sets
 	cls.charSetShader = re.RegisterShader( "gfx/2d/bigchars" );
+
+    cls.useLegacyConsoleFace = cls.useLegacyConsoleFont = qtrue;
+
+#ifdef BUILD_FREETYPE
+
+    // Register console font specified by cl_consoleFont, if any
+    // filehandle is unused but forces FS_FOpenFileRead() to heed purecheck because it does not when filehandle is NULL 
+    if( *cl_consoleFont->string )
+	{
+	  if( FS_FOpenFileRead( cl_consoleFont->string, &f, FS_READ ) >= 0 ) 
+      {
+        re.RegisterFont( cl_consoleFont->string, cl_consoleFontSize->integer, &cls.consoleFont);
+        cls.useLegacyConsoleFont = qfalse;
+      }
+      FS_FCloseFile( f );
+	}
+
+  if( *cl_consoleDynFont->string )
+  {
+    if( FS_FOpenFileRead( cl_consoleDynFont->string, &f, FS_READ ) >= 0 )
+    {
+        re.LoadFace( cl_consoleDynFont->string, cl_consoleFontSize->integer, cl_consoleDynFont->string, &cls.consoleFace );
+        cls.useLegacyConsoleFace = qfalse;
+    }
+    FS_FCloseFile( f );
+  }
+
+#endif
+
 	cls.whiteShader = re.RegisterShader( "white" );
-	cls.consoleShader = re.RegisterShader( "console" );
+
+    // For committing to Trem SVN, use "console" and change core.shader to use white instead of black.tga, 
+    // so that the console background image can be configured via that file and still let user color configuration work. 
+    // For inclusion in 1.1 clients, use "white" so that custom colors can be set and just skip the "console" shader altogether.
+	cls.consoleShader = re.RegisterShader( "white" );
+
 	g_console_field_width = cls.glconfig.vidWidth / SMALLCHAR_WIDTH - 2;
 	g_consoleField.widthInChars = g_console_field_width;
 }
@@ -3114,7 +3161,7 @@ void CL_InitRef( void ) {
 	refimport_t	ri;
 	refexport_t	*ret;
 
-	Com_Printf( "----- Initializing Renderer ----\n" );
+	Com_Printf( _("----- Initializing Renderer ----\n") );
 
 	ri.Cmd_AddCommand = Cmd_AddCommand;
 	ri.Cmd_RemoveCommand = Cmd_RemoveCommand;
@@ -3159,10 +3206,10 @@ void CL_InitRef( void ) {
 	hA3Dg_ExportRenderGeom (ret);
 #endif
 
-	Com_Printf( "-------------------------------\n");
+	Com_Printf( _("-------------------------------\n"));
 
 	if ( !ret ) {
-		Com_Error (ERR_FATAL, "Couldn't initialize refresh" );
+		Com_Error (ERR_FATAL, _("Couldn't initialize refresh") );
 	}
 
 	re = *ret;
@@ -3185,7 +3232,7 @@ void CL_SetModel_f( void ) {
 		Cvar_Set( "headmodel", arg );
 	} else {
 		Cvar_VariableStringBuffer( "model", name, sizeof(name) );
-		Com_Printf("model is set to %s\n", name);
+		Com_Printf(_("model is set to %s\n"), name);
 	}
 }
 
@@ -3208,7 +3255,7 @@ void CL_Video_f( void )
 
   if( !clc.demoplaying )
   {
-    Com_Printf( "The video command can only be used when playing back demos\n" );
+    Com_Printf( _("The video command can only be used when playing back demos\n") );
     return;
   }
 
@@ -3243,7 +3290,7 @@ void CL_Video_f( void )
 
     if( i > 9999 )
     {
-      Com_Printf( S_COLOR_RED "ERROR: no free file names to create video\n" );
+      Com_Printf( _(S_COLOR_RED "ERROR: no free file names to create video\n") );
       return;
     }
   }
@@ -3278,27 +3325,27 @@ static void CL_GenerateQKey(void)
 	len = FS_SV_FOpenFileRead( QKEY_FILE, &f );
 	FS_FCloseFile( f );
 	if( len == QKEY_SIZE ) {
-		Com_Printf( "QKEY found.\n" );
+		Com_Printf( _("QKEY found.\n") );
 		return;
 	}
 	else {
 		if( len > 0 ) {
-			Com_Printf( "QKEY file size != %d, regenerating\n",
+			Com_Printf( _("QKEY file size != %d, regenerating\n"),
 				QKEY_SIZE );
 		}
 
-		Com_Printf( "QKEY building random string\n" );
+		Com_Printf( _("QKEY building random string\n") );
 		Com_RandomBytes( buff, sizeof(buff) );
 
 		f = FS_SV_FOpenFileWrite( QKEY_FILE );
 		if( !f ) {
-			Com_Printf( "QKEY could not open %s for write\n",
+			Com_Printf( _("QKEY could not open %s for write\n"),
 				QKEY_FILE );
 			return;
 		}
 		FS_Write( buff, sizeof(buff), f );
 		FS_FCloseFile( f );
-		Com_Printf( "QKEY generated\n" );
+		Com_Printf( _("QKEY generated\n") );
 	}
 } 
 
@@ -3308,7 +3355,7 @@ CL_Init
 ====================
 */
 void CL_Init( void ) {
-	Com_Printf( "----- Client Initialization -----\n" );
+	Com_Printf( _("----- Client Initialization -----\n") );
 
 	Con_Init ();
 
@@ -3323,6 +3370,8 @@ void CL_Init( void ) {
 	//
 	// register our variables
 	//
+	Cvar_SetIFlag( "\\IS_GETTEXT_SUPPORTED" );
+
 	cl_noprint = Cvar_Get( "cl_noprint", "0", 0 );
 	cl_motd = Cvar_Get ("cl_motd", "1", 0);
 
@@ -3373,7 +3422,7 @@ void CL_Init( void ) {
 	com_downloadPrompt = Cvar_Get ("com_downloadPrompt", "0", CVAR_TEMP);
 	Cvar_Get( "com_downloadPromptText", "", CVAR_TEMP );
 
-	cl_conXOffset = Cvar_Get ("cl_conXOffset", "0", 0);
+	cl_conXOffset = Cvar_Get ("cl_conXOffset", "3", 0);
 #ifdef MACOS_X
 	// In game video is REALLY slow in Mac OS X right now due to driver slowness
 	cl_inGameVideo = Cvar_Get ("r_inGameVideo", "0", CVAR_ARCHIVE);
@@ -3405,6 +3454,13 @@ void CL_Init( void ) {
 	// ~ and `, as keys and characters
 	cl_consoleKeys = Cvar_Get( "cl_consoleKeys", "~ ` 0x7e 0x60", CVAR_ARCHIVE);
 
+	cl_consoleColor = Cvar_Get ("cl_consoleColor", "0.0 0.0 0.0 1.0", CVAR_ARCHIVE);
+	cl_consoleHeight = Cvar_Get ("cl_consoleHeight", "50", CVAR_ARCHIVE);
+	cl_consoleFont = Cvar_Get ("cl_consoleFont", DEFAULT_CONSOLE_FONT, CVAR_ARCHIVE | CVAR_LATCH);
+	cl_consoleFontSize = Cvar_Get ("cl_consoleFontSize", "16", CVAR_ARCHIVE | CVAR_LATCH);
+	cl_consoleFontKerning = Cvar_Get ("cl_consoleFontKerning", "0", CVAR_ARCHIVE);
+	cl_consoleDynFont = Cvar_Get ("cl_consoleDynFont", DEFAULT_CONSOLE_FONT, CVAR_ARCHIVE | CVAR_LATCH);
+
 	// userinfo
 	Cvar_Get ("name", Sys_GetCurrentUser( ), CVAR_USERINFO | CVAR_ARCHIVE );
 
@@ -3441,9 +3497,9 @@ void CL_Init( void ) {
 	//  just demand it. Who doesn't have at least a DSL line now, anyhow? If
 	//  you don't, you don't need VoIP.  :)
 	if ((cl_voip->integer) && (Cvar_VariableIntegerValue("rate") < 25000)) {
-		Com_Printf("Your network rate is too slow for VoIP.\n");
-		Com_Printf("Set 'Data Rate' to 'LAN/Cable/xDSL' in 'Setup/System/Network' and restart.\n");
-		Com_Printf("Until then, VoIP is disabled.\n");
+		Com_Printf(_("Your network rate is too slow for VoIP.\n"));
+		Com_Printf(_("Set 'Data Rate' to 'LAN/Cable/xDSL' in 'Setup/System/Network' and restart.\n"));
+		Com_Printf(_("Until then, VoIP is disabled.\n"));
 		Cvar_Set("cl_voip", "0");
 	}
 #endif
@@ -3494,7 +3550,7 @@ void CL_Init( void ) {
 	Cvar_Get( "cl_guid", "", CVAR_USERINFO | CVAR_ROM );
 	CL_UpdateGUID( NULL, 0 );
 
-	Com_Printf( "----- Client Initialization Complete -----\n" );
+	Com_Printf( _("----- Client Initialization Complete -----\n") );
 }
 
 
@@ -3511,20 +3567,24 @@ void CL_Shutdown( void ) {
 	if(!(com_cl_running && com_cl_running->integer))
 		return;
 	
-	Com_Printf( "----- CL_Shutdown -----\n" );
+	Com_Printf( _("----- CL_Shutdown -----\n") );
 
 	if ( recursive ) {
-		Com_Printf( "WARNING: Recursive shutdown\n" );
+		Com_Printf( _("WARNING: Recursive shutdown\n") );
 		return;
 	}
 	recursive = qtrue;
 
 	CL_Disconnect( qtrue );
 
+	re.FreeCachedGlyphs( &cls.consoleFace );
+	re.FreeFace( &cls.consoleFace );
+
+	CL_ShutdownCGame();
+	CL_ShutdownUI();
+
 	S_Shutdown();
 	CL_ShutdownRef();
-	
-	CL_ShutdownUI();
 
 	Cmd_RemoveCommand ("cmd");
 	Cmd_RemoveCommand ("configstrings");
@@ -3554,7 +3614,7 @@ void CL_Shutdown( void ) {
 	Com_Memset( &cls, 0, sizeof( cls ) );
 	Key_SetCatcher( 0 );
 
-	Com_Printf( "-----------------------\n" );
+	Com_Printf( _("-----------------------\n") );
 
 }
 
@@ -3614,7 +3674,7 @@ void CL_ServerInfoPacket( netadr_t from, msg_t *msg ) {
 	// if this isn't the correct protocol version, ignore it
 	prot = atoi( Info_ValueForKey( infoString, "protocol" ) );
 	if ( prot != PROTOCOL_VERSION ) {
-		Com_DPrintf( "Different protocol info packet: %s\n", infoString );
+		Com_DPrintf( _("Different protocol info packet: %s\n"), infoString );
 		return;
 	}
 
@@ -3625,7 +3685,7 @@ void CL_ServerInfoPacket( netadr_t from, msg_t *msg ) {
 		{
 			// calc ping time
 			cl_pinglist[i].time = Sys_Milliseconds() - cl_pinglist[i].start;
-			Com_DPrintf( "ping time %dms from %s\n", cl_pinglist[i].time, NET_AdrToString( from ) );
+			Com_DPrintf( _("ping time %dms from %s\n"), cl_pinglist[i].time, NET_AdrToString( from ) );
 
 			// save of info
 			Q_strncpyz( cl_pinglist[i].info, infoString, sizeof( cl_pinglist[i].info ) );
@@ -3670,7 +3730,7 @@ void CL_ServerInfoPacket( netadr_t from, msg_t *msg ) {
 	}
 
 	if ( i == MAX_OTHER_SERVERS ) {
-		Com_DPrintf( "MAX_OTHER_SERVERS hit, dropping infoResponse\n" );
+		Com_DPrintf( _("MAX_OTHER_SERVERS hit, dropping infoResponse\n") );
 		return;
 	}
 
@@ -3825,7 +3885,7 @@ void CL_ServerStatusResponse( netadr_t from, msg_t *msg ) {
 	Com_sprintf(&serverStatus->string[len], sizeof(serverStatus->string)-len, "%s", s);
 
 	if (serverStatus->print) {
-		Com_Printf("Server settings:\n");
+		Com_Printf(_("Server settings:\n"));
 		// print cvars
 		while (*s) {
 			for (i = 0; i < 2 && *s; i++) {
@@ -3856,8 +3916,8 @@ void CL_ServerStatusResponse( netadr_t from, msg_t *msg ) {
 	Com_sprintf(&serverStatus->string[len], sizeof(serverStatus->string)-len, "\\");
 
 	if (serverStatus->print) {
-		Com_Printf("\nPlayers:\n");
-		Com_Printf("num: score: ping: name:\n");
+		Com_Printf(_("\nPlayers:\n"));
+		Com_Printf(_("num: score: ping: name:\n"));
 	}
 	for (i = 0, s = MSG_ReadStringLine( msg ); *s; s = MSG_ReadStringLine( msg ), i++) {
 
@@ -3898,7 +3958,7 @@ void CL_LocalServers_f( void ) {
 	int			i, j;
 	netadr_t	to;
 
-	Com_Printf( "Scanning for servers on the local network...\n");
+	Com_Printf( _("Scanning for servers on the local network...\n"));
 
 	// reset the list, waiting for response
 	cls.numlocalservers = 0;
@@ -3944,7 +4004,7 @@ void CL_GlobalServers_f( void ) {
 	
 	if ((count = Cmd_Argc()) < 3 || (masterNum = atoi(Cmd_Argv(1))) < 0 || masterNum > 4)
 	{
-		Com_Printf( "usage: globalservers <master# 0-4> <protocol> [keywords]\n");
+		Com_Printf( _("usage: globalservers <master# 0-4> <protocol> [keywords]\n"));
 		return;	
 	}
 
@@ -3953,7 +4013,7 @@ void CL_GlobalServers_f( void ) {
 	
 	if(!*masteraddress)
 	{
-		Com_Printf( "CL_GlobalServers_f: Error: No master server address given.\n");
+		Com_Printf( _("CL_GlobalServers_f: Error: No master server address given.\n"));
 		return;	
 	}
 
@@ -3964,13 +4024,13 @@ void CL_GlobalServers_f( void ) {
 	
 	if(!i)
 	{
-		Com_Printf( "CL_GlobalServers_f: Error: could not resolve address of master %s\n", masteraddress);
+		Com_Printf( _("CL_GlobalServers_f: Error: could not resolve address of master %s\n"), masteraddress);
 		return;	
 	}
 	else if(i == 2)
 		to.port = BigShort(PORT_MASTER);
 
-	Com_Printf("Requesting servers from master %s...\n", masteraddress);
+	Com_Printf(_("Requesting servers from master %s...\n"), masteraddress);
 
 	cls.numglobalservers = -1;
 	cls.pingUpdateSource = AS_GLOBAL;
@@ -4188,7 +4248,7 @@ void CL_Ping_f( void ) {
 		else if(!strcmp(Cmd_Argv(1), "-6"))
 			family = NA_IP6;
 		else
-			Com_Printf( "warning: only -4 or -6 as address type understood.\n");
+			Com_Printf( _("warning: only -4 or -6 as address type understood.\n"));
 		
 		server = Cmd_Argv(2);
 	}
@@ -4354,7 +4414,7 @@ void CL_ServerStatus_f(void) {
 			else if(!strcmp(Cmd_Argv(1), "-6"))
 				family = NA_IP6;
 			else
-				Com_Printf( "warning: only -4 or -6 as address type understood.\n");
+				Com_Printf( _("warning: only -4 or -6 as address type understood.\n"));
 		
 			server = Cmd_Argv(2);
 		}
diff --git a/src/client/cl_parse.c b/src/client/cl_parse.c
index 64404f7..dd0fb79 100644
--- a/src/client/cl_parse.c
+++ b/src/client/cl_parse.c
@@ -121,7 +121,7 @@ void CL_ParsePacketEntities( msg_t *msg, clSnapshot_t *oldframe, clSnapshot_t *n
 		}
 
 		if ( msg->readcount > msg->cursize ) {
-			Com_Error (ERR_DROP,"CL_ParsePacketEntities: end of message");
+			Com_Error (ERR_DROP,_("CL_ParsePacketEntities: end of message"));
 		}
 
 		while ( oldnum < newnum ) {
@@ -249,13 +249,13 @@ void CL_ParseSnapshot( msg_t *msg ) {
 		old = &cl.snapshots[newSnap.deltaNum & PACKET_MASK];
 		if ( !old->valid ) {
 			// should never happen
-			Com_Printf ("Delta from invalid frame (not supposed to happen!).\n");
+			Com_Printf (_("Delta from invalid frame (not supposed to happen!).\n"));
 		} else if ( old->messageNum != newSnap.deltaNum ) {
 			// The frame that the server did the delta from
 			// is too old, so we can't reconstruct it properly.
-			Com_Printf ("Delta frame too old.\n");
+			Com_Printf (_("Delta frame too old.\n"));
 		} else if ( cl.parseEntitiesNum - old->parseEntitiesNum > MAX_PARSE_ENTITIES-128 ) {
-			Com_Printf ("Delta parseEntitiesNum too old.\n");
+			Com_Printf (_("Delta parseEntitiesNum too old.\n"));
 		} else {
 			newSnap.valid = qtrue;	// valid delta parse
 		}
@@ -266,7 +266,7 @@ void CL_ParseSnapshot( msg_t *msg ) {
 	
 	if(len > sizeof(newSnap.areamask))
 	{
-		Com_Error (ERR_DROP,"CL_ParseSnapshot: Invalid size %d for areamask.", len);
+		Com_Error (ERR_DROP,_("CL_ParseSnapshot: Invalid size %d for areamask."), len);
 		return;
 	}
 	
@@ -401,7 +401,7 @@ void CL_SystemInfoChanged( void ) {
 		{
 			if(FS_CheckDirTraversal(value))
 			{
-				Com_Printf(S_COLOR_YELLOW "WARNING: Server sent invalid fs_game value %s\n", value);
+				Com_Printf(_(S_COLOR_YELLOW "WARNING: Server sent invalid fs_game value %s\n"), value);
 				continue;
 			}
 				
@@ -415,7 +415,7 @@ void CL_SystemInfoChanged( void ) {
 			// If this cvar may not be modified by a server discard the value.
 			if(!(cvar_flags & (CVAR_SYSTEMINFO | CVAR_SERVER_CREATED)))
 			{
-				Com_Printf(S_COLOR_YELLOW "WARNING: server is not allowed to set %s=%s\n", key, value);
+				Com_Printf(_(S_COLOR_YELLOW "WARNING: server is not allowed to set %s=%s\n"), key, value);
 				continue;
 			}
 
@@ -485,13 +485,13 @@ void CL_ParseGamestate( msg_t *msg ) {
 
 			i = MSG_ReadShort( msg );
 			if ( i < 0 || i >= MAX_CONFIGSTRINGS ) {
-				Com_Error( ERR_DROP, "configstring > MAX_CONFIGSTRINGS" );
+				Com_Error( ERR_DROP, _("configstring > MAX_CONFIGSTRINGS") );
 			}
 			s = MSG_ReadBigString( msg );
 			len = strlen( s );
 
 			if ( len + 1 + cl.gameState.dataCount > MAX_GAMESTATE_CHARS ) {
-				Com_Error( ERR_DROP, "MAX_GAMESTATE_CHARS exceeded" );
+				Com_Error( ERR_DROP, _("MAX_GAMESTATE_CHARS exceeded") );
 			}
 
 			// append it to the gameState string buffer
@@ -501,13 +501,13 @@ void CL_ParseGamestate( msg_t *msg ) {
 		} else if ( cmd == svc_baseline ) {
 			newnum = MSG_ReadBits( msg, GENTITYNUM_BITS );
 			if ( newnum < 0 || newnum >= MAX_GENTITIES ) {
-				Com_Error( ERR_DROP, "Baseline number out of range: %i", newnum );
+				Com_Error( ERR_DROP, _("Baseline number out of range: %i"), newnum );
 			}
 			Com_Memset (&nullstate, 0, sizeof(nullstate));
 			es = &cl.entityBaselines[ newnum ];
 			MSG_ReadDeltaEntity( msg, &nullstate, es, newnum );
 		} else {
-			Com_Error( ERR_DROP, "CL_ParseGamestate: bad command byte" );
+			Com_Error( ERR_DROP, _("CL_ParseGamestate: bad command byte") );
 		}
 	}
 
@@ -552,7 +552,7 @@ void CL_ParseDownload ( msg_t *msg ) {
 	int block;
 
 	if (!*clc.downloadTempName) {
-		Com_Printf("Server sending download, but no download was requested\n");
+		Com_Printf(_("Server sending download, but no download was requested\n"));
 		CL_AddReliableCommand("stopdl", qfalse);
 		return;
 	}
@@ -577,14 +577,14 @@ void CL_ParseDownload ( msg_t *msg ) {
 	size = MSG_ReadShort ( msg );
 	if (size < 0 || size > sizeof(data))
 	{
-		Com_Error(ERR_DROP, "CL_ParseDownload: Invalid size %d for download chunk.", size);
+		Com_Error(ERR_DROP, _("CL_ParseDownload: Invalid size %d for download chunk."), size);
 		return;
 	}
 	
 	MSG_ReadData(msg, data, size);
 
 	if (clc.downloadBlock != block) {
-		Com_DPrintf( "CL_ParseDownload: Expected block %d, got %d\n", clc.downloadBlock, block);
+		Com_DPrintf( _("CL_ParseDownload: Expected block %d, got %d\n"), clc.downloadBlock, block);
 		return;
 	}
 
@@ -594,7 +594,7 @@ void CL_ParseDownload ( msg_t *msg ) {
 		clc.download = FS_SV_FOpenFileWrite( clc.downloadTempName );
 
 		if (!clc.download) {
-			Com_Printf( "Could not create %s\n", clc.downloadTempName );
+			Com_Printf( _("Could not create %s\n"), clc.downloadTempName );
 			CL_AddReliableCommand("stopdl", qfalse);
 			CL_NextDownload();
 			return;
@@ -673,7 +673,7 @@ void CL_ParseVoip ( msg_t *msg ) {
 	int written = 0;
 	int i;
 
-	Com_DPrintf("VoIP: %d-byte packet from client %d\n", packetsize, sender);
+	Com_DPrintf(_("VoIP: %d-byte packet from client %d\n"), packetsize, sender);
 
 	if (sender < 0)
 		return;   // short/invalid packet, bail.
@@ -711,31 +711,31 @@ void CL_ParseVoip ( msg_t *msg ) {
 
 	// !!! FIXME: make sure data is narrowband? Does decoder handle this?
 
-	Com_DPrintf("VoIP: packet accepted!\n");
+	Com_DPrintf(_("VoIP: packet accepted!\n"));
 
 	// This is a new "generation" ... a new recording started, reset the bits.
 	if (generation != clc.voipIncomingGeneration[sender]) {
-		Com_DPrintf("VoIP: new generation %d!\n", generation);
+		Com_DPrintf(_("VoIP: new generation %d!\n"), generation);
 		speex_bits_reset(&clc.speexDecoderBits[sender]);
 		clc.voipIncomingGeneration[sender] = generation;
 		seqdiff = 0;
 	} else if (seqdiff < 0) {   // we're ahead of the sequence?!
 		// This shouldn't happen unless the packet is corrupted or something.
-		Com_DPrintf("VoIP: misordered sequence! %d < %d!\n",
+		Com_DPrintf(_("VoIP: misordered sequence! %d < %d!\n"),
 		            sequence, clc.voipIncomingSequence[sender]);
 		// reset the bits just in case.
 		speex_bits_reset(&clc.speexDecoderBits[sender]);
 		seqdiff = 0;
 	} else if (seqdiff > 100) { // more than 2 seconds of audio dropped?
 		// just start over.
-		Com_DPrintf("VoIP: Dropped way too many (%d) frames from client #%d\n",
+		Com_DPrintf(_("VoIP: Dropped way too many (%d) frames from client #%d\n"),
 		            seqdiff, sender);
 		speex_bits_reset(&clc.speexDecoderBits[sender]);
 		seqdiff = 0;
 	}
 
 	if (seqdiff != 0) {
-		Com_DPrintf("VoIP: Dropped %d frames from client #%d\n",
+		Com_DPrintf(_("VoIP: Dropped %d frames from client #%d\n"),
 		            seqdiff, sender);
 		// tell speex that we're missing frames...
 		for (i = 0; i < seqdiff; i++) {
@@ -749,14 +749,14 @@ void CL_ParseVoip ( msg_t *msg ) {
 		char encoded[256];
 		const int len = MSG_ReadByte(msg);
 		if (len < 0) {
-			Com_DPrintf("VoIP: Short packet!\n");
+			Com_DPrintf(_("VoIP: Short packet!\n"));
 			break;
 		}
 		MSG_ReadData(msg, encoded, len);
 
 		// shouldn't happen, but just in case...
 		if ((written + clc.speexFrameSize) * 2 > sizeof (decoded)) {
-			Com_DPrintf("VoIP: playback %d bytes, %d samples, %d frames\n",
+			Com_DPrintf(_("VoIP: playback %d bytes, %d samples, %d frames\n"),
 			            written * 2, written, i);
 			S_RawSamples(sender + 1, written, clc.speexSampleRate, 2, 1,
 			             (const byte *) decoded, clc.voipGain[sender]);
@@ -779,7 +779,7 @@ void CL_ParseVoip ( msg_t *msg ) {
 		written += clc.speexFrameSize;
 	}
 
-	Com_DPrintf("VoIP: playback %d bytes, %d samples, %d frames\n",
+	Com_DPrintf(_("VoIP: playback %d bytes, %d samples, %d frames\n"),
 	            written * 2, written, i);
 
 	if (written > 0) {
@@ -830,7 +830,7 @@ void CL_ParseServerMessage( msg_t *msg ) {
 	if ( cl_shownet->integer == 1 ) {
 		Com_Printf ("%i ",msg->cursize);
 	} else if ( cl_shownet->integer >= 2 ) {
-		Com_Printf ("------------------\n");
+		Com_Printf (_("------------------\n"));
 	}
 
 	MSG_Bitstream(msg);
@@ -847,7 +847,7 @@ void CL_ParseServerMessage( msg_t *msg ) {
 	//
 	while ( 1 ) {
 		if ( msg->readcount > msg->cursize ) {
-			Com_Error (ERR_DROP,"CL_ParseServerMessage: read past end of server message");
+			Com_Error (ERR_DROP,_("CL_ParseServerMessage: read past end of server message"));
 			break;
 		}
 
@@ -882,7 +882,7 @@ void CL_ParseServerMessage( msg_t *msg ) {
 	// other commands
 		switch ( cmd ) {
 		default:
-			Com_Error (ERR_DROP,"CL_ParseServerMessage: Illegible server message\n");
+			Com_Error (ERR_DROP,_("CL_ParseServerMessage: Illegible server message\n"));
 			break;			
 		case svc_nop:
 			break;
diff --git a/src/client/cl_scrn.c b/src/client/cl_scrn.c
index a5769b0..5c58688 100644
--- a/src/client/cl_scrn.c
+++ b/src/client/cl_scrn.c
@@ -115,19 +115,27 @@ void SCR_DrawPic( float x, float y, float width, float height, qhandle_t hShader
 }
 
 
+static glyphInfo_t *Glyph( const char *s )
+{
+  static glyphInfo_t glyphs[8];
+  static int index = 0;
+  glyphInfo_t *glyph = &glyphs[index++ & 7];
+
+  re.Glyph( &cls.consoleFont, &cls.consoleFace, s, glyph);
+
+  return glyph;
+}
+
+
 
 /*
 ** SCR_DrawChar
 ** chars are drawn at 640*480 virtual screen size
 */
-static void SCR_DrawChar( int x, int y, float size, int ch ) {
-	int row, col;
-	float frow, fcol;
+static void SCR_DrawChar( int x, int y, float size, const char *s ) {
 	float	ax, ay, aw, ah;
 
-	ch &= 255;
-
-	if ( ch == ' ' ) {
+	if ( *s == ' ' ) {
 		return;
 	}
 
@@ -141,49 +149,170 @@ static void SCR_DrawChar( int x, int y, float size, int ch ) {
 	ah = size;
 	SCR_AdjustFrom640( &ax, &ay, &aw, &ah );
 
-	row = ch>>4;
-	col = ch&15;
+  if( cls.useLegacyConsoleFace )
+  {
+    int row, col;
+    char ch = *s;
+    float frow, fcol;
+
+    row = ch>>4;
+    col = ch&15;
 
-	frow = row*0.0625;
-	fcol = col*0.0625;
-	size = 0.0625;
+    frow = row*0.0625;
+    fcol = col*0.0625;
+    size = 0.0625;
 
-	re.DrawStretchPic( ax, ay, aw, ah,
+    re.DrawStretchPic( ax, ay, aw, ah,
 					   fcol, frow, 
 					   fcol + size, frow + size, 
 					   cls.charSetShader );
+  }
+  else
+  {
+    glyphInfo_t *glyph = Glyph( s );
+
+    re.DrawStretchPic( ax, ay, aw, glyph->imageHeight,
+        glyph->s, glyph->t,
+        glyph->s2, glyph->t2,
+        glyph->glyph );
+  }
+}
+
+void SCR_DrawConsoleFontChar( float x, float y, const char *s )
+{
+  float xadj, yadj;
+  glyphInfo_t *glyph;
+
+  if( cls.useLegacyConsoleFont )
+  {
+    SCR_DrawSmallChar( (int)x, (int)y, s );
+    return;
+  }
+
+  if( *s == ' ' )
+    return;
+
+  glyph = Glyph( s );
+
+  xadj = ( SCR_ConsoleFontCharWidth( s ) - glyph->xSkip ) / 2.0f;
+  yadj = glyph->top;
+
+  re.DrawStretchPic( x + xadj, y - yadj, glyph->imageWidth, glyph->imageHeight,
+      glyph->s, glyph->t,
+      glyph->s2, glyph->t2,
+      glyph->glyph );
 }
 
 /*
 ** SCR_DrawSmallChar
 ** small chars are drawn at native screen resolution
 */
-void SCR_DrawSmallChar( int x, int y, int ch ) {
+void SCR_DrawSmallChar( int x, int y, const char *s ) {
 	int row, col;
 	float frow, fcol;
 	float size;
 
-	ch &= 255;
+  if( Q_UTF8Width( s ) <= 1 )
+  {
+    int ch = (int) *s;
+
+    ch &= 255;
+
+    if ( ch == ' ' ) {
+      return;
+    }
+
+    if ( y < -SMALLCHAR_HEIGHT ) {
+      return;
+    }
+
+    row = ch>>4;
+    col = ch&15;
+
+    frow = row*0.0625;
+    fcol = col*0.0625;
+    size = 0.0625;
+
+    re.DrawStretchPic( x, y, SMALLCHAR_WIDTH, SMALLCHAR_HEIGHT,
+               fcol, frow, 
+               fcol + size, frow + size, 
+               cls.charSetShader );
+  }
+  else
+  {
+    glyphInfo_t *glyph = Glyph( s );
+
+    re.DrawStretchPic( x, y, SMALLCHAR_WIDTH, glyph->imageHeight,
+               glyph->s,
+               glyph->t,
+               glyph->s2,
+               glyph->t2,
+               glyph->glyph );
+  }
+}
+
+float SCR_ConsoleFontCharWidth( const char *s )
+{
+    glyphInfo_t *glyph;
 
-	if ( ch == ' ' ) {
-		return;
-	}
+    if( cls.useLegacyConsoleFont )
+        return SMALLCHAR_WIDTH;
 
-	if ( y < -SMALLCHAR_HEIGHT ) {
-		return;
-	}
+    glyph = Glyph( s );
 
-	row = ch>>4;
-	col = ch&15;
+    return glyph->xSkip + cl_consoleFontKerning->value;
+}
 
-	frow = row*0.0625;
-	fcol = col*0.0625;
-	size = 0.0625;
 
-	re.DrawStretchPic( x, y, SMALLCHAR_WIDTH, SMALLCHAR_HEIGHT,
-					   fcol, frow, 
-					   fcol + size, frow + size, 
-					   cls.charSetShader );
+float SCR_ConsoleFontCharHeight( )
+{
+    fontInfo_t *font = &cls.consoleFont;
+    int ch = 'I' & 0xff;
+    glyphInfo_t *glyph = &font->glyphs[ch];
+    float vpadding = 0.3 * cl_consoleFontSize->value;
+
+    if( cls.useLegacyConsoleFont ) return SMALLCHAR_HEIGHT;
+
+
+    return (glyph->imageHeight + vpadding);
+}
+
+
+float SCR_ConsoleFontStringWidth( const char* s, int len )
+{
+    float width = 0;
+
+    if( cls.useLegacyConsoleFont )
+    {
+      if( cls.useLegacyConsoleFace )
+      {
+        return len * SMALLCHAR_WIDTH;
+      }
+      else
+      {
+        int l = 0;
+        const char *str = s;
+
+        while( *str && str - s < len )
+        {
+          l++;
+
+          str += Q_UTF8Width( str );
+        }
+
+        return l * SMALLCHAR_WIDTH;
+      }
+    }
+
+    while( *s && len > 0 )
+    {
+      width += SCR_ConsoleFontCharWidth( s );
+
+      s += Q_UTF8Width( s );
+      len--;
+    }
+
+    return (width);
 }
 
 
@@ -214,9 +343,9 @@ void SCR_DrawStringExt( int x, int y, float size, const char *string, float *set
 			s += 2;
 			continue;
 		}
-		SCR_DrawChar( xx+2, y+2, size, *s );
+		SCR_DrawChar( xx+2, y+2, size, s );
 		xx += size;
-		s++;
+    s += Q_UTF8Width( s );
 	}
 
 
@@ -234,9 +363,9 @@ void SCR_DrawStringExt( int x, int y, float size, const char *string, float *set
 			s += 2;
 			continue;
 		}
-		SCR_DrawChar( xx, y, size, *s );
+		SCR_DrawChar( xx, y, size, s );
 		xx += size;
-		s++;
+    s += Q_UTF8Width( s );
 	}
 	re.SetColor( NULL );
 }
@@ -267,7 +396,7 @@ void SCR_DrawSmallStringExt( int x, int y, const char *string, float *setColor,
 		qboolean noColorEscape ) {
 	vec4_t		color;
 	const char	*s;
-	int			xx;
+	float       xx;
 
 	// draw the colored text
 	s = string;
@@ -285,9 +414,9 @@ void SCR_DrawSmallStringExt( int x, int y, const char *string, float *setColor,
 				continue;
 			}
 		}
-		SCR_DrawSmallChar( xx, y, *s );
-		xx += SMALLCHAR_WIDTH;
-		s++;
+        SCR_DrawConsoleFontChar( xx, y, s );
+        xx += SCR_ConsoleFontCharWidth( s );
+		s += Q_UTF8Width( s );
 	}
 	re.SetColor( NULL );
 }
@@ -478,7 +607,7 @@ void SCR_DrawScreenField( stereoFrame_t stereoFrame ) {
 	if ( uivm && !VM_Call( uivm, UI_IS_FULLSCREEN )) {
 		switch( cls.state ) {
 		default:
-			Com_Error( ERR_FATAL, "SCR_DrawScreenField: bad cls.state" );
+			Com_Error( ERR_FATAL, _("SCR_DrawScreenField: bad cls.state") );
 			break;
 		case CA_CINEMATIC:
 			SCR_DrawCinematic();
@@ -541,7 +670,7 @@ void SCR_UpdateScreen( void ) {
 	}
 
 	if ( ++recursive > 2 ) {
-		Com_Error( ERR_FATAL, "SCR_UpdateScreen: recursively called" );
+		Com_Error( ERR_FATAL, _("SCR_UpdateScreen: recursively called") );
 	}
 	recursive = 1;
 
diff --git a/src/client/cl_ui.c b/src/client/cl_ui.c
index faa2dba..3679948 100644
--- a/src/client/cl_ui.c
+++ b/src/client/cl_ui.c
@@ -96,7 +96,7 @@ qboolean GetNews( qboolean begin )
 	if( begin ) { // if not already using curl, start the download
 		if( !clc.downloadCURLM ) { 
 			if(!CL_cURL_Init()) {
-				Cvar_Set( "cl_newsString", "^1Error: Could not load cURL library" );
+				Cvar_Set( "cl_newsString", _("^1Error: Could not load cURL library") );
 				return qtrue;
 			}
 			clc.activeCURLNotGameRelated = qtrue;
@@ -760,7 +760,7 @@ intptr_t CL_UISystemCalls( intptr_t *args ) {
 		|| !strncmp(VMA(2), "vid_restart", 11)
 		|| !strncmp(VMA(2), "quit", 5)))
 		{
-			Com_Printf (S_COLOR_YELLOW "turning EXEC_NOW '%.11s' into EXEC_INSERT\n", (const char*)VMA(2));
+			Com_Printf (_(S_COLOR_YELLOW "turning EXEC_NOW '%.11s' into EXEC_INSERT\n"), (const char*)VMA(2));
 			args[1] = EXEC_INSERT;
 		}
 		Cbuf_ExecuteText( args[1], VMA(2) );
@@ -1046,8 +1046,36 @@ intptr_t CL_UISystemCalls( intptr_t *args ) {
 		re.RemapShader( VMA(1), VMA(2), VMA(3) );
 		return 0;
 
+  case UI_GETTEXT:
+    strncpy( VMA(1), _(VMA(2)), args[3] );
+    return 0;
+
+  case UI_R_LOADFACE:
+    re.LoadFace( VMA(1), args[2], VMA(3), VMA(4) );
+    return 0;
+
+  case UI_R_FREEFACE:
+    re.FreeFace( VMA(1) );
+    return 0;
+
+  case UI_R_LOADGLYPH:
+    re.LoadGlyph( VMA(1), VMA(2), args[3], VMA(4) );
+    return 0;
+
+  case UI_R_FREEGLYPH:
+    re.FreeGlyph( VMA(1), args[2], VMA(3) );
+    return 0;
+
+  case UI_R_GLYPH:
+    re.Glyph( VMA(1), VMA(2), VMA(3), VMA(4) );
+    break;
+
+  case UI_R_FREECACHEDGLYPHS:
+    re.FreeCachedGlyphs( VMA(1) );
+    break;
+
 	default:
-		Com_Error( ERR_DROP, "Bad UI system trap: %ld", (long int) args[0] );
+		Com_Error( ERR_DROP, _("Bad UI system trap: %ld"), (long int) args[0] );
 
 	}
 
@@ -1091,9 +1119,9 @@ void CL_InitUI( void ) {
 	}
 	uivm = VM_Create( "ui", CL_UISystemCalls, interpret );
 	if ( !uivm ) {
-		Com_Printf( "Failed to find a valid UI vm. The following paths were searched:\n" );
+		Com_Printf( _("Failed to find a valid UI vm. The following paths were searched:\n") );
 		Cmd_ExecuteString( "path/\n" );
-		Com_Error( ERR_FATAL, "VM_Create on UI failed" );
+		Com_Error( ERR_FATAL, _("VM_Create on UI failed") );
 	}
 
 	// sanity check
@@ -1103,7 +1131,7 @@ void CL_InitUI( void ) {
 		VM_Call( uivm, UI_INIT, (cls.state >= CA_AUTHORIZING && cls.state < CA_ACTIVE));
 	}
 	else if (v != UI_API_VERSION) {
-		Com_Error( ERR_DROP, "User Interface is version %d, expected %d", v, UI_API_VERSION );
+		Com_Error( ERR_DROP, _("User Interface is version %d, expected %d"), v, UI_API_VERSION );
 		cls.uiStarted = qfalse;
 	}
 	else {
diff --git a/src/client/client.h b/src/client/client.h
index 0afdc68..7f0a5f3 100644
--- a/src/client/client.h
+++ b/src/client/client.h
@@ -44,8 +44,12 @@ Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 #define QKEY_FILE "qkey"
 #define QKEY_SIZE 2048
 
+#define DEFAULT_CONSOLE_FONT "ttf/DejaVuSans-Bold.ttf"
+
 #define	RETRANSMIT_TIMEOUT	3000	// time between connection packet retransmits
 
+#define _(String) Sys_Gettext(String)
+
 // snapshots are a view of the server at a given time
 typedef struct {
 	qboolean		valid;			// cleared if delta parsing was invalid
@@ -352,6 +356,11 @@ typedef struct {
 	qhandle_t	charSetShader;
 	qhandle_t	whiteShader;
 	qhandle_t	consoleShader;
+
+    qboolean useLegacyConsoleFont;
+    qboolean useLegacyConsoleFace;
+    fontInfo_t  consoleFont; 
+    face_t      consoleFace;
 } clientStatic_t;
 
 extern	clientStatic_t		cls;
@@ -413,6 +422,12 @@ extern	cvar_t	*cl_autoRecordDemo;
 
 extern	cvar_t	*cl_consoleKeys;
 
+extern  cvar_t  *cl_consoleColor;
+extern  cvar_t  *cl_consoleHeight;
+extern  cvar_t  *cl_consoleFont;
+extern  cvar_t  *cl_consoleFontSize;
+extern  cvar_t  *cl_consoleFontKerning;
+
 #ifdef USE_MUMBLE
 extern	cvar_t	*cl_useMumble;
 extern	cvar_t	*cl_mumbleScale;
@@ -569,7 +584,11 @@ void	SCR_DrawNamedPic( float x, float y, float width, float height, const char *
 void	SCR_DrawBigString( int x, int y, const char *s, float alpha, qboolean noColorEscape );			// draws a string with embedded color control characters with fade
 void	SCR_DrawBigStringColor( int x, int y, const char *s, vec4_t color, qboolean noColorEscape );	// ignores embedded color control characters
 void	SCR_DrawSmallStringExt( int x, int y, const char *string, float *setColor, qboolean forceColor, qboolean noColorEscape );
-void	SCR_DrawSmallChar( int x, int y, int ch );
+void	SCR_DrawSmallChar( int x, int y, const char *s );
+void    SCR_DrawConsoleFontChar( float x, float y, const char *s );
+float   SCR_ConsoleFontCharWidth( const char *s );
+float   SCR_ConsoleFontCharHeight ( void );
+float   SCR_ConsoleFontStringWidth( const char *s, int len );
 
 
 //
diff --git a/src/client/keycodes.h b/src/client/keycodes.h
index c13194c..c12d64f 100644
--- a/src/client/keycodes.h
+++ b/src/client/keycodes.h
@@ -276,6 +276,6 @@ typedef enum {
 // The menu code needs to get both key and char events, but
 // to avoid duplicating the paths, the char events are just
 // distinguished by or'ing in K_CHAR_FLAG (ugly)
-#define	K_CHAR_FLAG		1024
+#define	K_CHAR_BIT		11
 
 #endif
diff --git a/src/client/keys.h b/src/client/keys.h
index adb9537..8963a9e 100644
--- a/src/client/keys.h
+++ b/src/client/keys.h
@@ -33,7 +33,7 @@ extern	qkey_t		keys[MAX_KEYS];
 
 // NOTE TTimo the declaration of field_t and Field_Clear is now in qcommon/qcommon.h
 void Field_KeyDownEvent( field_t *edit, int key );
-void Field_CharEvent( field_t *edit, int ch );
+void Field_CharEvent( field_t *edit, const char *ch );
 void Field_Draw( field_t *edit, int x, int y, int width, qboolean showCursor, qboolean noColorEscape );
 void Field_BigDraw( field_t *edit, int x, int y, int width, qboolean showCursor, qboolean noColorEscape );
 
diff --git a/src/client/qal.c b/src/client/qal.c
index 57db8ed..109fd98 100644
--- a/src/client/qal.c
+++ b/src/client/qal.c
@@ -32,6 +32,8 @@ Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 
 #include "../sys/sys_loadlib.h"
 
+#define _(String) Sys_Gettext(String)
+
 LPALENABLE qalEnable;
 LPALDISABLE qalDisable;
 LPALISENABLED qalIsEnabled;
@@ -124,13 +126,13 @@ static void *GPA(char *str)
 	rv = Sys_LoadFunction(OpenALLib, str);
 	if(!rv)
 	{
-		Com_Printf( " Can't load symbol %s\n", str);
+		Com_Printf( _(" Can't load symbol %s\n"), str);
 		alinit_fail = qtrue;
 		return NULL;
 	}
 	else
 	{
-		Com_DPrintf( " Loaded symbol %s (%p)\n", str, rv);
+		Com_DPrintf( _(" Loaded symbol %s (%p)\n"), str, rv);
         return rv;
 	}
 }
@@ -145,7 +147,7 @@ qboolean QAL_Init(const char *libname)
 	if(OpenALLib)
 		return qtrue;
 
-	Com_Printf( "Loading \"%s\"...\n", libname);
+	Com_Printf( _("Loading \"%s\"...\n"), libname);
 	if( (OpenALLib = Sys_LoadLibrary(libname)) == 0 )
 	{
 #ifdef _WIN32
@@ -244,7 +246,7 @@ qboolean QAL_Init(const char *libname)
 	if(alinit_fail)
 	{
 		QAL_Shutdown();
-		Com_Printf( " One or more symbols not found\n");
+		Com_Printf( _(" One or more symbols not found\n"));
 		return qfalse;
 	}
 
diff --git a/src/client/snd_codec.c b/src/client/snd_codec.c
index b11e087..01c1a7a 100644
--- a/src/client/snd_codec.c
+++ b/src/client/snd_codec.c
@@ -145,7 +145,7 @@ void *S_CodecLoad(const char *filename, snd_info_t *info)
 	codec = S_FindCodecForFile(filename);
 	if(!codec)
 	{
-		Com_Printf("Unknown extension for %s\n", filename);
+		Com_Printf(_("Unknown extension for %s\n"), filename);
 		return NULL;
 	}
 
@@ -168,7 +168,7 @@ snd_stream_t *S_CodecOpenStream(const char *filename)
 	codec = S_FindCodecForFile(filename);
 	if(!codec)
 	{
-		Com_Printf("Unknown extension for %s\n", filename);
+		Com_Printf(_("Unknown extension for %s\n"), filename);
 		return NULL;
 	}
 
@@ -206,7 +206,7 @@ snd_stream_t *S_CodecUtilOpen(const char *filename, snd_codec_t *codec)
 	length = FS_FOpenFileRead(filename, &hnd, qtrue);
 	if(!hnd)
 	{
-		Com_Printf("Can't read sound file %s\n", filename);
+		Com_Printf(_("Can't read sound file %s\n"), filename);
 		return NULL;
 	}
 
diff --git a/src/client/snd_codec_wav.c b/src/client/snd_codec_wav.c
index dce561a..18afac6 100644
--- a/src/client/snd_codec_wav.c
+++ b/src/client/snd_codec_wav.c
@@ -68,7 +68,7 @@ static int S_ReadChunkInfo(fileHandle_t f, char *name)
 
 	len = FGetLittleLong(f);
 	if( len < 0 ) {
-		Com_Printf( S_COLOR_YELLOW "WARNING: Negative chunk length\n" );
+		Com_Printf( _(S_COLOR_YELLOW "WARNING: Negative chunk length\n") );
 		return -1;
 	}
 
@@ -142,7 +142,7 @@ static qboolean S_ReadRIFFHeader(fileHandle_t file, snd_info_t *info)
 	// Scan for the format chunk
 	if((fmtlen = S_FindRIFFChunk(file, "fmt ")) < 0)
 	{
-		Com_Printf( S_COLOR_RED "ERROR: Couldn't find \"fmt\" chunk\n");
+		Com_Printf( _(S_COLOR_RED "ERROR: Couldn't find \"fmt\" chunk\n"));
 		return qfalse;
 	}
 
@@ -156,7 +156,7 @@ static qboolean S_ReadRIFFHeader(fileHandle_t file, snd_info_t *info)
 
 	if( bits < 8 )
 	{
-	  Com_Printf( S_COLOR_RED "ERROR: Less than 8 bit sound is not supported\n");
+	  Com_Printf( _(S_COLOR_RED "ERROR: Less than 8 bit sound is not supported\n"));
 	  return qfalse;
 	}
 
@@ -173,7 +173,7 @@ static qboolean S_ReadRIFFHeader(fileHandle_t file, snd_info_t *info)
 	// Scan for the data chunk
 	if( (info->size = S_FindRIFFChunk(file, "data")) < 0)
 	{
-		Com_Printf( S_COLOR_RED "ERROR: Couldn't find \"data\" chunk\n");
+		Com_Printf( _(S_COLOR_RED "ERROR: Couldn't find \"data\" chunk\n"));
 		return qfalse;
 	}
 	info->samples = (info->size / info->width) / info->channels;
@@ -206,7 +206,7 @@ void *S_WAV_CodecLoad(const char *filename, snd_info_t *info)
 	FS_FOpenFileRead(filename, &file, qtrue);
 	if(!file)
 	{
-		Com_Printf( S_COLOR_RED "ERROR: Could not open \"%s\"\n",
+		Com_Printf( _(S_COLOR_RED "ERROR: Could not open \"%s\"\n"),
 				filename);
 		return NULL;
 	}
@@ -215,7 +215,7 @@ void *S_WAV_CodecLoad(const char *filename, snd_info_t *info)
 	if(!S_ReadRIFFHeader(file, info))
 	{
 		FS_FCloseFile(file);
-		Com_Printf( S_COLOR_RED "ERROR: Incorrect/unsupported format in \"%s\"\n",
+		Com_Printf( _(S_COLOR_RED "ERROR: Incorrect/unsupported format in \"%s\"\n"),
 				filename);
 		return NULL;
 	}
@@ -225,7 +225,7 @@ void *S_WAV_CodecLoad(const char *filename, snd_info_t *info)
 	if(!buffer)
 	{
 		FS_FCloseFile(file);
-		Com_Printf( S_COLOR_RED "ERROR: Out of memory reading \"%s\"\n",
+		Com_Printf( _(S_COLOR_RED "ERROR: Out of memory reading \"%s\"\n"),
 				filename);
 		return NULL;
 	}
diff --git a/src/client/snd_dma.c b/src/client/snd_dma.c
index 5d53533..f04dc8e 100644
--- a/src/client/snd_dma.c
+++ b/src/client/snd_dma.c
@@ -96,24 +96,24 @@ portable_samplepair_t s_rawsamples[MAX_RAW_STREAMS][MAX_RAW_SAMPLES];
 
 
 void S_Base_SoundInfo(void) {	
-	Com_Printf("----- Sound Info -----\n" );
+	Com_Printf(_("----- Sound Info -----\n") );
 	if (!s_soundStarted) {
-		Com_Printf ("sound system not started\n");
+		Com_Printf (_("sound system not started\n"));
 	} else {
-		Com_Printf("%5d stereo\n", dma.channels - 1);
-		Com_Printf("%5d samples\n", dma.samples);
-		Com_Printf("%5d samplebits\n", dma.samplebits);
-		Com_Printf("%5d submission_chunk\n", dma.submission_chunk);
-		Com_Printf("%5d speed\n", dma.speed);
-		Com_Printf("%p dma buffer\n", dma.buffer);
+		Com_Printf(_("%5d stereo\n"), dma.channels - 1);
+		Com_Printf(_("%5d samples\n"), dma.samples);
+		Com_Printf(_("%5d samplebits\n"), dma.samplebits);
+		Com_Printf(_("%5d submission_chunk\n"), dma.submission_chunk);
+		Com_Printf(_("%5d speed\n"), dma.speed);
+		Com_Printf(_("%p dma buffer\n"), dma.buffer);
 		if ( s_backgroundStream ) {
-			Com_Printf("Background file: %s\n", s_backgroundLoop );
+			Com_Printf(_("Background file: %s\n"), s_backgroundLoop );
 		} else {
-			Com_Printf("No background file.\n" );
+			Com_Printf(_("No background file.\n") );
 		}
 
 	}
-	Com_Printf("----------------------\n" );
+	Com_Printf(_("----------------------\n") );
 }
 
 
@@ -177,7 +177,7 @@ void S_Base_SoundList( void ) {
 		Com_Printf("%6i[%s] : %s[%s]\n", size, type[sfx->soundCompressionMethod],
 				sfx->soundName, mem[sfx->inMemory] );
 	}
-	Com_Printf ("Total resident: %i\n", total);
+	Com_Printf (_("Total resident: %i\n"), total);
 	S_DisplayFreeMemory();
 }
 
@@ -214,7 +214,7 @@ void S_ChannelSetup( void ) {
 	
 	*(channel_t **)q = NULL;
 	freelist = p + MAX_CHANNELS - 1;
-	Com_DPrintf("Channel memory manager started\n");
+	Com_DPrintf(_("Channel memory manager started\n"));
 }
 
 
@@ -260,14 +260,14 @@ static sfx_t *S_FindName( const char *name ) {
 	sfx_t	*sfx;
 
 	if (!name) {
-		Com_Error (ERR_FATAL, "S_FindName: NULL\n");
+		Com_Error (ERR_FATAL, _("S_FindName: NULL\n"));
 	}
 	if (!name[0]) {
-		Com_Error (ERR_FATAL, "S_FindName: empty name\n");
+		Com_Error (ERR_FATAL, _("S_FindName: empty name\n"));
 	}
 
 	if (strlen(name) >= MAX_QPATH) {
-		Com_Error (ERR_FATAL, "Sound name too long: %s", name);
+		Com_Error (ERR_FATAL, _("Sound name too long: %s"), name);
 	}
 
 	hash = S_HashSFXName(name);
@@ -290,7 +290,7 @@ static sfx_t *S_FindName( const char *name ) {
 
 	if (i == s_numSfx) {
 		if (s_numSfx == MAX_SFX) {
-			Com_Error (ERR_FATAL, "S_FindName: out of sfx_t");
+			Com_Error (ERR_FATAL, _("S_FindName: out of sfx_t"));
 		}
 		s_numSfx++;
 	}
@@ -354,14 +354,14 @@ sfxHandle_t	S_Base_RegisterSound( const char *name, qboolean compressed ) {
 	}
 
 	if ( strlen( name ) >= MAX_QPATH ) {
-		Com_Printf( "Sound name exceeds MAX_QPATH\n" );
+		Com_Printf( _("Sound name exceeds MAX_QPATH\n") );
 		return 0;
 	}
 
 	sfx = S_FindName( name );
 	if ( sfx->soundData ) {
 		if ( sfx->defaultSound ) {
-			Com_Printf( S_COLOR_YELLOW "WARNING: could not find %s - using default\n", sfx->soundName );
+			Com_Printf( _(S_COLOR_YELLOW "WARNING: could not find %s - using default\n"), sfx->soundName );
 			return 0;
 		}
 		return sfx - s_knownSfx;
@@ -373,7 +373,7 @@ sfxHandle_t	S_Base_RegisterSound( const char *name, qboolean compressed ) {
   S_memoryLoad(sfx);
 
 	if ( sfx->defaultSound ) {
-		Com_Printf( S_COLOR_YELLOW "WARNING: could not find %s - using default\n", sfx->soundName );
+		Com_Printf( _(S_COLOR_YELLOW "WARNING: could not find %s - using default\n"), sfx->soundName );
 		return 0;
 	}
 
@@ -387,7 +387,7 @@ S_Base_SoundDuration
 */
 static int S_Base_SoundDuration( sfxHandle_t handle ) {
 	if ( handle < 0 || handle >= s_numSfx ) {
-		Com_Printf( S_COLOR_YELLOW "S_Base_SoundDuration: handle %i out of range\n", handle );
+		Com_Printf( _(S_COLOR_YELLOW "S_Base_SoundDuration: handle %i out of range\n"), handle );
 		return 0;
 	}
 	return s_knownSfx[ handle ].duration;
@@ -418,7 +418,7 @@ void S_Base_BeginRegistration( void ) {
 void S_memoryLoad(sfx_t	*sfx) {
 	// load the sound file
 	if ( !S_LoadSound ( sfx ) ) {
-//		Com_Printf( S_COLOR_YELLOW "WARNING: couldn't load sound: %s\n", sfx->soundName );
+//		Com_Printf( _(S_COLOR_YELLOW "WARNING: couldn't load sound: %s\n"), sfx->soundName );
 		sfx->defaultSound = qtrue;
 	}
 	sfx->inMemory = qtrue;
@@ -509,11 +509,11 @@ void S_Base_StartSound(vec3_t origin, int entityNum, int entchannel, sfxHandle_t
 	}
 
 	if ( !origin && ( entityNum < 0 || entityNum > MAX_GENTITIES ) ) {
-		Com_Error( ERR_DROP, "S_StartSound: bad entitynum %i", entityNum );
+		Com_Error( ERR_DROP, _("S_StartSound: bad entitynum %i"), entityNum );
 	}
 
 	if ( sfxHandle < 0 || sfxHandle >= s_numSfx ) {
-		Com_Printf( S_COLOR_YELLOW "S_StartSound: handle %i out of range\n", sfxHandle );
+		Com_Printf( _(S_COLOR_YELLOW "S_StartSound: handle %i out of range\n"), sfxHandle );
 		return;
 	}
 
@@ -529,7 +529,7 @@ void S_Base_StartSound(vec3_t origin, int entityNum, int entchannel, sfxHandle_t
 
 	time = Com_Milliseconds();
 
-//	Com_Printf("playing %s\n", sfx->soundName);
+//	Com_Printf(_("playing %s\n"), sfx->soundName);
 	// pick a channel to play on
 
 	allowed = 4;
@@ -543,7 +543,7 @@ void S_Base_StartSound(vec3_t origin, int entityNum, int entchannel, sfxHandle_t
 		if (ch->entnum == entityNum && ch->thesfx == sfx) {
 			if (time - ch->allocTime < 50) {
 //				if (Cvar_VariableValue( "cg_showmiss" )) {
-//					Com_Printf("double sound start\n");
+//					Com_Printf(_("double sound start\n"));
 //				}
 				return;
 			}
@@ -588,7 +588,7 @@ void S_Base_StartSound(vec3_t origin, int entityNum, int entchannel, sfxHandle_t
 					}
 				}
 				if (chosen == -1) {
-					Com_DPrintf("dropping sound\n");
+					Com_DPrintf(_("dropping sound\n"));
 					return;
 				}
 			}
@@ -626,7 +626,7 @@ void S_Base_StartLocalSound( sfxHandle_t sfxHandle, int channelNum ) {
 	}
 
 	if ( sfxHandle < 0 || sfxHandle >= s_numSfx ) {
-		Com_Printf( S_COLOR_YELLOW "S_StartLocalSound: handle %i out of range\n", sfxHandle );
+		Com_Printf( _(S_COLOR_YELLOW "S_StartLocalSound: handle %i out of range\n"), sfxHandle );
 		return;
 	}
 
@@ -731,7 +731,7 @@ void S_Base_AddLoopingSound( int entityNum, const vec3_t origin, const vec3_t ve
 	}
 
 	if ( sfxHandle < 0 || sfxHandle >= s_numSfx ) {
-		Com_Printf( S_COLOR_YELLOW "S_AddLoopingSound: handle %i out of range\n", sfxHandle );
+		Com_Printf( _(S_COLOR_YELLOW "S_AddLoopingSound: handle %i out of range\n"), sfxHandle );
 		return;
 	}
 
@@ -742,7 +742,7 @@ void S_Base_AddLoopingSound( int entityNum, const vec3_t origin, const vec3_t ve
 	}
 
 	if ( !sfx->soundLength ) {
-		Com_Error( ERR_DROP, "%s has length 0", sfx->soundName );
+		Com_Error( ERR_DROP, _("%s has length 0"), sfx->soundName );
 	}
 
 	VectorCopy( origin, loopSounds[entityNum].origin );
@@ -794,7 +794,7 @@ void S_Base_AddRealLoopingSound( int entityNum, const vec3_t origin, const vec3_
 	}
 
 	if ( sfxHandle < 0 || sfxHandle >= s_numSfx ) {
-		Com_Printf( S_COLOR_YELLOW "S_AddRealLoopingSound: handle %i out of range\n", sfxHandle );
+		Com_Printf( _(S_COLOR_YELLOW "S_AddRealLoopingSound: handle %i out of range\n"), sfxHandle );
 		return;
 	}
 
@@ -805,7 +805,7 @@ void S_Base_AddRealLoopingSound( int entityNum, const vec3_t origin, const vec3_
 	}
 
 	if ( !sfx->soundLength ) {
-		Com_Error( ERR_DROP, "%s has length 0", sfx->soundName );
+		Com_Error( ERR_DROP, _("%s has length 0"), sfx->soundName );
 	}
 	VectorCopy( origin, loopSounds[entityNum].origin );
 	VectorCopy( velocity, loopSounds[entityNum].velocity );
@@ -955,13 +955,13 @@ void S_Base_RawSamples( int stream, int samples, int rate, int width, int s_chan
 		intVolume = 256 * volume * s_volume->value;
 
 	if ( s_rawend[stream] < s_soundtime ) {
-		Com_DPrintf( "S_Base_RawSamples: resetting minimum: %i < %i\n", s_rawend[stream], s_soundtime );
+		Com_DPrintf( _("S_Base_RawSamples: resetting minimum: %i < %i\n"), s_rawend[stream], s_soundtime );
 		s_rawend[stream] = s_soundtime;
 	}
 
 	scale = (float)rate / dma.speed;
 
-//Com_Printf ("%i < %i < %i\n", s_soundtime, s_paintedtime, s_rawend[stream]);
+//Com_Printf (_("%i < %i < %i\n"), s_soundtime, s_paintedtime, s_rawend[stream]);
 	if (s_channels == 2 && width == 2)
 	{
 		if (scale == 1.0)
@@ -1033,7 +1033,7 @@ void S_Base_RawSamples( int stream, int samples, int rate, int width, int s_chan
 	}
 
 	if ( s_rawend[stream] > s_soundtime + MAX_RAW_SAMPLES ) {
-		Com_DPrintf( "S_Base_RawSamples: overflowed %i > %i\n", s_rawend[stream], s_soundtime );
+		Com_DPrintf( _("S_Base_RawSamples: overflowed %i > %i\n"), s_rawend[stream], s_soundtime );
 	}
 }
 
@@ -1048,7 +1048,7 @@ let the sound system know where an entity currently is
 */
 void S_Base_UpdateEntityPosition( int entityNum, const vec3_t origin ) {
 	if ( entityNum < 0 || entityNum > MAX_GENTITIES ) {
-		Com_Error( ERR_DROP, "S_UpdateEntityPosition: bad entitynum %i", entityNum );
+		Com_Error( ERR_DROP, _("S_UpdateEntityPosition: bad entitynum %i"), entityNum );
 	}
 	VectorCopy( origin, loopSounds[entityNum].origin );
 }
@@ -1152,7 +1152,7 @@ void S_Base_Update( void ) {
 	channel_t	*ch;
 
 	if ( !s_soundStarted || s_soundMuted ) {
-//		Com_DPrintf ("not started or muted\n");
+//		Com_DPrintf (_("not started or muted\n"));
 		return;
 	}
 
@@ -1169,7 +1169,7 @@ void S_Base_Update( void ) {
 			}
 		}
 		
-		Com_Printf ("----(%i)---- painted: %i\n", total, s_paintedtime);
+		Com_Printf (_("----(%i)---- painted: %i\n"), total, s_paintedtime);
 	}
 
 	// add raw data from streamed samples
@@ -1216,7 +1216,7 @@ void S_GetSoundtime(void)
 // check to make sure that we haven't overshot
 	if (s_paintedtime < s_soundtime)
 	{
-		Com_DPrintf ("S_Update_ : overflow\n");
+		Com_DPrintf (_("S_Update_ : overflow\n"));
 		s_paintedtime = s_soundtime;
 	}
 #endif
@@ -1325,7 +1325,7 @@ void S_Base_StartBackgroundTrack( const char *intro, const char *loop ){
 	if ( !loop || !loop[0] ) {
 		loop = intro;
 	}
-	Com_DPrintf( "S_StartBackgroundTrack( %s, %s )\n", intro, loop );
+	Com_DPrintf( _("S_StartBackgroundTrack( %s, %s )\n"), intro, loop );
 
 	if(!*intro)
 	{
@@ -1350,12 +1350,12 @@ void S_Base_StartBackgroundTrack( const char *intro, const char *loop ){
 	// Open stream
 	s_backgroundStream = S_CodecOpenStream(intro);
 	if(!s_backgroundStream) {
-		Com_Printf( S_COLOR_YELLOW "WARNING: couldn't open music file %s\n", intro );
+		Com_Printf( _(S_COLOR_YELLOW "WARNING: couldn't open music file %s\n"), intro );
 		return;
 	}
 
 	if(s_backgroundStream->info.channels != 2 || s_backgroundStream->info.rate != 22050) {
-		Com_Printf(S_COLOR_YELLOW "WARNING: music file %s is not 22k stereo\n", intro );
+		Com_Printf(_(S_COLOR_YELLOW "WARNING: music file %s is not 22k stereo\n"), intro );
 	}
 }
 
@@ -1461,7 +1461,7 @@ void S_FreeOldestSound( void ) {
 
 	sfx = &s_knownSfx[used];
 
-	Com_DPrintf("S_FreeOldestSound: freeing sound %s\n", sfx->soundName);
+	Com_DPrintf(_("S_FreeOldestSound: freeing sound %s\n"), sfx->soundName);
 
 	buffer = sfx->soundData;
 	while(buffer != NULL) {
diff --git a/src/client/snd_local.h b/src/client/snd_local.h
index 53ddbca..be9071a 100644
--- a/src/client/snd_local.h
+++ b/src/client/snd_local.h
@@ -33,6 +33,8 @@ Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 #define SND_CHUNK_SIZE_FLOAT	(SND_CHUNK_SIZE/2)		// floats
 #define SND_CHUNK_SIZE_BYTE		(SND_CHUNK_SIZE*2)		// floats
 
+#define _(String) Sys_Gettext(String)
+
 typedef struct {
 	int			left;	// the final values will be clamped to +/- 0x00ffff00 and shifted down
 	int			right;
diff --git a/src/client/snd_main.c b/src/client/snd_main.c
index 1215e95..5c11642 100644
--- a/src/client/snd_main.c
+++ b/src/client/snd_main.c
@@ -489,7 +489,7 @@ void S_Init( void )
 	cvar_t		*cv;
 	qboolean	started = qfalse;
 
-	Com_Printf( "------ Initializing Sound ------\n" );
+	Com_Printf( _("------ Initializing Sound ------\n") );
 
 	s_volume = Cvar_Get( "s_volume", "0.8", CVAR_ARCHIVE );
 	s_musicVolume = Cvar_Get( "s_musicvolume", "0.25", CVAR_ARCHIVE );
@@ -501,7 +501,7 @@ void S_Init( void )
 
 	cv = Cvar_Get( "s_initsound", "1", 0 );
 	if( !cv->integer ) {
-		Com_Printf( "Sound disabled.\n" );
+		Com_Printf( _("Sound disabled.\n") );
 	} else {
 
 		S_CodecInit( );
@@ -527,17 +527,17 @@ void S_Init( void )
 
 		if( started ) {
 			if( !S_ValidSoundInterface( &si ) ) {
-				Com_Error( ERR_FATAL, "Sound interface invalid." );
+				Com_Error( ERR_FATAL, _("Sound interface invalid.") );
 			}
 
 			S_SoundInfo( );
-			Com_Printf( "Sound initialization successful.\n" );
+			Com_Printf( _("Sound initialization successful.\n") );
 		} else {
-			Com_Printf( "Sound initialization failed.\n" );
+			Com_Printf( _("Sound initialization failed.\n") );
 		}
 	}
 
-	Com_Printf( "--------------------------------\n");
+	Com_Printf( _("--------------------------------\n"));
 }
 
 /*
diff --git a/src/client/snd_mem.c b/src/client/snd_mem.c
index f3d90dd..d58f7dd 100644
--- a/src/client/snd_mem.c
+++ b/src/client/snd_mem.c
@@ -98,7 +98,7 @@ void SND_setup(void) {
 	*(sndBuffer **)q = NULL;
 	freelist = p + scs - 1;
 
-	Com_Printf("Sound memory manager started\n");
+	Com_Printf(_("Sound memory manager started\n"));
 }
 
 /*
@@ -218,11 +218,11 @@ qboolean S_LoadSound( sfx_t *sfx )
 		sfx->duration = (int)(1000.0f * ((double)info.size / size_per_sec));
 
 	if ( info.width == 1 ) {
-		Com_DPrintf(S_COLOR_YELLOW "WARNING: %s is a 8 bit wav file\n", sfx->soundName);
+		Com_DPrintf(_(S_COLOR_YELLOW "WARNING: %s is a 8 bit wav file\n"), sfx->soundName);
 	}
 
 	if ( info.rate != 22050 ) {
-		Com_DPrintf(S_COLOR_YELLOW "WARNING: %s is not a 22kHz wav file\n", sfx->soundName);
+		Com_DPrintf(_(S_COLOR_YELLOW "WARNING: %s is not a 22kHz wav file\n"), sfx->soundName);
 	}
 
 	samples = Hunk_AllocateTempMemory(info.samples * sizeof(short) * 2);
@@ -266,5 +266,5 @@ qboolean S_LoadSound( sfx_t *sfx )
 }
 
 void S_DisplayFreeMemory(void) {
-	Com_Printf("%d bytes free sound buffer memory, %d total used\n", inUse, totalInUse);
+	Com_Printf(_("%d bytes free sound buffer memory, %d total used\n"), inUse, totalInUse);
 }
diff --git a/src/client/snd_openal.c b/src/client/snd_openal.c
index b0e7cae..8b68ba4 100644
--- a/src/client/snd_openal.c
+++ b/src/client/snd_openal.c
@@ -83,19 +83,19 @@ static const char *S_AL_ErrorMsg(ALenum error)
 	switch(error)
 	{
 		case AL_NO_ERROR:
-			return "No error";
+			return _("No error");
 		case AL_INVALID_NAME:
-			return "Invalid name";
+			return _("Invalid name");
 		case AL_INVALID_ENUM:
-			return "Invalid enumerator";
+			return _("Invalid enumerator");
 		case AL_INVALID_VALUE:
-			return "Invalid value";
+			return _("Invalid value");
 		case AL_INVALID_OPERATION:
-			return "Invalid operation";
+			return _("Invalid operation");
 		case AL_OUT_OF_MEMORY:
-			return "Out of memory";
+			return _("Out of memory");
 		default:
-			return "Unknown error";
+			return _("Unknown error");
 	}
 }
 
@@ -112,7 +112,7 @@ static void S_AL_ClearError( qboolean quiet )
 		return;
 	if(error != AL_NO_ERROR)
 	{
-		Com_Printf(S_COLOR_YELLOW "WARNING: unhandled AL error: %s\n",
+		Com_Printf(_(S_COLOR_YELLOW "WARNING: unhandled AL error: %s\n"),
 			S_AL_ErrorMsg(error));
 	}
 }
@@ -171,7 +171,7 @@ static sfxHandle_t S_AL_BufferFindFree( void )
 	}
 
 	// Shit...
-	Com_Error(ERR_FATAL, "S_AL_BufferFindFree: No free sound handles");
+	Com_Error(ERR_FATAL, _("S_AL_BufferFindFree: No free sound handles"));
 	return -1;
 }
 
@@ -223,9 +223,9 @@ S_AL_BufferUseDefault
 static void S_AL_BufferUseDefault(sfxHandle_t sfx)
 {
 	if(sfx == default_sfx)
-		Com_Error(ERR_FATAL, "Can't load default sound effect %s\n", knownSfx[sfx].filename);
+		Com_Error(ERR_FATAL, _("Can't load default sound effect %s\n"), knownSfx[sfx].filename);
 
-	Com_Printf( S_COLOR_YELLOW "WARNING: Using default sound for %s\n", knownSfx[sfx].filename);
+	Com_Printf( _(S_COLOR_YELLOW "WARNING: Using default sound for %s\n"), knownSfx[sfx].filename);
 	knownSfx[sfx].isDefault = qtrue;
 	knownSfx[sfx].buffer = knownSfx[default_sfx].buffer;
 }
@@ -249,7 +249,7 @@ static void S_AL_BufferUnload(sfxHandle_t sfx)
 	S_AL_ClearError( qfalse );
 	qalDeleteBuffers(1, &knownSfx[sfx].buffer);
 	if((error = qalGetError()) != AL_NO_ERROR)
-		Com_Printf( S_COLOR_RED "ERROR: Can't delete sound buffer for %s\n",
+		Com_Printf( _(S_COLOR_RED "ERROR: Can't delete sound buffer for %s\n"),
 				knownSfx[sfx].filename);
 
 	knownSfx[sfx].inMemory = qfalse;
@@ -337,7 +337,7 @@ static void S_AL_BufferLoad(sfxHandle_t sfx)
 	{
 		S_AL_BufferUseDefault(sfx);
 		Z_Free(data);
-		Com_Printf( S_COLOR_RED "ERROR: Can't create a sound buffer for %s - %s\n",
+		Com_Printf( _(S_COLOR_RED "ERROR: Can't create a sound buffer for %s - %s\n"),
 				curSfx->filename, S_AL_ErrorMsg(error));
 		return;
 	}
@@ -362,7 +362,7 @@ static void S_AL_BufferLoad(sfxHandle_t sfx)
 		{
 			S_AL_BufferUseDefault(sfx);
 			Z_Free(data);
-			Com_Printf( S_COLOR_RED "ERROR: Out of memory loading %s\n", curSfx->filename);
+			Com_Printf( _(S_COLOR_RED "ERROR: Out of memory loading %s\n"), curSfx->filename);
 			return;
 		}
 
@@ -376,7 +376,7 @@ static void S_AL_BufferLoad(sfxHandle_t sfx)
 	{
 		S_AL_BufferUseDefault(sfx);
 		Z_Free(data);
-		Com_Printf( S_COLOR_RED "ERROR: Can't fill sound buffer for %s - %s\n",
+		Com_Printf( _(S_COLOR_RED "ERROR: Can't fill sound buffer for %s - %s\n"),
 				curSfx->filename, S_AL_ErrorMsg(error));
 		return;
 	}
@@ -485,7 +485,7 @@ int S_AL_SoundDuration( sfxHandle_t sfx )
 {
 	if (sfx < 0 || sfx >= numSfx)
 	{
-		Com_Printf(S_COLOR_RED "ERROR: S_AL_SoundDuration: handle %i out of range\n", sfx);
+		Com_Printf(_(S_COLOR_RED "ERROR: S_AL_SoundDuration: handle %i out of range\n"), sfx);
 		return 0;
 	}
 	return knownSfx[sfx].duration;
@@ -570,8 +570,8 @@ static void _S_AL_SanitiseVector( vec3_t v, int line )
 {
 	if( Q_isnan( v[ 0 ] ) || Q_isnan( v[ 1 ] ) || Q_isnan( v[ 2 ] ) )
 	{
-		Com_DPrintf( S_COLOR_YELLOW "WARNING: vector with one or more NaN components "
-				"being passed to OpenAL at %s:%d -- zeroing\n", __FILE__, line );
+		Com_DPrintf( _(S_COLOR_YELLOW "WARNING: vector with one or more NaN components "
+				"being passed to OpenAL at %s:%d -- zeroing\n"), __FILE__, line );
 		VectorClear( v );
 	}
 }
@@ -699,7 +699,7 @@ qboolean S_AL_SrcInit( void )
 	}
 
 	// All done. Print this for informational purposes
-	Com_Printf( "Allocated %d sources.\n", srcCount);
+	Com_Printf( _("Allocated %d sources.\n"), srcCount);
 	alSourcesInitialised = qtrue;
 	return qtrue;
 }
@@ -724,7 +724,7 @@ void S_AL_SrcShutdown( void )
 		curSource = &srcList[i];
 		
 		if(curSource->isLocked)
-			Com_DPrintf( S_COLOR_YELLOW "WARNING: Source %d is locked\n", i);
+			Com_DPrintf( _(S_COLOR_YELLOW "WARNING: Source %d is locked\n"), i);
 
 		if(curSource->entity > 0)
 			entityList[curSource->entity].srcAllocated = qfalse;
@@ -810,7 +810,7 @@ static void S_AL_SaveLoopPos(src_t *dest, ALuint alSource)
 
 		if(error != AL_INVALID_ENUM)
 		{
-			Com_Printf(S_COLOR_YELLOW "WARNING: Could not get time offset for alSource %d: %s\n",
+			Com_Printf(_(S_COLOR_YELLOW "WARNING: Could not get time offset for alSource %d: %s\n"),
 				   alSource, S_AL_ErrorMsg(error));
 		}
 		
@@ -1124,7 +1124,7 @@ void S_AL_UpdateEntityPosition( int entityNum, const vec3_t origin )
 	VectorCopy( origin, sanOrigin );
 	S_AL_SanitiseVector( sanOrigin );
 	if ( entityNum < 0 || entityNum > MAX_GENTITIES )
-		Com_Error( ERR_DROP, "S_UpdateEntityPosition: bad entitynum %i", entityNum );
+		Com_Error( ERR_DROP, _("S_UpdateEntityPosition: bad entitynum %i"), entityNum );
 	VectorCopy( sanOrigin, entityList[entityNum].origin );
 }
 
@@ -1138,11 +1138,11 @@ Necessary for i.g. Western Quake3 mod which is buggy.
 static qboolean S_AL_CheckInput(int entityNum, sfxHandle_t sfx)
 {
 	if (entityNum < 0 || entityNum > MAX_GENTITIES)
-		Com_Error(ERR_DROP, "ERROR: S_AL_CheckInput: bad entitynum %i", entityNum);
+		Com_Error(ERR_DROP, _("ERROR: S_AL_CheckInput: bad entitynum %i"), entityNum);
 
 	if (sfx < 0 || sfx >= numSfx)
 	{
-		Com_Printf(S_COLOR_RED "ERROR: S_AL_CheckInput: handle %i out of range\n", sfx);
+		Com_Printf(_(S_COLOR_RED "ERROR: S_AL_CheckInput: handle %i out of range\n"), sfx);
 		return qtrue;
 	}
 
@@ -1281,8 +1281,8 @@ static void S_AL_SrcLoop( alSrcPriority_t priority, sfxHandle_t sfx,
 		src = S_AL_SrcAlloc( priority, entityNum, -1 );
 		if( src == -1 )
 		{
-			Com_DPrintf( S_COLOR_YELLOW "WARNING: Failed to allocate source "
-					"for loop sfx %d on entity %d\n", sfx, entityNum );
+			Com_DPrintf( _(S_COLOR_YELLOW "WARNING: Failed to allocate source "
+					"for loop sfx %d on entity %d\n"), sfx, entityNum );
 			return;
 		}
 
@@ -1484,8 +1484,8 @@ void S_AL_SrcUpdate( void )
 							{
 								if(error != AL_INVALID_ENUM)
 								{
-									Com_Printf(S_COLOR_YELLOW "WARNING: Cannot get sample offset from source %d: "
-										   "%s\n", i, S_AL_ErrorMsg(error));
+									Com_Printf(_(S_COLOR_YELLOW "WARNING: Cannot get sample offset from source %d: "
+										   "%s\n"), i, S_AL_ErrorMsg(error));
 								}
 							}
 							else
@@ -1684,7 +1684,7 @@ void S_AL_RawSamples(int stream, int samples, int rate, int width, int channels,
 		// Failed?
 		if(streamSourceHandles[stream] == -1)
 		{
-			Com_Printf( S_COLOR_RED "ERROR: Can't allocate streaming streamSource\n");
+			Com_Printf( _(S_COLOR_RED "ERROR: Can't allocate streaming streamSource\n"));
 			return;
 		}
 	}
@@ -1948,7 +1948,7 @@ void S_AL_MusicProcess(ALuint b)
 	if( ( error = qalGetError( ) ) != AL_NO_ERROR )
 	{
 		S_AL_StopBackgroundTrack( );
-		Com_Printf( S_COLOR_RED "ERROR: while buffering data for music stream - %s\n",
+		Com_Printf( _(S_COLOR_RED "ERROR: while buffering data for music stream - %s\n"),
 				S_AL_ErrorMsg( error ) );
 		return;
 	}
@@ -2056,7 +2056,7 @@ void S_AL_MusicUpdate( void )
 	qalGetSourcei( musicSource, AL_BUFFERS_QUEUED, &numBuffers );
 	if( state == AL_STOPPED && numBuffers )
 	{
-		Com_DPrintf( S_COLOR_YELLOW "Restarted OpenAL music\n" );
+		Com_DPrintf( _(S_COLOR_YELLOW "Restarted OpenAL music\n") );
 		qalSourcePlay(musicSource);
 	}
 
@@ -2280,16 +2280,16 @@ S_AL_SoundInfo
 static
 void S_AL_SoundInfo( void )
 {
-	Com_Printf( "OpenAL info:\n" );
-	Com_Printf( "  Vendor:     %s\n", qalGetString( AL_VENDOR ) );
-	Com_Printf( "  Version:    %s\n", qalGetString( AL_VERSION ) );
-	Com_Printf( "  Renderer:   %s\n", qalGetString( AL_RENDERER ) );
-	Com_Printf( "  AL Extensions: %s\n", qalGetString( AL_EXTENSIONS ) );
-	Com_Printf( "  ALC Extensions: %s\n", qalcGetString( alDevice, ALC_EXTENSIONS ) );
+	Com_Printf( _("OpenAL info:\n") );
+	Com_Printf( _("  Vendor:     %s\n"), qalGetString( AL_VENDOR ) );
+	Com_Printf( _("  Version:    %s\n"), qalGetString( AL_VERSION ) );
+	Com_Printf( _("  Renderer:   %s\n"), qalGetString( AL_RENDERER ) );
+	Com_Printf( _("  AL Extensions: %s\n"), qalGetString( AL_EXTENSIONS ) );
+	Com_Printf( _("  ALC Extensions: %s\n"), qalcGetString( alDevice, ALC_EXTENSIONS ) );
 	if(qalcIsExtensionPresent(NULL, "ALC_ENUMERATION_EXT"))
 	{
-		Com_Printf("  Device:     %s\n", qalcGetString(alDevice, ALC_DEVICE_SPECIFIER));
-		Com_Printf("Available Devices:\n%s", s_alAvailableDevices->string);
+		Com_Printf(_("  Device:     %s\n"), qalcGetString(alDevice, ALC_DEVICE_SPECIFIER));
+		Com_Printf(_("Available Devices:\n%s"), s_alAvailableDevices->string);
 	}
 }
 
@@ -2317,7 +2317,7 @@ void S_AL_Shutdown( void )
 		qalcCaptureStop(alCaptureDevice);
 		qalcCaptureCloseDevice(alCaptureDevice);
 		alCaptureDevice = NULL;
-		Com_Printf( "OpenAL capture device closed.\n" );
+		Com_Printf( _("OpenAL capture device closed.\n") );
 	}
 #endif
 
@@ -2371,7 +2371,7 @@ qboolean S_AL_Init( soundInterface_t *si )
 	// Load QAL
 	if( !QAL_Init( s_alDriver->string ) )
 	{
-		Com_Printf( "Failed to load library: \"%s\".\n", s_alDriver->string );
+		Com_Printf( _("Failed to load library: \"%s\".\n"), s_alDriver->string );
 		return qfalse;
 	}
 
@@ -2415,14 +2415,14 @@ qboolean S_AL_Init( soundInterface_t *si )
 	alDevice = qalcOpenDevice(device);
 	if( !alDevice && device )
 	{
-		Com_Printf( "Failed to open OpenAL device '%s', trying default.\n", device );
+		Com_Printf( _("Failed to open OpenAL device '%s', trying default.\n"), device );
 		alDevice = qalcOpenDevice(NULL);
 	}
 
 	if( !alDevice )
 	{
 		QAL_Shutdown( );
-		Com_Printf( "Failed to open OpenAL device.\n" );
+		Com_Printf( _("Failed to open OpenAL device.\n") );
 		return qfalse;
 	}
 
@@ -2432,7 +2432,7 @@ qboolean S_AL_Init( soundInterface_t *si )
 	{
 		QAL_Shutdown( );
 		qalcCloseDevice( alDevice );
-		Com_Printf( "Failed to create OpenAL context.\n" );
+		Com_Printf( _("Failed to create OpenAL context.\n") );
 		return qfalse;
 	}
 	qalcMakeContextCurrent( alContext );
@@ -2453,12 +2453,12 @@ qboolean S_AL_Init( soundInterface_t *si )
 	s_alCapture = Cvar_Get( "s_alCapture", "1", CVAR_ARCHIVE | CVAR_LATCH );
 	if (!s_alCapture->integer)
 	{
-		Com_Printf("OpenAL capture support disabled by user ('+set s_alCapture 1' to enable)\n");
+		Com_Printf(_("OpenAL capture support disabled by user ('+set s_alCapture 1' to enable)\n"));
 	}
 #if USE_MUMBLE
 	else if (cl_useMumble->integer)
 	{
-		Com_Printf("OpenAL capture support disabled for Mumble support\n");
+		Com_Printf(_("OpenAL capture support disabled for Mumble support\n"));
 	}
 #endif
 	else
@@ -2474,7 +2474,7 @@ qboolean S_AL_Init( soundInterface_t *si )
 		if (!qalcIsExtensionPresent(NULL, "ALC_EXT_capture"))
 #endif
 		{
-			Com_Printf("No ALC_EXT_capture support, can't record audio.\n");
+			Com_Printf(_("No ALC_EXT_capture support, can't record audio.\n"));
 		}
 		else
 		{
@@ -2482,10 +2482,10 @@ qboolean S_AL_Init( soundInterface_t *si )
 			// !!! FIXME:  should probably open the capture device after
 			// !!! FIXME:  initializing Speex so we can change to wideband
 			// !!! FIXME:  if we like.
-			Com_Printf("OpenAL default capture device is '%s'\n",
+			Com_Printf(_("OpenAL default capture device is '%s'\n"),
 			           qalcGetString(NULL, ALC_CAPTURE_DEFAULT_DEVICE_SPECIFIER));
 			alCaptureDevice = qalcCaptureOpenDevice(NULL, 8000, AL_FORMAT_MONO16, 4096);
-			Com_Printf( "OpenAL capture device %s.\n",
+			Com_Printf( _("OpenAL capture device %s.\n"),
 			            (alCaptureDevice == NULL) ? "failed to open" : "opened");
 		}
 	}
diff --git a/src/game/bg_local.h b/src/game/bg_local.h
index 6a3fd72..fc3422e 100644
--- a/src/game/bg_local.h
+++ b/src/game/bg_local.h
@@ -35,6 +35,8 @@ Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 
 #define FALLING_THRESHOLD -900.0f //what vertical speed to start falling sound at
 
+#define _(String) gettext(String)
+
 
 // all of the locals will be zeroed before each
 // pmove, just to make damn sure we don't have
diff --git a/src/game/g_local.h b/src/game/g_local.h
index a55561e..48d76d4 100644
--- a/src/game/g_local.h
+++ b/src/game/g_local.h
@@ -53,6 +53,8 @@ typedef struct gclient_s gclient_t;
 #define FL_NO_HUMANS      0x00004000  // spawn point just for bots
 #define FL_FORCE_GESTURE  0x00008000  // spawn point just for bots
 
+#define _(String) gettext(String)
+
 // movers are things like doors, plats, buttons, etc
 typedef enum
 {
@@ -1213,3 +1215,6 @@ void      trap_SendGameStat( const char *data );
 
 void      trap_AddCommand( const char *cmdName );
 void      trap_RemoveCommand( const char *cmdName );
+
+void      trap_Gettext ( char *buffer, const char *msgid, int bufferLength );
+char      *gettext ( const char *msgid );
diff --git a/src/game/g_main.c b/src/game/g_main.c
index 797ad6a..83f0aeb 100644
--- a/src/game/g_main.c
+++ b/src/game/g_main.c
@@ -2405,3 +2405,14 @@ void G_RunFrame( int levelTime )
   level.frameMsec = trap_Milliseconds();
 }
 
+char *gettext ( const char *msgid )
+{
+  static char string[8][32000];
+  static int  index = 0;
+	char        *buf = string[index++ & 7];
+
+  trap_Gettext( buf, msgid, sizeof( *string ) );
+
+  return buf;
+}
+
diff --git a/src/game/g_public.h b/src/game/g_public.h
index 312a5e5..d68105a 100644
--- a/src/game/g_public.h
+++ b/src/game/g_public.h
@@ -225,7 +225,9 @@ typedef enum {
   G_SEND_GAMESTAT,
 
   G_ADDCOMMAND,
-  G_REMOVECOMMAND
+  G_REMOVECOMMAND,
+
+  G_GETTEXT = 300
 } gameImport_t;
 
 
diff --git a/src/game/g_syscalls.asm b/src/game/g_syscalls.asm
index f39b138..6f84478 100644
--- a/src/game/g_syscalls.asm
+++ b/src/game/g_syscalls.asm
@@ -66,3 +66,5 @@ equ floor                             -111
 equ ceil                              -112
 equ testPrintInt                      -113
 equ testPrintFloat                    -114
+
+equ trap_Gettext                      -301
diff --git a/src/game/g_syscalls.c b/src/game/g_syscalls.c
index 38e5203..b244416 100644
--- a/src/game/g_syscalls.c
+++ b/src/game/g_syscalls.c
@@ -297,3 +297,25 @@ void trap_RemoveCommand( const char *cmdName )
   syscall( G_REMOVECOMMAND, cmdName );
 }
 
+void trap_Gettext( char *buffer, const char *msgid, int bufferLength )
+{
+  static int engineState = 0;
+
+  if( !( engineState & 0x01 ) )
+  {
+    char t[2];
+
+    engineState |= 0x01;
+
+    trap_Cvar_VariableStringBuffer( "\\IS_GETTEXT_SUPPORTED", t, 2 );
+
+    if( t[0] == '1' )
+      engineState |= 0x02;
+  }
+
+  if( !( engineState & 0x02 ) )
+    strncpy( buffer, msgid, bufferLength );
+  else
+    syscall( G_GETTEXT, buffer, msgid, bufferLength );
+}
+
diff --git a/src/null/null_client.c b/src/null/null_client.c
index 5c96ccb..60ce018 100644
--- a/src/null/null_client.c
+++ b/src/null/null_client.c
@@ -45,7 +45,7 @@ void CL_Frame ( int msec ) {
 void CL_PacketEvent( netadr_t from, msg_t *msg ) {
 }
 
-void CL_CharEvent( int key ) {
+void CL_CharEvent( const char *key ) {
 }
 
 void CL_Disconnect( qboolean showMainMenu ) {
diff --git a/src/qcommon/cmd.c b/src/qcommon/cmd.c
index 7ce50cc..6e31910 100644
--- a/src/qcommon/cmd.c
+++ b/src/qcommon/cmd.c
@@ -482,8 +482,8 @@ will point into this temporary buffer.
 // NOTE TTimo define that to track tokenization issues
 //#define TKN_DBG
 static void Cmd_TokenizeString2( const char *text_in, qboolean ignoreQuotes ) {
-	const char	*text;
-	char	*textOut;
+	const unsigned char *text;
+	unsigned char *textOut;
 
 #ifdef TKN_DBG
   // FIXME TTimo blunt hook to try to find the tokenization of userinfo
@@ -500,8 +500,8 @@ static void Cmd_TokenizeString2( const char *text_in, qboolean ignoreQuotes ) {
 	
 	Q_strncpyz( cmd.cmd, text_in, sizeof(cmd.cmd) );
 
-	text = text_in;
-	textOut = cmd.tokenized;
+	text = (const unsigned char *) text_in;
+	textOut = (unsigned char *) cmd.tokenized;
 
 	while ( 1 ) {
 		if ( cmd.argc == MAX_STRING_TOKENS ) {
@@ -539,7 +539,7 @@ static void Cmd_TokenizeString2( const char *text_in, qboolean ignoreQuotes ) {
 		// handle quoted strings
     // NOTE TTimo this doesn't handle \" escaping
 		if ( !ignoreQuotes && *text == '"' ) {
-			cmd.argv[cmd.argc] = textOut;
+			cmd.argv[cmd.argc] = (char *) textOut;
 			cmd.argc++;
 			text++;
 			while ( *text && *text != '"' ) {
@@ -554,7 +554,7 @@ static void Cmd_TokenizeString2( const char *text_in, qboolean ignoreQuotes ) {
 		}
 
 		// regular token
-		cmd.argv[cmd.argc] = textOut;
+		cmd.argv[cmd.argc] = (char *) textOut;
 		cmd.argc++;
 
 		// skip until whitespace, quote, or command
diff --git a/src/qcommon/common.c b/src/qcommon/common.c
index d9fb449..f7ec32b 100644
--- a/src/qcommon/common.c
+++ b/src/qcommon/common.c
@@ -82,6 +82,7 @@ cvar_t	*com_unfocused;
 cvar_t	*com_maxfpsUnfocused;
 cvar_t	*com_minimized;
 cvar_t	*com_maxfpsMinimized;
+cvar_t  *com_translatePrint;
 
 // com_speeds times
 int		time_game;
@@ -141,7 +142,7 @@ A raw string should NEVER be passed as fmt, because of "%f" type crashers.
 */
 void QDECL Com_Printf( const char *fmt, ... ) {
 	va_list		argptr;
-	char		msg[MAXPRINTMSG];
+	char		msg[MAXPRINTMSG], *str = msg;
   static qboolean opening_qconsole = qfalse;
 
 
@@ -161,14 +162,17 @@ void QDECL Com_Printf( const char *fmt, ... ) {
 		return;
 	}
 
+	if ( com_translatePrint && com_translatePrint->integer )
+		str = Sys_Gettext( msg );
+
 #ifndef DEDICATED
-	CL_ConsolePrint( msg );
+	CL_ConsolePrint( str );
 #endif
 
-	Q_StripIndentMarker( msg );
+	Q_StripIndentMarker( str );
 
 	// echo to dedicated console and early console
-	Sys_Print( msg );
+	Sys_Print( str );
 
 	// logfile
 	if ( com_logfile && com_logfile->integer ) {
@@ -205,7 +209,7 @@ void QDECL Com_Printf( const char *fmt, ... ) {
       opening_qconsole = qfalse;
 		}
 		if ( logfile && FS_Initialized()) {
-			FS_Write(msg, strlen(msg), logfile);
+			FS_Write(str, strlen(str), logfile);
 		}
 	}
 }
@@ -2226,7 +2230,7 @@ int Com_EventLoop( void ) {
 			CL_KeyEvent( ev.evValue, ev.evValue2, ev.evTime );
 			break;
 		case SE_CHAR:
-			CL_CharEvent( ev.evValue );
+			CL_CharEvent( (const char *) ev.evPtr );
 			break;
 		case SE_MOUSE:
 			CL_MouseEvent( ev.evValue, ev.evValue2, ev.evTime );
@@ -2617,6 +2621,8 @@ void Com_Init( char *commandLine ) {
 	com_minimized = Cvar_Get( "com_minimized", "0", CVAR_ROM );
 	com_maxfpsMinimized = Cvar_Get( "com_maxfpsMinimized", "0", CVAR_ARCHIVE );
 
+	com_ansiColor = Cvar_Get( "com_translatePrint", "0", CVAR_ARCHIVE );
+
 	s = va("%s %s %s", Q3_VERSION, PLATFORM_STRING, __DATE__ );
 	com_version = Cvar_Get ("version", s, CVAR_ROM | CVAR_SERVERINFO );
 
diff --git a/src/qcommon/cvar.c b/src/qcommon/cvar.c
index b0a2150..70cdfbd 100644
--- a/src/qcommon/cvar.c
+++ b/src/qcommon/cvar.c
@@ -613,6 +613,92 @@ void Cvar_Set( const char *var_name, const char *value) {
 
 /*
 ============
+Cvar_SetIFlag
+
+Sets the cvar by the name that begins with a backslash to "1".  This creates a
+cvar that can be set by the engine but not by the sure, and can be read by
+interpreted modules.
+============
+*/
+void Cvar_SetIFlag( const char *var_name )
+{
+	cvar_t *var;
+	long hash;
+	int index;
+
+	if ( !var_name ) {
+		Com_Error( ERR_FATAL, "Cvar_SetIFlag: NULL parameter" );
+	}
+
+  if ( *var_name != '\\' ) {
+		Com_Error( ERR_FATAL, "Cvar_SetIFlag: var_name must begin with a '\\'" );
+  }
+
+  /*
+  if ( Cvar_FindVar( var_name ) ) {
+		Com_Error( ERR_FATAL, "Cvar_SetIFlag: %s already exists.", var_name );
+  }
+  */
+
+	if ( !Cvar_ValidateString( var_name + 1 ) ) {
+		Com_Printf("invalid cvar name string: %s\n", var_name );
+		var_name = "BADNAME";
+	}
+
+	// find a free cvar
+	for(index = 0; index < MAX_CVARS; index++)
+	{
+		if(!cvar_indexes[index].name)
+			break;
+	}
+
+	if(index >= MAX_CVARS)
+	{
+		if(!com_errorEntered)
+			Com_Error(ERR_FATAL, "Error: Too many cvars, cannot create a new one!");
+
+		return;
+	}
+	
+	var = &cvar_indexes[index];
+
+	if(index >= cvar_numIndexes)
+		cvar_numIndexes = index + 1;
+		
+	var->name = CopyString (var_name);
+	var->string = CopyString ("1");
+	var->modified = qtrue;
+	var->modificationCount = 1;
+	var->value = atof (var->string);
+	var->integer = atoi(var->string);
+	var->resetString = CopyString( "1" );
+	var->validate = qfalse;
+
+	// link the variable in
+	var->next = cvar_vars;
+	if(cvar_vars)
+		cvar_vars->prev = var;
+
+	var->prev = NULL;
+	cvar_vars = var;
+
+	var->flags = CVAR_INIT;
+	// note what types of cvars have been modified (userinfo, archive, serverinfo, systeminfo)
+	cvar_modifiedFlags |= var->flags;
+
+	hash = generateHashValue(var_name);
+	var->hashIndex = hash;
+
+	var->hashNext = hashTable[hash];
+	if(hashTable[hash])
+		hashTable[hash]->hashPrev = var;
+
+	var->hashPrev = NULL;
+	hashTable[hash] = var;
+}
+
+/*
+============
 Cvar_SetLatched
 ============
 */
diff --git a/src/qcommon/files.c b/src/qcommon/files.c
index 807be3f..e07ade2 100644
--- a/src/qcommon/files.c
+++ b/src/qcommon/files.c
@@ -1110,6 +1110,8 @@ int FS_FOpenFileRead( const char *filename, fileHandle_t *file, qboolean uniqueF
 					if ( !(pak->referenced & FS_GENERAL_REF)) {
 						if ( Q_stricmp(filename + l - 7, ".shader") != 0 &&
 							Q_stricmp(filename + l - 4, ".txt") != 0 &&
+							Q_stricmp(filename + l - 4, ".ttf") != 0 &&
+							Q_stricmp(filename + l - 4, ".otf") != 0 &&
 							Q_stricmp(filename + l - 4, ".cfg") != 0 &&
 							Q_stricmp(filename + l - 7, ".config") != 0 &&
 							strstr(filename, "levelshots") == NULL &&
@@ -1169,6 +1171,8 @@ int FS_FOpenFileRead( const char *filename, fileHandle_t *file, qboolean uniqueF
 			if ( fs_numServerPaks ) {
 
 				if ( Q_stricmp( filename + l - 4, ".cfg" )		// for config files
+					&& Q_stricmp( filename + l - 4, ".otf" )
+					&& Q_stricmp( filename + l - 4, ".ttf" )
 					&& Q_stricmp( filename + l - 5, ".menu" )	// menu files
 					&& Q_stricmp( filename + l - 5, ".game" )	// menu files
 					&& Q_stricmp( filename + l - strlen(demoExt), demoExt )	// menu files
diff --git a/src/qcommon/msg.c b/src/qcommon/msg.c
index c85360c..76336b4 100644
--- a/src/qcommon/msg.c
+++ b/src/qcommon/msg.c
@@ -301,7 +301,7 @@ void MSG_WriteString( msg_t *sb, const char *s ) {
 	if ( !s ) {
 		MSG_WriteData (sb, "", 1);
 	} else {
-		int		l,i;
+		int		l;
 		char	string[MAX_STRING_CHARS];
 
 		l = strlen( s );
@@ -312,13 +312,6 @@ void MSG_WriteString( msg_t *sb, const char *s ) {
 		}
 		Q_strncpyz( string, s, sizeof( string ) );
 
-		// get rid of 0x80+ chars, because old clients don't like them
-		for ( i = 0 ; i < l ; i++ ) {
-			if ( ((byte *)string)[i] > 127 ) {
-				string[i] = '.';
-			}
-		}
-
 		MSG_WriteData (sb, string, l+1);
 	}
 }
@@ -327,7 +320,7 @@ void MSG_WriteBigString( msg_t *sb, const char *s ) {
 	if ( !s ) {
 		MSG_WriteData (sb, "", 1);
 	} else {
-		int		l,i;
+		int		l;
 		char	string[BIG_INFO_STRING];
 
 		l = strlen( s );
@@ -338,13 +331,6 @@ void MSG_WriteBigString( msg_t *sb, const char *s ) {
 		}
 		Q_strncpyz( string, s, sizeof( string ) );
 
-		// get rid of 0x80+ chars, because old clients don't like them
-		for ( i = 0 ; i < l ; i++ ) {
-			if ( ((byte *)string)[i] > 127 ) {
-				string[i] = '.';
-			}
-		}
-
 		MSG_WriteData (sb, string, l+1);
 	}
 }
@@ -440,10 +426,6 @@ char *MSG_ReadString( msg_t *msg ) {
 		if ( c == -1 || c == 0 ) {
 			break;
 		}
-		// don't allow higher ascii values
-		if ( c > 127 ) {
-			c = '.';
-		}
 
 		string[l] = c;
 		l++;
@@ -464,10 +446,6 @@ char *MSG_ReadBigString( msg_t *msg ) {
 		if ( c == -1 || c == 0 ) {
 			break;
 		}
-		// don't allow higher ascii values
-		if ( c > 127 ) {
-			c = '.';
-		}
 
 		string[l] = c;
 		l++;
@@ -488,10 +466,6 @@ char *MSG_ReadStringLine( msg_t *msg ) {
 		if (c == -1 || c == 0 || c == '\n') {
 			break;
 		}
-		// don't allow higher ascii values
-		if ( c > 127 ) {
-			c = '.';
-		}
 
 		string[l] = c;
 		l++;
diff --git a/src/qcommon/q_shared.c b/src/qcommon/q_shared.c
index ce28f95..6de269f 100644
--- a/src/qcommon/q_shared.c
+++ b/src/qcommon/q_shared.c
@@ -978,6 +978,248 @@ void QDECL Com_sprintf( char *dest, int size, const char *fmt, ...) {
 
 
 /*
+============================================================================
+
+					UTF-8
+
+============================================================================
+*/
+
+// never returns more than 4
+int Q_UTF8Width( const char *str )
+{
+  int                 ewidth;
+  const unsigned char *s = (const unsigned char *)str;
+
+  if( !str )
+    return 0;
+
+  if     ( 0x00 <= *s && *s <= 0x7F )
+    ewidth = 0;
+  else if( 0xC2 <= *s && *s <= 0xDF )
+    ewidth = 1;
+  else if( 0xE0 <= *s && *s <= 0xEF )
+    ewidth = 2;
+  else if( 0xF0 <= *s && *s <= 0xF4 )
+    ewidth = 3;
+  else
+    ewidth = 0;
+
+  for( ; *s && ewidth > 0; s++, ewidth-- );
+
+  return s - (const unsigned char *)str + 1;
+}
+
+int Q_UTF8Strlen( const char *str )
+{
+  int l = 0;
+
+  while( *str )
+  {
+    l++;
+
+    str += Q_UTF8Width( str );
+  }
+
+  return l;
+}
+
+int Q_UTF8PrintStrlen( const char *str )
+{
+  int l = 0;
+
+  while( *str )
+  {
+    if( Q_IsColorString( str ) )
+    {
+      str += 2;
+      continue;
+    }
+
+    l++;
+
+    str += Q_UTF8Width( str );
+  }
+
+  return l;
+}
+
+qboolean Q_UTF8ContByte( char c )
+{
+  return (unsigned char )0x80 <= (unsigned char)c && (unsigned char)c <= (unsigned char )0xBF;
+}
+
+static qboolean getbit(const unsigned char *p, int pos)
+{
+  p   += pos / 8;
+  pos %= 8;
+
+  return (*p & (1 << (7 - pos))) != 0;
+}
+
+static void setbit(unsigned char *p, int pos, qboolean on)
+{
+  p   += pos / 8;
+  pos %= 8;
+
+  if( on )
+    *p |= 1 << (7 - pos);
+  else
+    *p &= ~(1 << (7 - pos));
+}
+
+static void shiftbitsright(unsigned char *p, unsigned long num, unsigned long by)
+{
+  int step, off;
+  unsigned char *e;
+
+  if( by >= num )
+  {
+    for( ; num > 8; p++, num -= 8 )
+      *p = 0;
+
+    *p &= (~0x00) >> num;
+
+    return;
+  }
+
+  step = by / 8;
+  off  = by % 8;
+
+  for( e = p + (num + 7) / 8 - 1; e > p + step; e-- )
+    *e = (*(e - step) >> off) | (*(e - step - 1) << (8 - off));
+
+  *e = *(e - step) >> off;
+
+  for( e = p; e < p + step; e++ )
+    *e = 0;
+}
+
+unsigned long Q_UTF8CodePoint( const char *str )
+{
+  int i, j;
+  int n = 0;
+  int size = Q_UTF8Width( str );
+  unsigned long codepoint = 0;
+  unsigned char *p = (unsigned char *) &codepoint;
+
+  if( size > sizeof( codepoint ) )
+    size = sizeof( codepoint );
+  else if( size < 1 )
+    size = 1;
+
+  for( i = (size > 1 ? size + 1 : 1); i < 8; i++ )
+    setbit(p, n++, getbit((const unsigned char *)str, i));
+  for( i = 1; i < size; i++ )
+    for( j = 2; j < 8; j++ )
+      setbit(p, n++, getbit(((const unsigned char *)str) + i, j));
+
+  /*
+  if( n > 8 * sizeof(codepoint) )
+  {
+		Com_Error( ERR_DROP, "Q_UTF8CodePoint: overflow caught" );
+
+    return 0;
+  }
+  */
+
+  shiftbitsright(p, 8 * sizeof(codepoint), 8 * sizeof(codepoint) - n);
+
+#ifndef Q3_BIG_ENDIAN
+  for( i = 0; i < sizeof(codepoint) / 2; i++ )
+  {
+    p[i] ^= p[sizeof(codepoint) - 1 - i];
+    p[sizeof(codepoint) - 1 - i] ^= p[i];
+    p[i] ^= p[sizeof(codepoint) - 1 - i];
+  }
+#endif
+
+  return codepoint;
+}
+
+char *Q_UTF8Encode( unsigned long codepoint )
+{
+  static char sbuf[2][5];
+  static int index = 0;
+  char *buf = sbuf[index++ & 1];
+
+  if     (                        codepoint <= 0x007F )
+  {
+    buf[0] = codepoint;
+    buf[1] = 0;
+  }
+  else if( 0x0080 <= codepoint && codepoint <= 0x07FF )
+  {
+    buf[0] = 0xC0 | ((codepoint & 0x0700) >> 6) | ((codepoint & 0x00C0) >> 6);
+    buf[1] = 0x80 | (codepoint & 0x003F);
+    buf[2] = 0;
+  }
+  else if( 0x0800 <= codepoint && codepoint <= 0xFFFF )
+  {
+    buf[0] = 0xE0 | ((codepoint & 0xF000) >> 12);
+    buf[1] = 0x80 | ((codepoint & 0x0F00) >> 6) | ((codepoint & 0x00C0) >> 6);
+    buf[2] = 0x80 | (codepoint & 0x003F);
+    buf[3] = 0;
+  }
+  else if( 0x010000 <= codepoint && codepoint <= 0x10FFFF )
+  {
+    buf[0] = 0xF0 | ((codepoint & 0x1C0000 >> 18));
+    buf[1] = 0x80 | ((codepoint & 0x030000 >> 16)) | ((codepoint & 0x00F000) >> 12);
+    buf[2] = 0x80 | ((codepoint & 0x000F00) >> 6) | ((codepoint & 0x0000C0) >> 6);
+    buf[3] = 0x80 | (codepoint & 0x00003F);
+    buf[4] = 0;
+  }
+  else
+  {
+    buf[0] = 0;
+  }
+
+  return buf;
+}
+
+// s needs to have at least sizeof(int) allocated
+int Q_UTF8Store( const char *s )
+{
+#ifdef Q3_BIG_ENDIAN
+  int r = *(int *)s, i;
+  unsigned char *p = (unsigned char *) &r;
+  for( i = 0; i < sizeof(r) / 2; i++ )
+  {
+    p[i] ^= p[sizeof(r) - 1 - i];
+    p[sizeof(r) - 1 - i] ^= p[i];
+    p[i] ^= p[sizeof(r) - 1 - i];
+  }
+  return r;
+#else
+  return *(int *)s;
+#endif
+}
+
+char *Q_UTF8Unstore( int e )
+{
+  static char sbuf[2][5];
+  static int index = 0;
+  char *buf = sbuf[index++ & 1];
+
+#ifdef Q3_BIG_ENDIAN
+  int i;
+  unsigned char *p = (unsigned char *) buf;
+  *(int *)buf = e;
+  for( i = 0; i < sizeof(e) / 2; i++ )
+  {
+    p[i] ^= p[sizeof(e) - 1 - i];
+    p[sizeof(e) - 1 - i] ^= p[i];
+    p[i] ^= p[sizeof(e) - 1 - i];
+  }
+#else
+  *(int *)buf = e;
+#endif
+
+  return buf;
+}
+
+
+/*
 ============
 va
 
diff --git a/src/qcommon/q_shared.h b/src/qcommon/q_shared.h
index 4468558..6ea264b 100644
--- a/src/qcommon/q_shared.h
+++ b/src/qcommon/q_shared.h
@@ -802,6 +802,17 @@ int Q_CountChar(const char *string, char tocount);
 
 //=============================================
 
+int Q_UTF8Width( const char *str );
+int Q_UTF8Strlen( const char *str );
+int Q_UTF8PrintStrlen( const char *str );
+qboolean Q_UTF8ContByte( char c );
+unsigned long Q_UTF8CodePoint( const char *str );
+char *Q_UTF8Encode( unsigned long codepoint );
+int Q_UTF8Store( const char *s );
+char *Q_UTF8Unstore( int e );
+
+//=============================================
+
 // 64-bit integers for global rankings interface
 // implemented as a struct for qvm compatibility
 typedef struct
@@ -1010,6 +1021,11 @@ typedef struct {
 #define	KEYCATCH_UI					0x0002
 #define	KEYCATCH_CGAME			0x0008
 
+#define KEYEVSTATE_DOWN 0
+#define KEYEVSTATE_CHAR 1
+#define KEYEVSTATE_BIT  2
+#define KEYEVSTATE_SUP  3
+
 
 // sound channels
 // channel 0 never willingly overrides
@@ -1330,6 +1346,16 @@ typedef struct {
   char name[MAX_QPATH];
 } fontInfo_t;
 
+#define MAX_FACE_GLYPHS 384
+
+typedef struct {
+  void *opaque;
+  void *mem;
+  void *images[MAX_FACE_GLYPHS];
+  char name[MAX_QPATH];
+  float glyphScale;
+} face_t;
+
 #define Square(x) ((x)*(x))
 
 // real time
diff --git a/src/qcommon/qcommon.h b/src/qcommon/qcommon.h
index 18f4c5e..0490322 100644
--- a/src/qcommon/qcommon.h
+++ b/src/qcommon/qcommon.h
@@ -489,6 +489,9 @@ void	Cvar_Update( vmCvar_t *vmCvar );
 void 	Cvar_Set( const char *var_name, const char *value );
 // will create the variable with no flags if it doesn't exist
 
+void Cvar_SetIFlag( const char *var_name );
+// sets the cvar by the name that begins with a backslash to "1"
+
 void Cvar_SetLatched( const char *var_name, const char *value);
 // don't set the cvar immediately
 
@@ -817,6 +820,7 @@ extern	cvar_t	*com_maxfpsUnfocused;
 extern	cvar_t	*com_minimized;
 extern	cvar_t	*com_maxfpsMinimized;
 extern	cvar_t	*com_altivec;
+extern	cvar_t	*com_translatePrint;
 
 // both client and server must agree to pause
 extern	cvar_t	*cl_paused;
@@ -928,7 +932,7 @@ void CL_Frame( int msec );
 qboolean CL_GameCommand( void );
 void CL_KeyEvent (int key, qboolean down, unsigned time);
 
-void CL_CharEvent( int key );
+void CL_CharEvent( const char *key );
 // char events are for field typing, not game control
 
 void CL_MouseEvent( int dx, int dy, int time );
@@ -1084,6 +1088,8 @@ qboolean Sys_LowPhysicalMemory( void );
 
 void Sys_SetEnv(const char *name, const char *value);
 
+char *Sys_Gettext(const char *msgid);
+
 /* This is based on the Adaptive Huffman algorithm described in Sayood's Data
  * Compression book.  The ranks are not actually stored, but implicitly defined
  * by the location of a node within a doubly-linked list */
diff --git a/src/renderer/tr_backend.c b/src/renderer/tr_backend.c
index 54431ab..509cc4a 100644
--- a/src/renderer/tr_backend.c
+++ b/src/renderer/tr_backend.c
@@ -999,31 +999,33 @@ void RB_ShowImages( void ) {
 
 	start = ri.Milliseconds();
 
-	for ( i=0 ; i<tr.numImages ; i++ ) {
-		image = tr.images[i];
-
-		w = glConfig.vidWidth / 20;
-		h = glConfig.vidHeight / 15;
-		x = i % 20 * w;
-		y = i / 20 * h;
-
-		// show in proportional size in mode 2
-		if ( r_showImages->integer == 2 ) {
-			w *= image->uploadWidth / 512.0f;
-			h *= image->uploadHeight / 512.0f;
-		}
-
-		GL_Bind( image );
-		qglBegin (GL_QUADS);
-		qglTexCoord2f( 0, 0 );
-		qglVertex2f( x, y );
-		qglTexCoord2f( 1, 0 );
-		qglVertex2f( x + w, y );
-		qglTexCoord2f( 1, 1 );
-		qglVertex2f( x + w, y + h );
-		qglTexCoord2f( 0, 1 );
-		qglVertex2f( x, y + h );
-		qglEnd();
+	for ( i=0 ; i<MAX_DRAWIMAGES ; i++ ) {
+    if( tr.used_images[ i ] ) {
+      image = tr.images[i];
+
+      w = glConfig.vidWidth / 20;
+      h = glConfig.vidHeight / 15;
+      x = i % 20 * w;
+      y = i / 20 * h;
+
+      // show in proportional size in mode 2
+      if ( r_showImages->integer == 2 ) {
+        w *= image->uploadWidth / 512.0f;
+        h *= image->uploadHeight / 512.0f;
+      }
+
+      GL_Bind( image );
+      qglBegin (GL_QUADS);
+      qglTexCoord2f( 0, 0 );
+      qglVertex2f( x, y );
+      qglTexCoord2f( 1, 0 );
+      qglVertex2f( x + w, y );
+      qglTexCoord2f( 1, 1 );
+      qglVertex2f( x + w, y + h );
+      qglTexCoord2f( 0, 1 );
+      qglVertex2f( x, y + h );
+      qglEnd();
+    }
 	}
 
 	qglFinish();
diff --git a/src/renderer/tr_font.c b/src/renderer/tr_font.c
index 3fe80d0..283231d 100644
--- a/src/renderer/tr_font.c
+++ b/src/renderer/tr_font.c
@@ -75,6 +75,7 @@ Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 #include "../qcommon/qcommon.h"
 
 #ifdef BUILD_FREETYPE
+
 #include <ft2build.h>
 #include <freetype/fterrors.h>
 #include <freetype/ftsystem.h>
@@ -89,7 +90,7 @@ Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 FT_Library ftLibrary = NULL;  
 #endif
 
-#define MAX_FONTS 6
+#define MAX_FONTS 12
 static int registeredFontCount = 0;
 static fontInfo_t registeredFont[MAX_FONTS];
 
@@ -137,7 +138,6 @@ FT_Bitmap *R_RenderGlyph(FT_GlyphSlot glyph, glyphInfo_t* glyphOut) {
     glyphOut->pitch = pitch;
     glyphOut->top = (glyph->metrics.horiBearingY >> 6) + 1;
     glyphOut->bottom = bottom;
-    
     return bit2;
   }
   else {
@@ -146,11 +146,13 @@ FT_Bitmap *R_RenderGlyph(FT_GlyphSlot glyph, glyphInfo_t* glyphOut) {
   return NULL;
 }
 
-void WriteTGA (char *filename, byte *data, int width, int height) {
+static void WriteTGA(char *filename, byte * data, int width, int height)
+{
 	byte	*buffer;
 	int		i, c;
 
 	buffer = Z_Malloc(width*height*4 + 18);
+
 	Com_Memset (buffer, 0, 18);
 	buffer[2] = 2;		// uncompressed type
 	buffer[12] = width&255;
@@ -169,16 +171,31 @@ void WriteTGA (char *filename, byte *data, int width, int height) {
 		buffer[i+3] = data[i-18+3];		// alpha
 	}
 
-	ri.FS_WriteFile(filename, buffer, c);
+	// Tr3B: flip upside down
+	{
+		int             row;
+		unsigned char  *flip;
+		unsigned char  *src, *dst;
+
+		flip = (unsigned char *)malloc(width * 4);
+		for(row = 0; row < height / 2; row++)
+		{
+			src = buffer + 18 + (row * 4 * width);
+			dst = buffer + 18 + ((height - row - 1) * 4 * width);
+
+			memcpy(flip, src, width * 4);
+			memcpy(src, dst, width * 4);
+			memcpy(dst, flip, width * 4);
+		}
+		free(flip);
+	}
 
-	//f = fopen (filename, "wb");
-	//fwrite (buffer, 1, c, f);
-	//fclose (f);
+	ri.FS_WriteFile(filename, buffer, c);
 
 	Z_Free (buffer);
 }
 
-static glyphInfo_t *RE_ConstructGlyphInfo(unsigned char *imageOut, int *xOut, int *yOut, int *maxHeight, FT_Face face, const unsigned char c, qboolean calcHeight) {
+static glyphInfo_t *RE_ConstructGlyphInfo(int max, unsigned char *imageOut, int *xOut, int *yOut, int *maxHeight, FT_Face face, const unsigned long c, qboolean calcHeight) {
   int i;
   static glyphInfo_t glyph;
   unsigned char *src, *dst;
@@ -188,7 +205,13 @@ static glyphInfo_t *RE_ConstructGlyphInfo(unsigned char *imageOut, int *xOut, in
   Com_Memset(&glyph, 0, sizeof(glyphInfo_t));
   // make sure everything is here
   if (face != NULL) {
-    FT_Load_Glyph(face, FT_Get_Char_Index( face, c), FT_LOAD_DEFAULT );
+    FT_UInt ci = FT_Get_Char_Index( face, c );
+    if( !ci )
+    {
+      ri.Printf(PRINT_ALL, "Unrecognized character\n");
+      return &glyph;
+    }
+    FT_Load_Glyph(face, ci, FT_LOAD_DEFAULT );
     bitmap = R_RenderGlyph(face->glyph, &glyph);
     if (bitmap) {
       glyph.xSkip = (face->glyph->metrics.horiAdvance >> 6) + 1;
@@ -219,8 +242,8 @@ static glyphInfo_t *RE_ConstructGlyphInfo(unsigned char *imageOut, int *xOut, in
     scaled_height = glyph.height;
 
     // we need to make sure we fit
-    if (*xOut + scaled_width + 1 >= 255) {
-      if (*yOut + *maxHeight + 1 >= 255) {
+    if (*xOut + scaled_width + 1 >= max - 1) {
+      if (*yOut + *maxHeight + 1 >= max - 1) {
         *yOut = -1;
         *xOut = -1;
         Z_Free(bitmap->buffer);
@@ -230,7 +253,7 @@ static glyphInfo_t *RE_ConstructGlyphInfo(unsigned char *imageOut, int *xOut, in
         *xOut = 0;
         *yOut += *maxHeight + 1;
       }
-    } else if (*yOut + *maxHeight + 1 >= 255) {
+    } else if (*yOut + *maxHeight + 1 >= max - 1) {
       *yOut = -1;
       *xOut = -1;
       Z_Free(bitmap->buffer);
@@ -240,7 +263,7 @@ static glyphInfo_t *RE_ConstructGlyphInfo(unsigned char *imageOut, int *xOut, in
 
 
     src = bitmap->buffer;
-    dst = imageOut + (*yOut * 256) + *xOut;
+    dst = imageOut + (*yOut * max) + *xOut;
 
 		if (bitmap->pixel_mode == ft_pixel_mode_mono) {
 			for (i = 0; i < glyph.height; i++) {
@@ -265,14 +288,14 @@ static glyphInfo_t *RE_ConstructGlyphInfo(unsigned char *imageOut, int *xOut, in
 				}
 
 				src += glyph.pitch;
-				dst += 256;
+				dst += max;
 
 			}
 		} else {
 	    for (i = 0; i < glyph.height; i++) {
 		    Com_Memcpy(dst, src, glyph.pitch);
 			  src += glyph.pitch;
-				dst += 256;
+				dst += max;
 	    }
 		}
 
@@ -281,10 +304,10 @@ static glyphInfo_t *RE_ConstructGlyphInfo(unsigned char *imageOut, int *xOut, in
 
     glyph.imageHeight = scaled_height;
     glyph.imageWidth = scaled_width;
-    glyph.s = (float)*xOut / 256;
-    glyph.t = (float)*yOut / 256;
-    glyph.s2 = glyph.s + (float)scaled_width / 256;
-    glyph.t2 = glyph.t + (float)scaled_height / 256;
+    glyph.s = (float)*xOut / max;
+    glyph.t = (float)*yOut / max;
+    glyph.s2 = glyph.s + (float)scaled_width / max;
+    glyph.t2 = glyph.t + (float)scaled_height / max;
 
     *xOut += scaled_width + 1;
   }
@@ -327,6 +350,387 @@ float readFloat( void ) {
 	return me.ffred;
 }
 
+#ifdef BUILD_FREETYPE
+
+static unsigned long stream_read(FT_Stream stream, unsigned long offset, unsigned char *buffer, unsigned long count )
+{
+  if( count == 0 )
+  {
+    int r = FS_Seek( (fileHandle_t) stream->descriptor.value, (long) offset, FS_SEEK_SET );
+    if( r == offset )
+      return 0;
+    else
+      return r;
+  }
+
+  if( !buffer )
+  {
+    ri.Printf(PRINT_ALL, "stream_read: buffer is NULL\n");
+    return 0;
+  }
+  if( !stream->descriptor.value )
+  {
+    ri.Printf(PRINT_ALL, "stream_read: stream->descriptor.value is zero\n");
+    return 0;
+  }
+
+  if( FS_FTell( ( fileHandle_t ) stream->descriptor.value ) != (long) offset )
+    FS_Seek( (fileHandle_t) stream->descriptor.value, (long) offset,  FS_SEEK_SET );
+
+  return FS_Read( (char *) buffer, (long) count, (fileHandle_t) stream->descriptor.value );
+}
+
+static void stream_close(FT_Stream stream)
+{
+  FS_FCloseFile( (fileHandle_t) stream->descriptor.value );
+}
+
+static void *memory_alloc(FT_Memory memory, long size)
+{
+  return malloc( size );
+}
+
+static void memory_free(FT_Memory memory, void *block)
+{
+  free( block );
+}
+
+static void *memory_realloc(FT_Memory memory, long cur_size, long new_size, void *block)
+{
+  return realloc( block, new_size );
+}
+
+void RE_LoadFace(const char *fileName, int pointSize, const char *name, face_t *face)
+{
+  fileHandle_t h;
+  static struct FT_MemoryRec_ memory =
+  { NULL
+  , memory_alloc
+  , memory_free
+  , memory_realloc
+  };
+  FT_Stream stream;
+  FT_Open_Args oa =
+  { FT_OPEN_STREAM
+  , NULL
+  , 0L
+  , NULL
+  , NULL  // stream
+  , NULL  // driver
+  , 0
+  , NULL
+  };
+  FT_Face ftFace;
+	float dpi = 72.0f;
+	float glyphScale =  72.0f / dpi; 		// change the scale to be relative to 1 based on 72 dpi ( so dpi of 144 means a scale of .5 )
+  int ec;
+
+  if( !face || !fileName || !name )
+    return;
+
+  if( FS_ReadFile( fileName, NULL ) <= 0 )
+    return;
+
+  oa.stream = face->mem = stream = malloc(sizeof(*stream));
+
+  FS_FOpenFileRead(fileName, &h, qtrue);
+  stream->base = NULL;
+  stream->size = ri.FS_ReadFile(fileName, NULL);
+  stream->pos = 0;
+  stream->descriptor.value = h;
+  stream->pathname.pointer = (void *) fileName;
+  stream->read = (FT_Stream_IoFunc) stream_read;
+  stream->close = (FT_Stream_CloseFunc) stream_close;
+  stream->memory = &memory;
+  stream->cursor = NULL;
+  stream->limit = NULL;
+
+  if (ftLibrary == NULL) {
+    ri.Printf(PRINT_ALL, "RE_LoadFace: FreeType not initialized.\n");
+    return;
+  }
+
+  if( ( ec = FT_Open_Face( ftLibrary, &oa, 0, (FT_Face *) &( face->opaque ) ) ) != 0 )
+  {
+    ri.Printf(PRINT_ALL, "RE_LoadFace: FreeType2, Unable to open face; error code: %d\n", ec);
+    return;
+  }
+
+  ftFace = (FT_Face) face->opaque;
+
+  if( !ftFace )
+  {
+    ri.Printf(PRINT_ALL, "RE_LoadFace: face handle is NULL");
+    return;
+  }
+
+	if (pointSize <= 0) {
+		pointSize = 12;
+	}
+	// we also need to adjust the scale based on point size relative to 48 points as the ui scaling is based on a 48 point font
+	glyphScale *= 48.0f / pointSize;
+
+  face->glyphScale = glyphScale;
+  strncpy(face->name, name, MAX_QPATH);
+
+  if((ec = FT_Set_Char_Size( ftFace, pointSize << 6, pointSize << 6, dpi, dpi)) != 0)
+  {
+    ri.Printf(PRINT_ALL, "RE_LoadFace: FreeType2, Unable to set face char size; error code: %d\n", ec);
+    return;
+  }
+}
+void RE_FreeFace(face_t *face)
+{
+  FT_Face ftFace;
+
+  if( !face )
+    return;
+
+  ftFace = face->opaque;
+
+  if( !ftFace )
+  {
+    if( face->mem )
+    {
+      free( face->mem );
+      face->mem = NULL;
+    }
+
+	  return;
+  }
+
+  if( ftLibrary )
+  {
+    FT_Done_Face( (FT_Face) ftFace );
+    face->opaque = NULL;
+  }
+
+  if( face->mem )
+  {
+    free( face->mem );
+    face->mem = NULL;
+  }
+}
+
+void RE_LoadGlyph(face_t *face, const char *str, int img, glyphInfo_t *glyphInfo)
+{
+  FT_Face ftFace = face ? (FT_Face) face->opaque : NULL;
+  glyphInfo_t *tmp;
+  int i;
+  int x = 0, y = 0, maxHeight = 0;
+  int left, max, satLevels;
+  static char name[MAX_QPATH];
+  image_t *image;
+  qhandle_t h;
+  static unsigned char buf[8*256*256];
+  static unsigned char imageBuf[4*256*256];
+
+  if( !face || !ftFace )
+    return;
+
+  if( img > MAX_FACE_GLYPHS )
+  {
+    ri.Printf(PRINT_ALL, "RE_LoadGlyph: img > MAX_FACE_GLYPHS\n");
+
+    return;
+  }
+
+  Com_Memset(buf, 0, sizeof(buf));
+  tmp = RE_ConstructGlyphInfo(32, buf, &x, &y, &maxHeight, ftFace, Q_UTF8CodePoint( str ), qfalse);
+  if( x == -1 || y == -1 )
+  {
+    Com_Memset(buf, 0, sizeof(buf));
+    Com_Memset(imageBuf, 0, sizeof(imageBuf));
+    return;
+  }
+  Com_Memcpy(glyphInfo, tmp, sizeof(glyphInfo_t));
+
+  left = 0;
+  max = 0;
+  satLevels = 255;
+  for(i = 0; i < 32*32; i++)
+  {
+    if(max < buf[i])
+    {
+      max = buf[i];
+    }
+  }
+
+  if(max > 0)
+  {
+    max = 255/max;
+  }
+
+  //for(i = 0; i < (scaledSize); i++)
+  for(i = 0; i < (32*32); i++)
+  {
+    imageBuf[left++] = 255;
+    imageBuf[left++] = 255;
+    imageBuf[left++] = 255;
+
+    imageBuf[left++] = ((float)buf[i] * max);
+  }
+
+  Com_sprintf( name, sizeof(name), "./../._FONT_%d", img );
+  //{static int n = 0; Com_sprintf( name, sizeof(name), "./../._FONT_%d", n++ );}
+
+  image = R_CreateImage(name, imageBuf, 32, 32, qfalse, qfalse, GL_CLAMP_TO_EDGE);
+  face->images[ img ] = (void *) image;
+  h = RE_RegisterShaderFromImage(name, LIGHTMAP_2D, image, qfalse);
+
+  Com_Memset(buf, 0, sizeof(buf));
+  Com_Memset(imageBuf, 0, sizeof(imageBuf));
+
+  glyphInfo->glyph = h;
+  strncpy( glyphInfo->shaderName, name, sizeof( glyphInfo->shaderName ) );
+}
+void RE_FreeGlyph(face_t *face, int img, glyphInfo_t *glyphInfo)
+{
+  image_t *image;
+
+  if( !face || !glyphInfo )
+    return;
+
+  if( img > MAX_FACE_GLYPHS )
+  {
+    ri.Printf(PRINT_ALL, "RE_LoadGlyph: img > MAX_FACE_GLYPHS\n");
+
+    return;
+  }
+
+  image = (image_t *) face->images[ img ];
+
+  if( !image )
+    return;
+
+  R_FreeImage( image );
+  face->images[ img ] = NULL;
+}
+
+typedef struct
+{ qboolean    used;
+  char        str[5];
+  glyphInfo_t glyph;
+  face_t      *face;
+} glyphCache_t;
+
+static glyphCache_t glyphCache[MAX_FACE_GLYPHS] = {{0}}, *nextCache = glyphCache;
+
+void RE_Glyph( fontInfo_t *font, face_t *face, const char *str, glyphInfo_t *glyph )
+{
+  int    i;
+  int    width;
+
+  if( !str || !*str || !face || ( width = Q_UTF8Width( str ) ) <= 1 )
+  {
+    memcpy( glyph, &font->glyphs[ (int)*str ], sizeof( *glyph ) );
+    return;
+  }
+
+  for( i = 0; i < MAX_FACE_GLYPHS; i++ )
+  {
+    glyphCache_t *c = &glyphCache[ i ];
+
+    if( c->used && c->face == face )
+    {
+      if( !face->images[ c - glyphCache ] )
+      {
+        // was freed
+        c->used = qfalse;
+      }
+      else
+      {
+        const char *s, *cs;
+
+        for( s = str, cs = c->str; *s && *cs && *s == *cs && s - str < width ; s++, cs++ );
+
+        if( !*cs && s - str == width)
+        {
+          memcpy( glyph, &c->glyph, sizeof( *glyph ) );
+          return;
+        }
+      }
+    }
+  }
+
+  if( nextCache->used )
+  {
+	  RE_FreeGlyph( nextCache->face, nextCache - glyphCache, &nextCache->glyph );
+  }
+
+  RE_LoadGlyph( face, str, nextCache - glyphCache, &nextCache->glyph );
+  nextCache->face = face;
+
+  strncpy( nextCache->str, str, width );  // This should never cause an overflow since Q_UTF8Width never returns a width larger than 4
+  nextCache->used = qtrue;
+
+  if( ++nextCache - glyphCache >= MAX_FACE_GLYPHS )
+    nextCache = glyphCache;
+
+  memcpy( glyph, &nextCache->glyph, sizeof( *glyph ) );
+}
+
+void RE_FreeCachedGlyphs( face_t *face )
+{
+  int i;
+
+  for( i = 0; i < MAX_FACE_GLYPHS; i++ )
+  {
+    glyphCache_t *c = &glyphCache[ i ];
+
+    if( c->used )
+    {
+      if( c->face == face )
+      {
+        c->used = qfalse;
+
+        RE_FreeGlyph( face, i, &c->glyph );
+      }
+    }
+  }
+}
+
+static void RE_ClearGlyphCache( void )
+{
+  int i;
+
+  for( i = 0; i < MAX_FACE_GLYPHS; i++ )
+  {
+    glyphCache_t *c = &glyphCache[ i ];
+
+    if( c->used )
+    {
+      c->used = qfalse;
+
+      RE_FreeGlyph( c->face, i, &c->glyph );
+    }
+  }
+}
+#else
+void RE_LoadFace(const char *fileName, int pointSize, const char *name, face_t *face)
+{
+}
+void RE_FreeFace(face_t *face)
+{
+}
+void RE_LoadGlyph(face_t *face, const char *str, glyphInfo_t *glyphInfo)
+{
+}
+void RE_FreeGlyph(face_t *face, glyphInfo_t *glyphInfo)
+{
+}
+void RE_Glyph( fontInfo_t *font, face_t *face, const char *str, glyphInfo_t *glyph )
+{
+  memcpy( glyph, &font->glyphs[ (int)*str ], sizeof( *glyph ) );
+}
+void RE_FreeCachedGlyphs( face_t *face )
+{
+}
+static void RE_ClearGlyphCache( void )
+{
+}
+#endif
+
 void RE_RegisterFont(const char *fontName, int pointSize, fontInfo_t *font) {
 #ifdef BUILD_FREETYPE
   FT_Face face;
@@ -340,7 +744,8 @@ void RE_RegisterFont(const char *fontName, int pointSize, fontInfo_t *font) {
 #endif
   void *faceData;
 	int i, len;
-  char name[1024];
+	char  name[MAX_QPATH];
+	char  strippedName[MAX_QPATH];
 	float dpi = 72;											//
 	float glyphScale =  72.0f / dpi; 		// change the scale to be relative to 1 based on 72 dpi ( so dpi of 144 means a scale of .5 )
 
@@ -364,13 +769,23 @@ void RE_RegisterFont(const char *fontName, int pointSize, fontInfo_t *font) {
     return;
   }
 
-	Com_sprintf(name, sizeof(name), "fonts/fontImage_%i.dat",pointSize);
-	for (i = 0; i < registeredFontCount; i++) {
-		if (Q_stricmp(name, registeredFont[i].name) == 0) {
-			Com_Memcpy(font, &registeredFont[i], sizeof(fontInfo_t));
-			return;
-		}
-	}
+	COM_StripExtension(fontName, strippedName, sizeof(strippedName));
+    //Compatibility: If there is no extension, assume this is loading one of the legacy fonts
+    if(!Q_stricmp(strippedName, fontName))
+    {
+        Com_sprintf(name, sizeof(name), "fonts/fontImage_%i.dat",pointSize);
+    }
+    else
+    {
+        Com_sprintf(name, sizeof(name), "%s_%i.dat", strippedName, pointSize);
+    }
+
+    for (i = 0; i < registeredFontCount; i++) {
+        if (Q_stricmp(name, registeredFont[i].name) == 0) {
+            Com_Memcpy(font, &registeredFont[i], sizeof(fontInfo_t));
+            return;
+        }
+    }
 
 	len = ri.FS_ReadFile(name, NULL);
 	if (len == sizeof(fontInfo_t)) {
@@ -413,9 +828,11 @@ void RE_RegisterFont(const char *fontName, int pointSize, fontInfo_t *font) {
     return;
   }
 
+  Com_sprintf(name, sizeof(name), "%s", fontName);
+
   len = ri.FS_ReadFile(fontName, &faceData);
   if (len <= 0) {
-    ri.Printf(PRINT_ALL, "RE_RegisterFont: Unable to read font file\n");
+    ri.Printf(PRINT_ALL, "RE_RegisterFont: Unable to read font file %s\n", name);
     return;
   }
 
@@ -431,6 +848,7 @@ void RE_RegisterFont(const char *fontName, int pointSize, fontInfo_t *font) {
     return;
   }
 
+
   //*font = &registeredFonts[registeredFontCount++];
 
   // make a 256x256 image buffer, once it is full, register it, clean it and keep going 
@@ -446,7 +864,7 @@ void RE_RegisterFont(const char *fontName, int pointSize, fontInfo_t *font) {
   maxHeight = 0;
 
   for (i = GLYPH_START; i < GLYPH_END; i++) {
-    glyph = RE_ConstructGlyphInfo(out, &xOut, &yOut, &maxHeight, face, (unsigned char)i, qtrue);
+    glyph = RE_ConstructGlyphInfo(256, out, &xOut, &yOut, &maxHeight, face, (unsigned char)i, qtrue);
   }
 
   xOut = 0;
@@ -455,69 +873,99 @@ void RE_RegisterFont(const char *fontName, int pointSize, fontInfo_t *font) {
   lastStart = i;
   imageNumber = 0;
 
-  while ( i <= GLYPH_END ) {
-
-    glyph = RE_ConstructGlyphInfo(out, &xOut, &yOut, &maxHeight, face, (unsigned char)i, qfalse);
-
-    if (xOut == -1 || yOut == -1 || i == GLYPH_END)  {
-      // ran out of room
-      // we need to create an image from the bitmap, set all the handles in the glyphs to this point
-      // 
-
-      scaledSize = 256*256;
-      newSize = scaledSize * 4;
-      imageBuff = Z_Malloc(newSize);
-      left = 0;
-      max = 0;
-      satLevels = 255;
-      for ( k = 0; k < (scaledSize) ; k++ ) {
-        if (max < out[k]) {
-          max = out[k];
-        }
-      }
-
-			if (max > 0) {
-				max = 255/max;
-			}
-
-      for ( k = 0; k < (scaledSize) ; k++ ) {
-        imageBuff[left++] = 255;
-        imageBuff[left++] = 255;
-        imageBuff[left++] = 255;
-
-        imageBuff[left++] = ((float)out[k] * max);
-      }
-
-			Com_sprintf (name, sizeof(name), "fonts/fontImage_%i_%i.tga", imageNumber++, pointSize);
-			if (r_saveFontData->integer) { 
+  while(i <= GLYPH_END)
+  {
+	  glyph = RE_ConstructGlyphInfo(256, out, &xOut, &yOut, &maxHeight, face, (unsigned char)i, qfalse);
+
+	  if(xOut == -1 || yOut == -1 || i == GLYPH_END)
+	  {
+		  if(xOut == -1 || yOut == -1)
+		  {
+			  //ri.Printf(PRINT_WARNING, "RE_RegisterFont: character %c does not fit image number %i\n", (unsigned char) i, imageNumber);
+		  }
+
+		  // ran out of room
+		  // we need to create an image from the bitmap, set all the handles in the glyphs to this point
+		  scaledSize = 256*256;
+		  newSize = scaledSize * 4;
+		  imageBuff = Z_Malloc(newSize);
+		  left = 0;
+		  max = 0;
+		  satLevels = 255;
+		  for(k = 0; k < (scaledSize); k++)
+		  {
+			  if(max < out[k])
+			  {
+				  max = out[k];
+			  }
+		  }
+
+		  if(max > 0)
+		  {
+			  max = 255/max;
+		  }
+
+		  for(k = 0; k < (scaledSize); k++)
+		  {
+			  imageBuff[left++] = 255;
+			  imageBuff[left++] = 255;
+			  imageBuff[left++] = 255;
+
+			  imageBuff[left++] = ((float)out[k] * max);
+		  }
+
+		  Com_sprintf(name, sizeof(name), "%s_%i_%i.tga", strippedName, imageNumber++, pointSize);
+		  if(!ri.FS_FileExists(name) && r_saveFontData->integer)  
+		  {
 			  WriteTGA(name, imageBuff, 256, 256);
-			}
+		  }
+
+		  /*`image = R_CreateImage(name, imageBuff, 256, 256, IF_NOPICMIP, FT_LINEAR, WT_CLAMP);`*/
+		  image = R_CreateImage(name, imageBuff, 256, 256, qfalse, qfalse, GL_CLAMP_TO_EDGE);
+		  /*`h = RE_RegisterShaderFromImage(name, image, qfalse);`*/
+		  h = RE_RegisterShaderFromImage(name, LIGHTMAP_2D, image, qfalse);
 
-    	//Com_sprintf (name, sizeof(name), "fonts/fontImage_%i_%i", imageNumber++, pointSize);
-      image = R_CreateImage(name, imageBuff, 256, 256, qfalse, qfalse, GL_CLAMP_TO_EDGE);
-      h = RE_RegisterShaderFromImage(name, LIGHTMAP_2D, image, qfalse);
-      for (j = lastStart; j < i; j++) {
-        font->glyphs[j].glyph = h;
-				Q_strncpyz(font->glyphs[j].shaderName, name, sizeof(font->glyphs[j].shaderName));
-      }
-      lastStart = i;
 		  Com_Memset(out, 0, 1024*1024);
-      xOut = 0;
-      yOut = 0;
-      Z_Free(imageBuff);
-			i++;
-    } else {
-      Com_Memcpy(&font->glyphs[i], glyph, sizeof(glyphInfo_t));
-      i++;
-    }
+		  xOut = 0;
+		  yOut = 0;
+		  Z_Free(imageBuff);
+
+		  if(i == GLYPH_END)
+		  {
+			  for(j = lastStart; j <= GLYPH_END; j++)
+			  {
+				  font->glyphs[j].glyph = h;
+				  Q_strncpyz(font->glyphs[j].shaderName, name, sizeof(font->glyphs[j].shaderName));
+			  }
+			  break;
+		  }
+		  else
+		  {
+			  for(j = lastStart; j < i; j++)
+			  {
+				  font->glyphs[j].glyph = h;
+				  Q_strncpyz(font->glyphs[j].shaderName, name, sizeof(font->glyphs[j].shaderName));
+			  }
+			  lastStart = i;
+		  }
+	  }
+	  else
+	  {
+		  Com_Memcpy(&font->glyphs[i], glyph, sizeof(glyphInfo_t));
+		  i++;
+	  }
   }
 
 	registeredFont[registeredFontCount].glyphScale = glyphScale;
 	font->glyphScale = glyphScale;
-  Com_Memcpy(&registeredFont[registeredFontCount++], font, sizeof(fontInfo_t));
 
-	if (r_saveFontData->integer) { 
-		ri.FS_WriteFile(va("fonts/fontImage_%i.dat", pointSize), font, sizeof(fontInfo_t));
+	Com_sprintf(name, sizeof(name), "%s_%i.dat", strippedName, pointSize);
+	Q_strncpyz(font->name, name, sizeof(font->name));
+	Com_Memcpy(&registeredFont[registeredFontCount++], font, sizeof(fontInfo_t));
+
+	if(!ri.FS_FileExists(name) && r_saveFontData->integer) 
+	{
+        ri.FS_WriteFile(name, font, sizeof(fontInfo_t));
 	}
 
   Z_Free(out);
@@ -541,6 +989,7 @@ void R_InitFreeType(void) {
 void R_DoneFreeType(void) {
 #ifdef BUILD_FREETYPE
   if (ftLibrary) {
+    RE_ClearGlyphCache();
     FT_Done_FreeType( ftLibrary );
     ftLibrary = NULL;
   }
diff --git a/src/renderer/tr_image.c b/src/renderer/tr_image.c
index 0cb1875..b7aa441 100644
--- a/src/renderer/tr_image.c
+++ b/src/renderer/tr_image.c
@@ -112,13 +112,15 @@ void GL_TextureMode( const char *string ) {
 	gl_filter_max = modes[i].maximize;
 
 	// change all the existing mipmap texture objects
-	for ( i = 0 ; i < tr.numImages ; i++ ) {
-		glt = tr.images[ i ];
-		if ( glt->mipmap ) {
-			GL_Bind (glt);
-			qglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, gl_filter_min);
-			qglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, gl_filter_max);
-		}
+	for ( i = 0 ; i < MAX_DRAWIMAGES ; i++ ) {
+    if( tr.used_images[ i ] ) {
+      glt = tr.images[ i ];
+      if ( glt->mipmap ) {
+        GL_Bind (glt);
+        qglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, gl_filter_min);
+        qglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, gl_filter_max);
+      }
+    }
 	}
 }
 
@@ -132,10 +134,12 @@ int R_SumOfUsedImages( void ) {
 	int i;
 
 	total = 0;
-	for ( i = 0; i < tr.numImages; i++ ) {
-		if ( tr.images[i]->frameUsed == tr.frameCount ) {
-			total += tr.images[i]->uploadWidth * tr.images[i]->uploadHeight;
-		}
+	for ( i = 0; i < MAX_DRAWIMAGES; i++ ) {
+    if( tr.used_images[ i ] ) {
+      if ( tr.images[i]->frameUsed == tr.frameCount ) {
+        total += tr.images[i]->uploadWidth * tr.images[i]->uploadHeight;
+      }
+    }
 	}
 
 	return total;
@@ -153,66 +157,71 @@ void R_ImageList_f( void ) {
 	const char *yesno[] = {
 		"no ", "yes"
 	};
+  int   c = 0;
 
 	ri.Printf (PRINT_ALL, "\n      -w-- -h-- -mm- -TMU- -if-- wrap --name-------\n");
 	texels = 0;
 
-	for ( i = 0 ; i < tr.numImages ; i++ ) {
-		image = tr.images[ i ];
-
-		texels += image->uploadWidth*image->uploadHeight;
-		ri.Printf (PRINT_ALL,  "%4i: %4i %4i  %s   %d   ",
-			i, image->uploadWidth, image->uploadHeight, yesno[image->mipmap], image->TMU );
-		switch ( image->internalFormat ) {
-		case 1:
-			ri.Printf( PRINT_ALL, "I    " );
-			break;
-		case 2:
-			ri.Printf( PRINT_ALL, "IA   " );
-			break;
-		case 3:
-			ri.Printf( PRINT_ALL, "RGB  " );
-			break;
-		case 4:
-			ri.Printf( PRINT_ALL, "RGBA " );
-			break;
-		case GL_RGBA8:
-			ri.Printf( PRINT_ALL, "RGBA8" );
-			break;
-		case GL_RGB8:
-			ri.Printf( PRINT_ALL, "RGB8" );
-			break;
-		case GL_RGB4_S3TC:
-		case GL_COMPRESSED_RGBA_S3TC_DXT1_EXT:
-			ri.Printf( PRINT_ALL, "S3TC " );
-			break;
-		case GL_RGBA4:
-			ri.Printf( PRINT_ALL, "RGBA4" );
-			break;
-		case GL_RGB5:
-			ri.Printf( PRINT_ALL, "RGB5 " );
-			break;
-		default:
-			ri.Printf( PRINT_ALL, "???? " );
-		}
-
-		switch ( image->wrapClampMode ) {
-		case GL_REPEAT:
-			ri.Printf( PRINT_ALL, "rept " );
-			break;
-		case GL_CLAMP_TO_EDGE:
-			ri.Printf( PRINT_ALL, "clmp " );
-			break;
-		default:
-			ri.Printf( PRINT_ALL, "%4i ", image->wrapClampMode );
-			break;
-		}
-		
-		ri.Printf( PRINT_ALL, " %s\n", image->imgName );
+	for ( i = 0 ; i < MAX_DRAWIMAGES ; i++ ) {
+    if( tr.used_images[ i ] ) {
+      image = tr.images[ i ];
+
+      c++;
+
+      texels += image->uploadWidth*image->uploadHeight;
+      ri.Printf (PRINT_ALL,  "%4i: %4i %4i  %s   %d   ",
+        i, image->uploadWidth, image->uploadHeight, yesno[image->mipmap], image->TMU );
+      switch ( image->internalFormat ) {
+      case 1:
+        ri.Printf( PRINT_ALL, "I    " );
+        break;
+      case 2:
+        ri.Printf( PRINT_ALL, "IA   " );
+        break;
+      case 3:
+        ri.Printf( PRINT_ALL, "RGB  " );
+        break;
+      case 4:
+        ri.Printf( PRINT_ALL, "RGBA " );
+        break;
+      case GL_RGBA8:
+        ri.Printf( PRINT_ALL, "RGBA8" );
+        break;
+      case GL_RGB8:
+        ri.Printf( PRINT_ALL, "RGB8" );
+        break;
+      case GL_RGB4_S3TC:
+      case GL_COMPRESSED_RGBA_S3TC_DXT1_EXT:
+        ri.Printf( PRINT_ALL, "S3TC " );
+        break;
+      case GL_RGBA4:
+        ri.Printf( PRINT_ALL, "RGBA4" );
+        break;
+      case GL_RGB5:
+        ri.Printf( PRINT_ALL, "RGB5 " );
+        break;
+      default:
+        ri.Printf( PRINT_ALL, "???? " );
+      }
+
+      switch ( image->wrapClampMode ) {
+      case GL_REPEAT:
+        ri.Printf( PRINT_ALL, "rept " );
+        break;
+      case GL_CLAMP_TO_EDGE:
+        ri.Printf( PRINT_ALL, "clmp " );
+        break;
+      default:
+        ri.Printf( PRINT_ALL, "%4i ", image->wrapClampMode );
+        break;
+      }
+      
+      ri.Printf( PRINT_ALL, " %s\n", image->imgName );
+    }
 	}
 	ri.Printf (PRINT_ALL, " ---------\n");
 	ri.Printf (PRINT_ALL, " %i total texels (not including mipmaps)\n", texels);
-	ri.Printf (PRINT_ALL, " %i total images\n\n", tr.numImages );
+	ri.Printf (PRINT_ALL, " %i total images\n\n", c );
 }
 
 //=======================================================================
@@ -755,9 +764,10 @@ This is the only way any image_t are created
 */
 image_t *R_CreateImage( const char *name, const byte *pic, int width, int height, 
 					   qboolean mipmap, qboolean allowPicmip, int glWrapClampMode ) {
-	image_t		*image;
+	image_t		*image = NULL;
 	qboolean	isLightmap = qfalse;
 	long		hash;
+  int     i;
 
 	if (strlen(name) >= MAX_QPATH ) {
 		ri.Error (ERR_DROP, "R_CreateImage: \"%s\" is too long\n", name);
@@ -766,13 +776,20 @@ image_t *R_CreateImage( const char *name, const byte *pic, int width, int height
 		isLightmap = qtrue;
 	}
 
-	if ( tr.numImages == MAX_DRAWIMAGES ) {
-		ri.Error( ERR_DROP, "R_CreateImage: MAX_DRAWIMAGES hit\n");
+	for ( i=0; i<MAX_DRAWIMAGES ; i++ ) {
+    if( !tr.used_images[ i ] ) {
+      image = tr.images[ i ] = malloc( sizeof( image_t ) );
+      tr.used_images[ i ] = qtrue;
+
+      break;
+    }
+  }
+
+	if ( !image ) {
+		ri.Error( ERR_DROP, "R_CreateImage: no room for image (MAX_DRAWIMAGES is %d)\n", MAX_DRAWIMAGES);
 	}
 
-	image = tr.images[tr.numImages] = ri.Hunk_Alloc( sizeof( image_t ), h_low );
-	image->texnum = 1024 + tr.numImages;
-	tr.numImages++;
+	image->texnum = 1024 + i;
 
 	image->mipmap = mipmap;
 	image->allowPicmip = allowPicmip;
@@ -820,6 +837,38 @@ image_t *R_CreateImage( const char *name, const byte *pic, int width, int height
 	return image;
 }
 
+void R_FreeImage( image_t *image )
+{
+  int i;
+
+	for ( i=0; i<MAX_DRAWIMAGES ; i++ ) {
+    if( tr.used_images[ i ] && tr.images[ i ] == image ) {
+      tr.used_images[ i ] = qfalse;
+      free( image );
+      tr.images[ i ] = NULL;
+
+      return;
+    }
+  }
+
+  ri.Printf( PRINT_ALL, "R_FreeImage: image not found\n" );
+}
+
+void R_FreeImages( void )
+{
+  int i;
+
+	for ( i=0; i<MAX_DRAWIMAGES ; i++ ) {
+    if( tr.used_images[ i ] && tr.images[ i ] ) {
+      tr.used_images[ i ] = qfalse;
+      free( tr.images[ i ] );
+      tr.images[ i ] = NULL;
+
+      return;
+    }
+  }
+}
+
 //===================================================================
 
 typedef struct
@@ -1288,13 +1337,13 @@ R_DeleteTextures
 void R_DeleteTextures( void ) {
 	int		i;
 
-	for ( i=0; i<tr.numImages ; i++ ) {
-		qglDeleteTextures( 1, &tr.images[i]->texnum );
+	for ( i=0; i<MAX_DRAWIMAGES ; i++ ) {
+    if( tr.used_images[ i ] ) {
+      qglDeleteTextures( 1, &tr.images[i]->texnum );
+    }
 	}
 	Com_Memset( tr.images, 0, sizeof( tr.images ) );
 
-	tr.numImages = 0;
-
 	Com_Memset( glState.currenttextures, 0, sizeof( glState.currenttextures ) );
 	if ( qglActiveTextureARB ) {
 		GL_SelectTexture( 1 );
diff --git a/src/renderer/tr_init.c b/src/renderer/tr_init.c
index 89fcf3e..1347451 100644
--- a/src/renderer/tr_init.c
+++ b/src/renderer/tr_init.c
@@ -152,6 +152,8 @@ cvar_t	*r_saveFontData;
 
 cvar_t	*r_marksOnTriangleMeshes;
 
+cvar_t	*r_reuseGlyphShaders;
+
 cvar_t	*r_maxpolys;
 int		max_polys;
 cvar_t	*r_maxpolyverts;
@@ -1157,14 +1159,15 @@ void RE_Shutdown( qboolean destroyWindow ) {
 	ri.Cmd_RemoveCommand( "shaderstate" );
 
 
+	R_DoneFreeType();
+  R_FreeImages();
+
 	if ( tr.registered ) {
 		R_SyncRenderThread();
 		R_ShutdownCommandBuffers();
 		R_DeleteTextures();
 	}
 
-	R_DoneFreeType();
-
 	// shut down platform specific OpenGL stuff
 	if ( destroyWindow ) {
 		GLimp_Shutdown();
@@ -1243,6 +1246,12 @@ refexport_t *GetRefAPI ( int apiVersion, refimport_t *rimp ) {
 	re.UploadCinematic = RE_UploadCinematic;
 
 	re.RegisterFont = RE_RegisterFont;
+	re.LoadFace = RE_LoadFace;
+	re.FreeFace = RE_FreeFace;
+	re.LoadGlyph = RE_LoadGlyph;
+	re.FreeGlyph = RE_FreeGlyph;
+  re.Glyph = RE_Glyph;
+  re.FreeCachedGlyphs = RE_FreeCachedGlyphs;
 	re.RemapShader = R_RemapShader;
 	re.GetEntityToken = R_GetEntityToken;
 	re.inPVS = R_inPVS;
diff --git a/src/renderer/tr_local.h b/src/renderer/tr_local.h
index ad32c26..05559b1 100644
--- a/src/renderer/tr_local.h
+++ b/src/renderer/tr_local.h
@@ -952,7 +952,7 @@ typedef struct {
 	model_t					*models[MAX_MOD_KNOWN];
 	int						numModels;
 
-	int						numImages;
+  qboolean        used_images[MAX_DRAWIMAGES];
 	image_t					*images[MAX_DRAWIMAGES];
 
 	// shader indexes from other modules will be looked up in tr.shaders[]
@@ -1219,6 +1219,8 @@ image_t		*R_FindImageFile( const char *name, qboolean mipmap, qboolean allowPicm
 
 image_t		*R_CreateImage( const char *name, const byte *pic, int width, int height, qboolean mipmap,
             qboolean allowPicmip, int wrapClampMode );
+void      R_FreeImage( image_t *image );
+void      R_FreeImages( void );
 
 void		R_SetColorMappings( void );
 void		R_GammaCorrect( byte *buffer, int bufSize );
@@ -1710,6 +1712,12 @@ void RE_TakeVideoFrame( int width, int height,
 void R_InitFreeType( void );
 void R_DoneFreeType( void );
 void RE_RegisterFont(const char *fontName, int pointSize, fontInfo_t *font);
+void RE_LoadFace(const char *fileName, int pointSize, const char *name, face_t *face);
+void RE_FreeFace(face_t *face);
+void RE_LoadGlyph(face_t *face, const char *str, int img, glyphInfo_t *glyphInfo);
+void RE_FreeGlyph(face_t *face, int img, glyphInfo_t *glyphInfo);
+void RE_Glyph(fontInfo_t *font, face_t *face, const char *str, glyphInfo_t *glyph);
+void RE_FreeCachedGlyphs(face_t *face);
 
 
 #endif //TR_LOCAL_H
diff --git a/src/renderer/tr_public.h b/src/renderer/tr_public.h
index 5126ab4..9b27233 100644
--- a/src/renderer/tr_public.h
+++ b/src/renderer/tr_public.h
@@ -96,6 +96,12 @@ typedef struct {
 	void    (*A3D_RenderGeometry) (void *pVoidA3D, void *pVoidGeom, void *pVoidMat, void *pVoidGeomStatus);
 #endif
 	void	(*RegisterFont)(const char *fontName, int pointSize, fontInfo_t *font);
+	void	(*LoadFace)(const char *fileName, int pointSize, const char *name, face_t *face);
+	void	(*FreeFace)(face_t *face);
+	void	(*LoadGlyph)(face_t *face, const char *str, int img, glyphInfo_t *glyphInfo);
+	void	(*FreeGlyph)(face_t *face, int img, glyphInfo_t *glyphInfo);
+	void	(*Glyph)( fontInfo_t *font, face_t *face, const char *str, glyphInfo_t *glyph );
+	void	(*FreeCachedGlyphs)(face_t *face);
 	void	(*RemapShader)(const char *oldShader, const char *newShader, const char *offsetTime);
 	qboolean (*GetEntityToken)( char *buffer, int size );
 	qboolean (*inPVS)( const vec3_t p1, const vec3_t p2 );
diff --git a/src/renderer/tr_shader.c b/src/renderer/tr_shader.c
index 8e86a73..1907d9c 100644
--- a/src/renderer/tr_shader.c
+++ b/src/renderer/tr_shader.c
@@ -2124,7 +2124,7 @@ Returns a freshly allocated shader with all the needed info
 from the current global working shader
 =========================
 */
-static shader_t *FinishShader( void ) {
+static shader_t *FinishShader( shader_t *sh ) {
 	int stage;
 	qboolean		hasLightmapStage;
 	qboolean		vertexLightmap;
@@ -2303,7 +2303,10 @@ static shader_t *FinishShader( void ) {
 	// determine which stage iterator function is appropriate
 	ComputeStageIteratorFunc();
 
-	return GeneratePermanentShader();
+  if( sh )
+    return sh;
+  else
+    return GeneratePermanentShader();
 }
 
 //========================================================================================
@@ -2505,7 +2508,7 @@ shader_t *R_FindShader( const char *name, int lightmapIndex, qboolean mipRawImag
 			// had errors, so use default shader
 			shader.defaultShader = qtrue;
 		}
-		sh = FinishShader();
+		sh = FinishShader( NULL );
 		return sh;
 	}
 
@@ -2518,7 +2521,7 @@ shader_t *R_FindShader( const char *name, int lightmapIndex, qboolean mipRawImag
 	if ( !image ) {
 		ri.Printf( PRINT_DEVELOPER, "Couldn't find image file for shader %s\n", name );
 		shader.defaultShader = qtrue;
-		return FinishShader();
+		return FinishShader( NULL );
 	}
 
 	//
@@ -2572,10 +2575,19 @@ shader_t *R_FindShader( const char *name, int lightmapIndex, qboolean mipRawImag
 		stages[1].stateBits |= GLS_SRCBLEND_DST_COLOR | GLS_DSTBLEND_ZERO;
 	}
 
-	return FinishShader();
+	return FinishShader( NULL );
 }
 
 
+/*
+==================
+RE_RegisterShaderFromImage
+
+Registers a mutable shader from an image.  If a shader
+already exists with the same name, it will 
+be overwritten with the new image.
+==================
+*/
 qhandle_t RE_RegisterShaderFromImage(const char *name, int lightmapIndex, image_t *image, qboolean mipRawImage) {
 	int			i, hash;
 	shader_t	*sh;
@@ -2592,18 +2604,21 @@ qhandle_t RE_RegisterShaderFromImage(const char *name, int lightmapIndex, image_
 	//
 	// see if the shader is already loaded
 	//
-	for (sh=hashTable[hash]; sh; sh=sh->next) {
-		// NOTE: if there was no shader or image available with the name strippedName
-		// then a default shader is created with lightmapIndex == LIGHTMAP_NONE, so we
-		// have to check all default shaders otherwise for every call to R_FindShader
-		// with that same strippedName a new default shader is created.
-		if ( (sh->lightmapIndex == lightmapIndex || sh->defaultShader) &&
-			// index by name
-			!Q_stricmp(sh->name, name)) {
-			// match found
-			return sh->index;
-		}
-	}
+  for (sh=hashTable[hash]; sh; sh=sh->next) {
+    // NOTE: if there was no shader or image available with the name strippedName
+    // then a default shader is created with lightmapIndex == LIGHTMAP_NONE, so we
+    // have to check all default shaders otherwise for every call to R_FindShader
+    // with that same strippedName a new default shader is created.
+    if ( (sh->lightmapIndex == lightmapIndex || sh->defaultShader) &&
+      // index by name
+      Q_stricmp(sh->name, name) == 0) {
+      // match found
+      break;
+    }
+  }
+
+  if( Q_stricmp(sh->name, name) != 0 )
+    sh = NULL;
 
 	// make sure the render thread is stopped, because we are probably
 	// going to have to upload an image
@@ -2620,7 +2635,7 @@ qhandle_t RE_RegisterShaderFromImage(const char *name, int lightmapIndex, image_
 		stages[i].bundle[0].texMods = texMods[i];
 	}
 
-	// FIXME: set these "need" values apropriately
+	// FIXME: set these "need" values appropriately
 	shader.needsNormal = qtrue;
 	shader.needsST1 = qtrue;
 	shader.needsST2 = qtrue;
@@ -2677,7 +2692,7 @@ qhandle_t RE_RegisterShaderFromImage(const char *name, int lightmapIndex, image_
 		stages[1].stateBits |= GLS_SRCBLEND_DST_COLOR | GLS_DSTBLEND_ZERO;
 	}
 
-	sh = FinishShader();
+	sh = FinishShader(sh);
   return sh->index; 
 }
 
@@ -3028,12 +3043,12 @@ static void CreateInternalShaders( void ) {
 	stages[0].bundle[0].image[0] = tr.defaultImage;
 	stages[0].active = qtrue;
 	stages[0].stateBits = GLS_DEFAULT;
-	tr.defaultShader = FinishShader();
+	tr.defaultShader = FinishShader( NULL );
 
 	// shadow shader is just a marker
 	Q_strncpyz( shader.name, "<stencil shadow>", sizeof( shader.name ) );
 	shader.sort = SS_STENCIL_SHADOW;
-	tr.shadowShader = FinishShader();
+	tr.shadowShader = FinishShader( NULL );
 }
 
 static void CreateExternalShaders( void ) {
diff --git a/src/sdl/sdl_input.c b/src/sdl/sdl_input.c
index ec96b08..4f25361 100644
--- a/src/sdl/sdl_input.c
+++ b/src/sdl/sdl_input.c
@@ -217,7 +217,7 @@ IN_TranslateSDLToQ3Key
 static const char *IN_TranslateSDLToQ3Key( SDL_keysym *keysym,
 	keyNum_t *key, qboolean down )
 {
-	static unsigned char buf[ 2 ] = { '\0', '\0' };
+	static unsigned char buf[ 5 ] = {0};
 
 	*buf = '\0';
 	*key = 0;
@@ -356,9 +356,7 @@ static const char *IN_TranslateSDLToQ3Key( SDL_keysym *keysym,
 		*buf = '\0';
 	}
 
-	// Don't allow extended ASCII to generate characters
-	if( *buf & 0x80 )
-		*buf = '\0';
+	memcpy( buf, Q_UTF8Encode( keysym->unicode ), sizeof( buf ) );
 
 	return (char *)buf;
 }
@@ -909,11 +907,16 @@ static void IN_ProcessEvents( void )
 		{
 			case SDL_KEYDOWN:
 				character = IN_TranslateSDLToQ3Key( &e.key.keysym, &key, qtrue );
+
+				if( character && *character )
+				{
+					void *buf = Z_Malloc( 5 );
+					memcpy( buf, character, 5 );
+					Com_QueueEvent( 0, SE_CHAR, 5, 0, 0, buf );
+				}
+
 				if( key )
 					Com_QueueEvent( 0, SE_KEY, key, qtrue, 0, NULL );
-
-				if( character )
-					Com_QueueEvent( 0, SE_CHAR, *character, 0, 0, NULL );
 				break;
 
 			case SDL_KEYUP:
diff --git a/src/server/server.h b/src/server/server.h
index ad9fcde..253df35 100644
--- a/src/server/server.h
+++ b/src/server/server.h
@@ -34,6 +34,8 @@ Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 
 #define	MAX_ENT_CLUSTERS	16
 
+#define _(String) Sys_Gettext(String)
+
 #ifdef USE_VOIP
 typedef struct voipServerPacket_s
 {
diff --git a/src/server/sv_game.c b/src/server/sv_game.c
index efd6265..2db993c 100644
--- a/src/server/sv_game.c
+++ b/src/server/sv_game.c
@@ -492,6 +492,10 @@ intptr_t SV_GameSystemCalls( intptr_t *args ) {
 	case TRAP_CEIL:
 		return FloatAsInt( ceil( VMF(1) ) );
 
+	case G_GETTEXT:
+		strncpy( VMA(1), _(VMA(2)), args[3] );
+		return 0;
+
 
 	default:
 		Com_Error( ERR_DROP, "Bad game system trap: %ld", (long int) args[0] );
diff --git a/src/server/sv_init.c b/src/server/sv_init.c
index 59e0346..15075db 100644
--- a/src/server/sv_init.c
+++ b/src/server/sv_init.c
@@ -649,6 +649,8 @@ void SV_Init (void) {
 	Cvar_Get ("sv_referencedPakNames", "", CVAR_SYSTEMINFO | CVAR_ROM );
 
 	// server vars
+	Cvar_SetIFlag( "\\IS_GETTEXT_SUPPORTED" );
+
 	sv_rconPassword = Cvar_Get ("rconPassword", "", CVAR_TEMP );
 	sv_privatePassword = Cvar_Get ("sv_privatePassword", "", CVAR_TEMP );
 	sv_fps = Cvar_Get ("sv_fps", "20", CVAR_TEMP );
diff --git a/src/sys/con_tty.c b/src/sys/con_tty.c
index e4b2ad5..55945b1 100644
--- a/src/sys/con_tty.c
+++ b/src/sys/con_tty.c
@@ -285,7 +285,7 @@ void CON_Init( void )
 
 	if (!stdinIsATTY)
 	{
-		Com_Printf("tty console mode disabled\n");
+		Com_Printf(_("tty console mode disabled\n"));
 		ttycon_on = qfalse;
 		stdin_active = qtrue;
 		return;
@@ -416,7 +416,7 @@ char *CON_Input( void )
 						}
 					}
 				}
-				Com_DPrintf("droping ISCTL sequence: %d, TTY_erase: %d\n", key, TTY_erase);
+				Com_DPrintf(_("droping ISCTL sequence: %d, TTY_erase: %d\n"), key, TTY_erase);
 				CON_FlushIn();
 				return NULL;
 			}
diff --git a/src/sys/sys_local.h b/src/sys/sys_local.h
index 6017150..bc16764 100644
--- a/src/sys/sys_local.h
+++ b/src/sys/sys_local.h
@@ -29,6 +29,8 @@ Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 #define MINSDL_MINOR 2
 #define MINSDL_PATCH 10
 
+#define _(String) Sys_Gettext(String)
+
 // Input subsystem
 void IN_Init( void );
 void IN_Frame( void );
@@ -51,6 +53,7 @@ char *Sys_StripAppBundle( char *pwd );
 
 void Sys_GLimpSafeInit( void );
 void Sys_GLimpInit( void );
+void Sys_InitGettext( void );
 void Sys_PlatformInit( void );
 void Sys_SigHandler( int signal );
 void Sys_ErrorDialog( const char *error );
diff --git a/src/sys/sys_main.c b/src/sys/sys_main.c
index f1aa6fa..9cdafbf 100644
--- a/src/sys/sys_main.c
+++ b/src/sys/sys_main.c
@@ -196,6 +196,7 @@ void Sys_Init(void)
 	Cmd_AddCommand( "in_restart", Sys_In_Restart_f );
 	Cvar_Set( "arch", OS_STRING " " ARCH_STRING );
 	Cvar_Set( "username", Sys_GetCurrentUser( ) );
+	Sys_InitGettext( );
 }
 
 /*
@@ -313,7 +314,7 @@ void Sys_Warn( char *warning, ... )
 	Q_vsnprintf (string, sizeof(string), warning, argptr);
 	va_end (argptr);
 
-	CON_Print( va( "Warning: %s", string ) );
+	CON_Print( va( _("Warning: %s"), string ) );
 }
 
 /*
@@ -342,7 +343,7 @@ void Sys_UnloadDll( void *dllHandle )
 {
 	if( !dllHandle )
 	{
-		Com_Printf("Sys_UnloadDll(NULL)\n");
+		Com_Printf(_("Sys_UnloadDll(NULL)\n"));
 		return;
 	}
 
@@ -362,16 +363,16 @@ static void* Sys_TryLibraryLoad(const char* base, const char* gamedir, const cha
 	*fqpath = 0;
 
 	fn = FS_BuildOSPath( base, gamedir, fname );
-	Com_Printf( "Sys_LoadDll(%s)... \n", fn );
+	Com_Printf( _("Sys_LoadDll(%s)... \n"), fn );
 
 	libHandle = Sys_LoadLibrary(fn);
 
 	if(!libHandle) {
-		Com_Printf( "Sys_LoadDll(%s) failed:\n\"%s\"\n", fn, Sys_LibraryError() );
+		Com_Printf( _("Sys_LoadDll(%s) failed:\n\"%s\"\n"), fn, Sys_LibraryError() );
 		return NULL;
 	}
 
-	Com_Printf ( "Sys_LoadDll(%s): succeeded ...\n", fn );
+	Com_Printf ( _("Sys_LoadDll(%s): succeeded ...\n"), fn );
 	Q_strncpyz ( fqpath , fn , MAX_QPATH ) ;
 
 	return libHandle;
@@ -412,7 +413,7 @@ void *Sys_LoadDll( const char *name, char *fqpath ,
 		libHandle = Sys_TryLibraryLoad(basepath, gamedir, fname, fqpath);
 
 	if(!libHandle) {
-		Com_Printf ( "Sys_LoadDll(%s) failed to load library\n", name );
+		Com_Printf ( _("Sys_LoadDll(%s) failed to load library\n"), name );
 		return NULL;
 	}
 
@@ -421,13 +422,13 @@ void *Sys_LoadDll( const char *name, char *fqpath ,
 
 	if ( !*entryPoint || !dllEntry )
 	{
-		Com_Printf ( "Sys_LoadDll(%s) failed to find vmMain function:\n\"%s\" !\n", name, Sys_LibraryError( ) );
+		Com_Printf ( _("Sys_LoadDll(%s) failed to find vmMain function:\n\"%s\" !\n"), name, Sys_LibraryError( ) );
 		Sys_UnloadLibrary(libHandle);
 
 		return NULL;
 	}
 
-	Com_Printf ( "Sys_LoadDll(%s) found vmMain function at %p\n", name, *entryPoint );
+	Com_Printf ( _("Sys_LoadDll(%s) found vmMain function at %p\n"), name, *entryPoint );
 	dllEntry( systemcalls );
 
 	return libHandle;
@@ -475,17 +476,17 @@ void Sys_SigHandler( int signal )
 
 	if( signalcaught )
 	{
-		fprintf( stderr, "DOUBLE SIGNAL FAULT: Received signal %d, exiting...\n",
+		fprintf( stderr, _("DOUBLE SIGNAL FAULT: Received signal %d, exiting...\n"),
 			signal );
 	}
 	else
 	{
 		signalcaught = qtrue;
-		fprintf( stderr, "Received signal %d, exiting...\n", signal );
+		fprintf( stderr, _("Received signal %d, exiting...\n"), signal );
 #ifndef DEDICATED
 		CL_Shutdown();
 #endif
-		SV_Shutdown( "Signal caught" );
+		SV_Shutdown( _("Signal caught") );
 	}
 
 	Sys_Exit( 0 ); // Exit with 0 to avoid recursive signals
@@ -520,7 +521,7 @@ int main( int argc, char **argv )
 	if( SDL_VERSIONNUM( ver->major, ver->minor, ver->patch ) <
 			SDL_VERSIONNUM( MINSDL_MAJOR, MINSDL_MINOR, MINSDL_PATCH ) )
 	{
-		Sys_Print( "SDL version " MINSDL_VERSION " or greater required\n" );
+		Sys_Print( _("SDL version " MINSDL_VERSION " or greater required\n") );
 		Sys_Exit( 1 );
 	}
 #endif
diff --git a/src/sys/sys_unix.c b/src/sys/sys_unix.c
index ccff631..8691926 100644
--- a/src/sys/sys_unix.c
+++ b/src/sys/sys_unix.c
@@ -37,6 +37,8 @@ Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 #include <pwd.h>
 #include <libgen.h>
 #include <fcntl.h>
+#include <locale.h>
+#include <libintl.h>
 
 qboolean stdinIsATTY;
 
@@ -527,7 +529,7 @@ void Sys_ErrorDialog( const char *error )
 
 	/* make sure the write path for the crashlog exists... */
 	if( FS_CreatePath( ospath ) ) {
-		Com_Printf( "ERROR: couldn't create path '%s' for crash log.\n", ospath );
+		Com_Printf( _("ERROR: couldn't create path '%s' for crash log.\n"), ospath );
 		return;
 	}
 
@@ -537,14 +539,14 @@ void Sys_ErrorDialog( const char *error )
 	f = open(ospath, O_CREAT | O_TRUNC | O_WRONLY, 0640);
 	if( f == -1 )
 	{
-		Com_Printf( "ERROR: couldn't open %s\n", fileName );
+		Com_Printf( _("ERROR: couldn't open %s\n"), fileName );
 		return;
 	}
 
 	/* We're crashing, so we don't care much if write() or close() fails. */
 	while( ( size = CON_LogRead( buffer, sizeof( buffer ) ) ) > 0 ) {
 		if (write( f, buffer, size ) != size) {
-			Com_Printf( "ERROR: couldn't fully write to %s\n", fileName );
+			Com_Printf( _("ERROR: couldn't fully write to %s\n"), fileName );
 			break;
 		}
 	}
@@ -578,6 +580,46 @@ void Sys_GLimpInit( void )
 
 /*
 ==============
+Sys_InitGettext
+
+Initialise gettext
+==============
+*/
+void Sys_InitGettext( void )
+{
+	char dir[ 2 * MAX_CVAR_VALUE_STRING ];
+	Cvar_Get( "localepath", "", CVAR_ARCHIVE | CVAR_INIT );
+	Cvar_Get( "locale", "/locale", CVAR_ARCHIVE | CVAR_INIT );
+
+	Cvar_VariableStringBuffer( "localepath", dir, sizeof( dir ) );
+	if( !*dir )
+		Cvar_VariableStringBuffer( "fs_homepath", dir, MAX_CVAR_VALUE_STRING );
+	Q_strcat( dir, sizeof( dir ), Cvar_VariableString( "locale" ) );
+
+    errno = 0;
+
+    if (!setlocale(LC_ALL, ""))
+    {
+        fprintf(stderr, "Failed to set LC_ALL to native locale: %s\n",
+                errno ? strerror(errno) : "Unknown error");
+    }
+
+	bindtextdomain( PRODUCT_NAME, dir );
+	textdomain( PRODUCT_NAME );
+}
+
+/*
+==============
+Sys_Gettext
+==============
+*/
+char *Sys_Gettext(const char *msgid)
+{
+	return gettext(msgid);
+}
+
+/*
+==============
 Sys_PlatformInit
 
 Unix specific initialisation
diff --git a/src/sys/sys_win32.c b/src/sys/sys_win32.c
index ead428e..9b3769f 100644
--- a/src/sys/sys_win32.c
+++ b/src/sys/sys_win32.c
@@ -57,14 +57,14 @@ char *Sys_DefaultHomePath( void )
 	{
 		if(shfolder == NULL)
 		{
-			Com_Printf("Unable to load SHFolder.dll\n");
+			Com_Printf(_("Unable to load SHFolder.dll\n"));
 			return NULL;
 		}
 
 		qSHGetFolderPath = GetProcAddress(shfolder, "SHGetFolderPathA");
 		if(qSHGetFolderPath == NULL)
 		{
-			Com_Printf("Unable to find SHGetFolderPath in SHFolder.dll\n");
+			Com_Printf(_("Unable to find SHGetFolderPath in SHFolder.dll\n"));
 			FreeLibrary(shfolder);
 			return NULL;
 		}
@@ -72,7 +72,7 @@ char *Sys_DefaultHomePath( void )
 		if( !SUCCEEDED( qSHGetFolderPath( NULL, CSIDL_APPDATA,
 						NULL, 0, szPath ) ) )
 		{
-			Com_Printf("Unable to detect CSIDL_APPDATA\n");
+			Com_Printf(_("Unable to detect CSIDL_APPDATA\n"));
 			FreeLibrary(shfolder);
 			return NULL;
 		}
@@ -545,7 +545,7 @@ Display an error message
 */
 void Sys_ErrorDialog( const char *error )
 {
-	if( MessageBox( NULL, va( "%s. Copy console log to clipboard?", error ),
+	if( MessageBox( NULL, va( _("%s. Copy console log to clipboard?"), error ),
 			NULL, MB_YESNO|MB_ICONERROR ) == IDYES )
 	{
 		HGLOBAL memoryHandle;
@@ -632,6 +632,46 @@ void Sys_GLimpInit( void )
 
 /*
 ==============
+Sys_InitGettext
+
+Initialise gettext
+==============
+*/
+void Sys_InitGettext( void )
+{
+	char dir[ 2 * MAX_CVAR_VALUE_STRING ];
+	Cvar_Get( "localepath", "", CVAR_ARCHIVE | CVAR_INIT );
+	Cvar_Get( "locale", "/locale", CVAR_ARCHIVE | CVAR_INIT );
+
+	Cvar_VariableStringBuffer( "localepath", dir, sizeof( dir ) );
+	if( !*dir )
+		Cvar_VariableStringBuffer( "fs_homepath", dir, MAX_CVAR_VALUE_STRING );
+	Q_strcat( dir, sizeof( dir ), Cvar_VariableString( "locale" ) );
+
+    errno = 0;
+
+    if (!setlocale(LC_ALL, ""))
+    {
+        fprintf(stderr, "Failed to set LC_ALL to native locale: %s\n",
+                errno ? strerror(errno) : "Unknown error");
+    }
+
+	bindtextdomain( PRODUCT_NAME, dir );
+	textdomain( PRODUCT_NAME );
+}
+
+/*
+==============
+Sys_Gettext
+==============
+*/
+char *Sys_Gettext(const char *msgid)
+{
+	return gettext(msgid);
+}
+
+/*
+==============
 Sys_PlatformInit
 
 Windows specific initialisation
@@ -644,8 +684,8 @@ void Sys_PlatformInit( void )
 
 	if( SDL_VIDEODRIVER )
 	{
-		Com_Printf( "SDL_VIDEODRIVER is externally set to \"%s\", "
-				"in_mouse -1 will have no effect\n", SDL_VIDEODRIVER );
+		Com_Printf( _("SDL_VIDEODRIVER is externally set to \"%s\", "
+				"in_mouse -1 will have no effect\n"), SDL_VIDEODRIVER );
 		SDL_VIDEODRIVER_externallySet = qtrue;
 	}
 	else
diff --git a/src/ui/ui_gameinfo.c b/src/ui/ui_gameinfo.c
index 18a604b..7e0584e 100644
--- a/src/ui/ui_gameinfo.c
+++ b/src/ui/ui_gameinfo.c
@@ -2,7 +2,7 @@
 ===========================================================================
 Copyright (C) 1999-2005 Id Software, Inc.
 Copyright (C) 2000-2009 Darklegion Development
- 
+
 This file is part of Tremulous.
  
 Tremulous is free software; you can redistribute it
@@ -62,13 +62,13 @@ int UI_ParseInfos( char *buf, int max, char *infos[] )
 
     if( strcmp( token, "{" ) )
     {
-      Com_Printf( "Missing { in info file\n" );
+      Com_Printf( _("Missing { in info file\n") );
       break;
     }
 
     if( count == max )
     {
-      Com_Printf( "Max infos exceeded\n" );
+      Com_Printf( _("Max infos exceeded\n") );
       break;
     }
 
@@ -80,7 +80,7 @@ int UI_ParseInfos( char *buf, int max, char *infos[] )
 
       if( !token[0] )
       {
-        Com_Printf( "Unexpected end of info file\n" );
+        Com_Printf( _("Unexpected end of info file\n") );
         break;
       }
 
@@ -125,13 +125,13 @@ static void UI_LoadArenasFromFile( char *filename )
 
   if( !f )
   {
-    trap_Print( va( S_COLOR_RED "file not found: %s\n", filename ) );
+    trap_Print( va( _(S_COLOR_RED "file not found: %s\n"), filename ) );
     return;
   }
 
   if( len >= MAX_ARENAS_TEXT )
   {
-    trap_Print( va( S_COLOR_RED "file too large: %s is %i, max allowed is %i", filename, len, MAX_ARENAS_TEXT ) );
+    trap_Print( va( _(S_COLOR_RED "file too large: %s is %i, max allowed is %i"), filename, len, MAX_ARENAS_TEXT ) );
     trap_FS_FCloseFile( f );
     return;
   }
@@ -186,10 +186,10 @@ void UI_LoadArenas( void )
     UI_LoadArenasFromFile( filename );
   }
 
-  trap_Print( va( "[skipnotify]%i arenas parsed\n", ui_numArenas ) );
+  trap_Print( va( _("[skipnotify]%i arenas parsed\n"), ui_numArenas ) );
 
   if( UI_OutOfMemory() )
-    trap_Print( S_COLOR_YELLOW"WARNING: not anough memory in pool to load all arenas\n" );
+    trap_Print( _(S_COLOR_YELLOW"WARNING: not anough memory in pool to load all arenas\n") );
 
   for( n = 0; n < ui_numArenas; n++ )
   {
@@ -228,13 +228,13 @@ static void UI_LoadBotsFromFile( char *filename )
 
   if( !f )
   {
-    trap_Print( va( S_COLOR_RED "file not found: %s\n", filename ) );
+    trap_Print( va( _(S_COLOR_RED "file not found: %s\n"), filename ) );
     return;
   }
 
   if( len >= MAX_BOTS_TEXT )
   {
-    trap_Print( va( S_COLOR_RED "file too large: %s is %i, max allowed is %i", filename, len, MAX_BOTS_TEXT ) );
+    trap_Print( va( _(S_COLOR_RED "file too large: %s is %i, max allowed is %i"), filename, len, MAX_BOTS_TEXT ) );
     trap_FS_FCloseFile( f );
     return;
   }
@@ -285,7 +285,7 @@ void UI_LoadBots( void )
     UI_LoadBotsFromFile( filename );
   }
 
-  trap_Print( va( "%i bots parsed\n", ui_numBots ) );
+  trap_Print( va( _("%i bots parsed\n"), ui_numBots ) );
 }
 
 
@@ -298,7 +298,7 @@ char *UI_GetBotInfoByNumber( int num )
 {
   if( num < 0 || num >= ui_numBots )
   {
-    trap_Print( va( S_COLOR_RED "Invalid bot number: %i\n", num ) );
+    trap_Print( va( _(S_COLOR_RED "Invalid bot number: %i\n"), num ) );
     return NULL;
   }
 
diff --git a/src/ui/ui_local.h b/src/ui/ui_local.h
index 2c78e26..cb22397 100644
--- a/src/ui/ui_local.h
+++ b/src/ui/ui_local.h
@@ -63,6 +63,8 @@ void UI_DrawConnectScreen( qboolean overlay );
 #define MAX_HELP_INFOPANES 32
 #define MAX_RESOLUTIONS 32
 
+#define _(String) gettext(String)
+
 typedef struct
 {
   const char *mapName;
@@ -385,6 +387,18 @@ qboolean  trap_GetNews( qboolean force );
 int       trap_LAN_CompareServers( int source, int sortKey, int sortDir, int s1, int s2 );
 int       trap_MemoryRemaining( void );
 void      trap_R_RegisterFont( const char *pFontname, int pointSize, fontInfo_t *font );
+void      trap_R_LoadFace(const char *fileName, int pointSize, const char *name, face_t *face);
+void      trap_R_FreeFace(face_t *face);
+void      trap_R_LoadGlyph(face_t *face, const char *str, int img, glyphInfo_t *glyphInfo);
+void      trap_R_FreeGlyph(face_t *face, int img, glyphInfo_t *glyphInfo);
+void      trap_R_Glyph(fontInfo_t *font, face_t *face, const char *str, glyphInfo_t *glyph);
+void      trap_R_FreeCachedGlyphs(face_t *face);
+void      LoadFace(const char *fileName, int pointSize, const char *name, face_t *face);
+void      FreeFace(face_t *face);
+void      LoadGlyph(face_t *face, const char *str, int img, glyphInfo_t *glyphInfo);
+void      FreeGlyph(face_t *face, int img, glyphInfo_t *glyphInfo);
+void      Glyph(fontInfo_t *font, face_t *face, const char *str, glyphInfo_t *glyph);
+void      FreeCachedGlyphs(face_t *face);
 void      trap_S_StopBackgroundTrack( void );
 void      trap_S_StartBackgroundTrack( const char *intro, const char *loop );
 int       trap_CIN_PlayCinematic( const char *arg0, int xpos, int ypos, int width, int height, int bits );
@@ -397,4 +411,8 @@ void      trap_R_RemapShader( const char *oldShader, const char *newShader, cons
 
 void      trap_SetPbClStatus( int status );
 
+void      trap_Gettext ( char *buffer, const char *msgid, int bufferLength );
+void      Gettext ( char *buffer, const char *msgid, int bufferLength );
+char      *gettext ( const char *msgid );
+
 #endif
diff --git a/src/ui/ui_main.c b/src/ui/ui_main.c
index f581e94..95d4659 100644
--- a/src/ui/ui_main.c
+++ b/src/ui/ui_main.c
@@ -95,6 +95,7 @@ vmCvar_t  ui_findPlayer;
 vmCvar_t  ui_serverStatusTimeOut;
 vmCvar_t  ui_textWrapCache;
 vmCvar_t  ui_developer;
+vmCvar_t  ui_ascii;
 
 vmCvar_t  ui_emoticons;
 vmCvar_t  ui_winner;
@@ -122,6 +123,7 @@ static cvarTable_t    cvarTable[ ] =
   { &ui_serverStatusTimeOut, "ui_serverStatusTimeOut", "7000", CVAR_ARCHIVE},
   { &ui_textWrapCache, "ui_textWrapCache", "1", CVAR_ARCHIVE },
   { &ui_developer, "ui_developer", "0", CVAR_ARCHIVE | CVAR_CHEAT },
+  { &ui_ascii, "ui_ascii", "0", CVAR_ARCHIVE },
   { &ui_emoticons, "cg_emoticons", "1", CVAR_LATCH | CVAR_ARCHIVE },
   { &ui_winner, "ui_winner", "", CVAR_ROM },
   { &ui_chatCommands, "ui_chatCommands", "1", CVAR_ARCHIVE }
@@ -139,7 +141,7 @@ This must be the very first function compiled into the .qvm file
 */
 void UI_Init( qboolean );
 void UI_Shutdown( void );
-void UI_KeyEvent( int key, qboolean down );
+void UI_KeyEvent( int key, int state );
 void UI_MouseEvent( int dx, int dy );
 int UI_MousePosition( void );
 void UI_SetMousePosition( int x, int y );
@@ -998,15 +1000,15 @@ static void UI_StopServerRefresh( void )
   }
 
   uiInfo.serverStatus.refreshActive = qfalse;
-  Com_Printf( "%d servers listed in browser with %d players.\n",
+  Com_Printf( _("%d servers listed in browser with %d players.\n"),
               uiInfo.serverStatus.numDisplayServers,
               uiInfo.serverStatus.numPlayersOnServers );
   count = trap_LAN_GetServerCount( ui_netSource.integer );
 
   if( count - uiInfo.serverStatus.numDisplayServers > 0 )
   {
-    Com_Printf( "%d servers not listed due to packet loss, invalid info,"
-                " or pings higher than %d\n",
+    Com_Printf( _("%d servers not listed due to packet loss, invalid info,"
+                " or pings higher than %d\n"),
                 count - uiInfo.serverStatus.numDisplayServers,
                 ( int ) trap_Cvar_VariableValue( "cl_maxPing" ) );
   }
@@ -1201,6 +1203,15 @@ UI_Shutdown
 void UI_Shutdown( void )
 {
   trap_LAN_SaveCachedServers();
+
+  FreeCachedGlyphs( &uiInfo.uiDC.Assets.dynFont );
+  FreeFace( &uiInfo.uiDC.Assets.dynFont );
+  FreeCachedGlyphs( &uiInfo.uiDC.Assets.smallDynFont );
+  FreeFace( &uiInfo.uiDC.Assets.smallDynFont );
+  FreeCachedGlyphs( &uiInfo.uiDC.Assets.bigDynFont );
+  FreeFace( &uiInfo.uiDC.Assets.bigDynFont );
+
+  UIS_Shutdown( );
 }
 
 qboolean Asset_Parse( int handle )
@@ -1259,6 +1270,40 @@ qboolean Asset_Parse( int handle )
       continue;
     }
 
+    if( Q_stricmp( token.string, "dynFont" ) == 0 )
+    {
+      int pointSize;
+
+      if( !PC_String_Parse( handle, &tempStr ) || !PC_Int_Parse( handle, &pointSize ) )
+        return qfalse;
+
+      LoadFace( tempStr, pointSize, tempStr, &uiInfo.uiDC.Assets.dynFont );
+      uiInfo.uiDC.Assets.dynFontRegistered = qtrue;
+      continue;
+    }
+
+    if( Q_stricmp( token.string, "smallDynFont" ) == 0 )
+    {
+      int pointSize;
+
+      if( !PC_String_Parse( handle, &tempStr ) || !PC_Int_Parse( handle, &pointSize ) )
+        return qfalse;
+
+      LoadFace( tempStr, pointSize, tempStr, &uiInfo.uiDC.Assets.smallDynFont );
+      continue;
+    }
+
+    if( Q_stricmp( token.string, "bigDynFont" ) == 0 )
+    {
+      int pointSize;
+
+      if( !PC_String_Parse( handle, &tempStr ) || !PC_Int_Parse( handle, &pointSize ) )
+        return qfalse;
+
+      LoadFace( tempStr, pointSize, tempStr, &uiInfo.uiDC.Assets.bigDynFont );
+      continue;
+    }
+
 
     // gradientbar
     if( Q_stricmp( token.string, "gradientbar" ) == 0 )
@@ -1387,7 +1432,7 @@ void UI_ParseMenu( const char *menuFile )
 
   if( !handle )
   {
-    Com_Printf( S_COLOR_YELLOW "WARNING: Menu file %s not found\n",
+    Com_Printf( _(S_COLOR_YELLOW "WARNING: Menu file %s not found\n"),
                 menuFile );
     return;
   }
@@ -1400,12 +1445,12 @@ void UI_ParseMenu( const char *menuFile )
       break;
 
     //if( Q_stricmp( token, "{" ) ) {
-    //  Com_Printf( "Missing { in menu file\n" );
+    //  Com_Printf( _("Missing { in menu file\n") );
     //  break;
     //}
 
     //if( menuCount == MAX_MENUS ) {
-    //  Com_Printf( "Too many menus!\n" );
+    //  Com_Printf( _("Too many menus!\n") );
     //  break;
     //}
 
@@ -1465,10 +1510,10 @@ void UI_LoadMenus( const char *menuFile, qboolean reset )
 
   start = trap_Milliseconds();
 
-  handle = trap_Parse_LoadSource( menuFile );
+  handle = trap_Parse_LoadSource( _(menuFile) );
 
   if( !handle )
-    trap_Error( va( S_COLOR_RED "menu list '%s' not found, unable to continue!\n", menuFile ) );
+    trap_Error( va( _(S_COLOR_RED "menu list '%s' not found, unable to continue!\n"), _(menuFile) ) );
 
   if( reset )
     Menu_Reset();
@@ -1493,7 +1538,7 @@ void UI_LoadMenus( const char *menuFile, qboolean reset )
     }
   }
 
-  Com_Printf( "UI menu file '%s' loaded in %d msec\n", menuFile, trap_Milliseconds() - start );
+  Com_Printf( _("UI menu file '%s' loaded in %d msec\n"), _(menuFile), trap_Milliseconds() - start );
 
   trap_Parse_FreeSource( handle );
 }
@@ -1505,20 +1550,20 @@ void UI_LoadHelp( const char *helpFile )
   char title[ 32 ], buffer[ 1024 ];
 
   start = trap_Milliseconds();
-  
-  handle = trap_Parse_LoadSource( helpFile );
+
+  handle = trap_Parse_LoadSource( _(helpFile) );
   if( !handle )
   {
-    Com_Printf( S_COLOR_YELLOW "WARNING: help file '%s' not found!\n",
-                helpFile );
+    Com_Printf( _(S_COLOR_YELLOW "WARNING: help file '%s' not found!\n"),
+                _(helpFile) );
     return;
   }
 
   if( !trap_Parse_ReadToken( handle, &token ) ||
       token.string[0] == 0 || token.string[0] != '{' )
   {
-    Com_Printf( S_COLOR_YELLOW "WARNING: help file '%s' does not start with "
-                "'{'\n", helpFile );
+    Com_Printf( _(S_COLOR_YELLOW "WARNING: help file '%s' does not start with "
+                "'{'\n"), _(helpFile) );
     return;
   }
 
@@ -1553,8 +1598,8 @@ void UI_LoadHelp( const char *helpFile )
 
   trap_Parse_FreeSource( handle );
 
-  Com_Printf( "UI help file '%s' loaded in %d msec (%d infopanes)\n",
-              helpFile, trap_Milliseconds() - start, uiInfo.helpCount );                   
+  Com_Printf( _("UI help file '%s' loaded in %d msec (%d infopanes)\n"),
+              _(helpFile), trap_Milliseconds() - start, uiInfo.helpCount );                   
 }
 
 void UI_Load( void )
@@ -1641,14 +1686,14 @@ static void UI_DrawInfoPane( menuItem_t *item, rectDef_t *rect, float text_x, fl
       if( value < 1 )
       {
         s = va( "%s\n\n%s",
-                BG_ClassConfig( item->v.pclass )->humanName,
-                BG_Class( item->v.pclass )->info );
+                _(BG_ClassConfig( item->v.pclass )->humanName),
+                _(BG_Class( item->v.pclass )->info) );
       }
       else
       {
-        s = va( "%s\n\n%s\n\nFrags: %d",
-                BG_ClassConfig( item->v.pclass )->humanName,
-                BG_Class( item->v.pclass )->info,
+        s = va( _("%s\n\n%s\n\nFrags: %d"),
+                _(BG_ClassConfig( item->v.pclass )->humanName),
+                _(BG_Class( item->v.pclass )->info),
                 value );
       }
 
@@ -1659,15 +1704,15 @@ static void UI_DrawInfoPane( menuItem_t *item, rectDef_t *rect, float text_x, fl
 
       if( value == 0 )
       {
-        s = va( "%s\n\n%s\n\nCredits: Free",
-                BG_Weapon( item->v.weapon )->humanName,
-                BG_Weapon( item->v.weapon )->info );
+        s = va( _("%s\n\n%s\n\nCredits: Free"),
+                _(BG_Weapon( item->v.weapon )->humanName),
+                _(BG_Weapon( item->v.weapon )->info) );
       }
       else
       {
-        s = va( "%s\n\n%s\n\nCredits: %d",
-                BG_Weapon( item->v.weapon )->humanName,
-                BG_Weapon( item->v.weapon )->info,
+        s = va( _("%s\n\n%s\n\nCredits: %d"),
+                _(BG_Weapon( item->v.weapon )->humanName),
+                _(BG_Weapon( item->v.weapon )->info),
                 value );
       }
 
@@ -1678,15 +1723,15 @@ static void UI_DrawInfoPane( menuItem_t *item, rectDef_t *rect, float text_x, fl
 
       if( value == 0 )
       {
-        s = va( "%s\n\n%s\n\nCredits: Free",
-                BG_Upgrade( item->v.upgrade )->humanName,
-                BG_Upgrade( item->v.upgrade )->info );
+        s = va( _("%s\n\n%s\n\nCredits: Free"),
+                _(BG_Upgrade( item->v.upgrade )->humanName),
+                _(BG_Upgrade( item->v.upgrade )->info) );
       }
       else
       {
-        s = va( "%s\n\n%s\n\nCredits: %d",
-                BG_Upgrade( item->v.upgrade )->humanName,
-                BG_Upgrade( item->v.upgrade )->info,
+        s = va( _("%s\n\n%s\n\nCredits: %d"),
+                _(BG_Upgrade( item->v.upgrade )->humanName),
+                _(BG_Upgrade( item->v.upgrade )->info),
                 value );
       }
 
@@ -1712,14 +1757,14 @@ static void UI_DrawInfoPane( menuItem_t *item, rectDef_t *rect, float text_x, fl
       if( value == 0 )
       {
         s = va( "%s\n\n%s",
-                BG_Buildable( item->v.buildable )->humanName,
-                BG_Buildable( item->v.buildable )->info );
+                _(BG_Buildable( item->v.buildable )->humanName),
+                _(BG_Buildable( item->v.buildable )->info) );
       }
       else
       {
         s = va( "%s\n\n%s\n\n%s: %d",
-                BG_Buildable( item->v.buildable )->humanName,
-                BG_Buildable( item->v.buildable )->info,
+                _(BG_Buildable( item->v.buildable )->humanName),
+                _(BG_Buildable( item->v.buildable )->info),
                 string, value );
       }
 
@@ -1935,8 +1980,8 @@ static void UI_DrawGLInfo( rectDef_t *rect, float scale, int textalign, int text
 {
   char      buffer[ 4096 ];
 
-  Com_sprintf( buffer, sizeof( buffer ), "VENDOR: %s\nVERSION: %s\n"
-               "PIXELFORMAT: color(%d-bits) Z(%d-bits) stencil(%d-bits)\n%s",
+  Com_sprintf( buffer, sizeof( buffer ), _("VENDOR: %s\nVERSION: %s\n"
+               "PIXELFORMAT: color(%d-bits) Z(%d-bits) stencil(%d-bits)\n%s"),
                uiInfo.uiDC.glconfig.vendor_string, uiInfo.uiDC.glconfig.renderer_string,
                uiInfo.uiDC.glconfig.colorBits, uiInfo.uiDC.glconfig.depthBits,
                uiInfo.uiDC.glconfig.stencilBits, uiInfo.uiDC.glconfig.extensions_string );
@@ -2163,7 +2208,7 @@ static qboolean UI_NetSource_HandleKey( int key )
   return qfalse;
 }
 
-static qboolean UI_OwnerDrawHandleKey( int ownerDraw, int key )
+static qboolean UI_OwnerDrawHandleKey( int ownerDraw, int key, int state )
 {
   switch( ownerDraw )
   {
@@ -2218,36 +2263,36 @@ static void UI_LoadTeams( void )
 {
   uiInfo.teamCount = 4;
 
-  uiInfo.teamList[ 0 ].text = String_Alloc( "Aliens" );
+  uiInfo.teamList[ 0 ].text = String_Alloc( _("Aliens") );
   uiInfo.teamList[ 0 ].cmd = String_Alloc( "cmd team aliens\n" );
   uiInfo.teamList[ 0 ].type = INFOTYPE_TEXT;
   uiInfo.teamList[ 0 ].v.text =
-    "The Alien Team\n\n"
+    _("The Alien Team\n\n"
     "The Aliens' strengths are in movement and the ability to "
     "quickly construct new bases quickly. They possess a range "
     "of abilities including basic melee attacks, movement-"
-    "crippling poisons and more.";
+    "crippling poisons and more.");
 
-  uiInfo.teamList[ 1 ].text = String_Alloc( "Humans" );
+  uiInfo.teamList[ 1 ].text = String_Alloc( _("Humans") );
   uiInfo.teamList[ 1 ].cmd = String_Alloc( "cmd team humans\n" );
   uiInfo.teamList[ 1 ].type = INFOTYPE_TEXT;
   uiInfo.teamList[ 1 ].v.text =
-    "The Human Team\n\n"
+    _("The Human Team\n\n"
     "The humans are the masters of technology. Although their "
     "bases take long to construct, their automated defense "
     "ensures they stay built. A wide range of upgrades and "
     "weapons are available to the humans, each contributing "
-    "to eradicate the alien threat.";
+    "to eradicate the alien threat.");
 
-  uiInfo.teamList[ 2 ].text = String_Alloc( "Spectate" );
+  uiInfo.teamList[ 2 ].text = String_Alloc( _("Spectate") );
   uiInfo.teamList[ 2 ].cmd = String_Alloc( "cmd team spectate\n" );
   uiInfo.teamList[ 2 ].type = INFOTYPE_TEXT;
-  uiInfo.teamList[ 2 ].v.text = "Watch the game without playing.";
+  uiInfo.teamList[ 2 ].v.text = _("Watch the game without playing.");
 
-  uiInfo.teamList[ 3 ].text = String_Alloc( "Auto select" );
+  uiInfo.teamList[ 3 ].text = String_Alloc( _("Auto select") );
   uiInfo.teamList[ 3 ].cmd = String_Alloc( "cmd team auto\n" );
   uiInfo.teamList[ 3 ].type = INFOTYPE_TEXT;
-  uiInfo.teamList[ 3 ].v.text = "Join the team with the least players.";
+  uiInfo.teamList[ 3 ].v.text = _("Join the team with the least players.");
 }
 
 /*
@@ -2260,7 +2305,7 @@ static void UI_AddClass( class_t class )
 {
   uiInfo.alienClassList[ uiInfo.alienClassCount ].text =
 
-    String_Alloc( BG_ClassConfig( class )->humanName );
+    String_Alloc( _(BG_ClassConfig( class )->humanName) );
   uiInfo.alienClassList[ uiInfo.alienClassCount ].cmd =
 
     String_Alloc( va( "cmd class %s\n", BG_Class( class )->name ) );
@@ -2298,7 +2343,7 @@ UI_AddItem
 static void UI_AddItem( weapon_t weapon )
 {
   uiInfo.humanItemList[ uiInfo.humanItemCount ].text =
-    String_Alloc( BG_Weapon( weapon )->humanName );
+    String_Alloc( _(BG_Weapon( weapon )->humanName) );
   uiInfo.humanItemList[ uiInfo.humanItemCount ].cmd =
     String_Alloc( va( "cmd class %s\n", BG_Weapon( weapon )->name ) );
   uiInfo.humanItemList[ uiInfo.humanItemCount ].type = INFOTYPE_WEAPON;
@@ -2416,7 +2461,7 @@ static void UI_LoadHumanArmouryBuys( void )
         !( uiInfo.weapons & ( 1 << i ) ) )
     {
       uiInfo.humanArmouryBuyList[ j ].text =
-        String_Alloc( BG_Weapon( i )->humanName );
+        String_Alloc( _(BG_Weapon( i )->humanName) );
       uiInfo.humanArmouryBuyList[ j ].cmd =
         String_Alloc( va( "cmd buy %s\n", BG_Weapon( i )->name ) );
       uiInfo.humanArmouryBuyList[ j ].type = INFOTYPE_WEAPON;
@@ -2438,7 +2483,7 @@ static void UI_LoadHumanArmouryBuys( void )
         !( uiInfo.upgrades & ( 1 << i ) ) )
     {
       uiInfo.humanArmouryBuyList[ j ].text =
-        String_Alloc( BG_Upgrade( i )->humanName );
+        String_Alloc( _(BG_Upgrade( i )->humanName) );
       uiInfo.humanArmouryBuyList[ j ].cmd =
         String_Alloc( va( "cmd buy %s\n", BG_Upgrade( i )->name ) );
       uiInfo.humanArmouryBuyList[ j ].type = INFOTYPE_UPGRADE;
@@ -2467,7 +2512,7 @@ static void UI_LoadHumanArmourySells( void )
   {
     if( uiInfo.weapons & ( 1 << i ) )
     {
-      uiInfo.humanArmourySellList[ j ].text = String_Alloc( BG_Weapon( i )->humanName );
+      uiInfo.humanArmourySellList[ j ].text = String_Alloc( _(BG_Weapon( i )->humanName) );
       uiInfo.humanArmourySellList[ j ].cmd =
         String_Alloc( va( "cmd sell %s\n", BG_Weapon( i )->name ) );
       uiInfo.humanArmourySellList[ j ].type = INFOTYPE_WEAPON;
@@ -2483,7 +2528,7 @@ static void UI_LoadHumanArmourySells( void )
   {
     if( uiInfo.upgrades & ( 1 << i ) )
     {
-      uiInfo.humanArmourySellList[ j ].text = String_Alloc( BG_Upgrade( i )->humanName );
+      uiInfo.humanArmourySellList[ j ].text = String_Alloc( _(BG_Upgrade( i )->humanName) );
       uiInfo.humanArmourySellList[ j ].cmd =
         String_Alloc( va( "cmd sell %s\n", BG_Upgrade( i )->name ) );
       uiInfo.humanArmourySellList[ j ].type = INFOTYPE_UPGRADE;
@@ -2539,7 +2584,7 @@ static void UI_LoadAlienUpgrades( void )
   {
     if( BG_ClassCanEvolveFromTo( class, i, credits, stage, 0 ) >= 0 )
     {
-      uiInfo.alienUpgradeList[ j ].text = String_Alloc( BG_ClassConfig( i )->humanName );
+      uiInfo.alienUpgradeList[ j ].text = String_Alloc( _(BG_ClassConfig( i )->humanName) );
       uiInfo.alienUpgradeList[ j ].cmd =
         String_Alloc( va( "cmd class %s\n", BG_Class( i )->name ) );
       uiInfo.alienUpgradeList[ j ].type = INFOTYPE_CLASS;
@@ -2575,7 +2620,7 @@ static void UI_LoadAlienBuilds( void )
         BG_BuildableIsAllowed( i ) )
     {
       uiInfo.alienBuildList[ j ].text =
-        String_Alloc( BG_Buildable( i )->humanName );
+        String_Alloc( _(BG_Buildable( i )->humanName) );
       uiInfo.alienBuildList[ j ].cmd =
         String_Alloc( va( "cmd build %s\n", BG_Buildable( i )->name ) );
       uiInfo.alienBuildList[ j ].type = INFOTYPE_BUILDABLE;
@@ -2611,7 +2656,7 @@ static void UI_LoadHumanBuilds( void )
         BG_BuildableIsAllowed( i ) )
     {
       uiInfo.humanBuildList[ j ].text =
-        String_Alloc( BG_Buildable( i )->humanName );
+        String_Alloc( _(BG_Buildable( i )->humanName));
       uiInfo.humanBuildList[ j ].cmd =
         String_Alloc( va( "cmd build %s\n", BG_Buildable( i )->name ) );
       uiInfo.humanBuildList[ j ].type = INFOTYPE_BUILDABLE;
@@ -3290,17 +3335,17 @@ static void UI_RunMenuScript( char **args )
           if( res == 0 )
           {
             // server already in the list
-            Com_Printf( "Favorite already in list\n" );
+            Com_Printf( _("Favorite already in list\n") );
           }
           else if( res == -1 )
           {
             // list full
-            Com_Printf( "Favorite list full\n" );
+            Com_Printf( _("Favorite list full\n") );
           }
           else
           {
             // successfully added
-            Com_Printf( "Added favorite server %s\n", addr );
+            Com_Printf( _("Added favorite server %s\n"), addr );
           }
         }
       }
@@ -3339,17 +3384,17 @@ static void UI_RunMenuScript( char **args )
           if( res == 0 )
           {
             // server already in the list
-            Com_Printf( "Favorite already in list\n" );
+            Com_Printf( _("Favorite already in list\n") );
           }
           else if( res == -1 )
           {
             // list full
-            Com_Printf( "Favorite list full\n" );
+            Com_Printf( _("Favorite list full\n") );
           }
           else
           {
             // successfully added
-            Com_Printf( "Added favorite server %s\n", addr );
+            Com_Printf( _("Added favorite server %s\n"), addr );
           }
         }
       }
@@ -3413,7 +3458,7 @@ static void UI_RunMenuScript( char **args )
       }
     }
     else
-      Com_Printf( "unknown UI script %s\n", name );
+      Com_Printf( _("unknown UI script %s\n"), name );
   }
 }
 
@@ -3664,7 +3709,7 @@ static const char *UI_FeederItemText( int feederID, int index, int column, qhand
   else if( feederID == FEEDER_TEAM_LIST )
   {
     if( index >= 0 && index < uiInfo.myTeamCount )
-      return uiInfo.teamNames[index];
+      return _(uiInfo.teamNames[index]);
   }
   else if( feederID == FEEDER_IGNORE_LIST )
   {
@@ -4066,6 +4111,12 @@ void UI_Init( qboolean inGameLoad )
   uiInfo.uiDC.addRefEntityToScene = &trap_R_AddRefEntityToScene;
   uiInfo.uiDC.renderScene = &trap_R_RenderScene;
   uiInfo.uiDC.registerFont = &trap_R_RegisterFont;
+  uiInfo.uiDC.loadFace = &LoadFace;
+  uiInfo.uiDC.freeFace = &FreeFace;
+  uiInfo.uiDC.loadGlyph = &LoadGlyph;
+  uiInfo.uiDC.freeGlyph = &FreeGlyph;
+  uiInfo.uiDC.glyph = &Glyph;
+  uiInfo.uiDC.freeCachedGlyphs = &FreeCachedGlyphs;
   uiInfo.uiDC.ownerDrawItem = &UI_OwnerDraw;
   uiInfo.uiDC.getValue = &UI_GetValue;
   uiInfo.uiDC.ownerDrawVisible = &UI_OwnerDrawVisible;
@@ -4135,18 +4186,32 @@ void UI_Init( qboolean inGameLoad )
 UI_KeyEvent
 =================
 */
-void UI_KeyEvent( int key, qboolean down )
+void UI_KeyEvent( int key, int state )
 {
+  qboolean sup = state & (1 << KEYEVSTATE_SUP);
+
+  if( sup )
+  {
+    qboolean bit = ( state & (1 << KEYEVSTATE_BIT) ) >> KEYEVSTATE_BIT;
+
+    if( bit )
+      key |= bit << (K_CHAR_BIT - 1);
+    else
+      key &= ~(bit << (K_CHAR_BIT - 1));
+  }
+
   if( Menu_Count() > 0 )
   {
     menuDef_t *menu = Menu_GetFocused();
+    qboolean sup = state & (1 << KEYEVSTATE_SUP);
+    qboolean down = !sup ? state : state & (1 << KEYEVSTATE_DOWN);
 
     if( menu )
     {
       if( key == K_ESCAPE && down && !Menus_AnyFullScreenVisible() )
         Menus_CloseAll( );
       else
-        Menu_HandleKey( menu, key, down );
+        Menu_HandleKey( menu, key, state );
     }
     else
     {
@@ -4511,7 +4576,7 @@ void UI_DrawConnectScreen( qboolean overlay )
                       "Starting up...", ITEM_TEXTSTYLE_SHADOWEDMORE );
   else
   {
-    Com_sprintf( text, sizeof( text ), "Connecting to %s", cstate.servername );
+    Com_sprintf( text, sizeof( text ), _("Connecting to %s"), cstate.servername );
     Text_PaintCenter( centerPoint, yStart + 48, scale, colorWhite, text , ITEM_TEXTSTYLE_SHADOWEDMORE );
   }
 
@@ -4544,7 +4609,7 @@ void UI_DrawConnectScreen( qboolean overlay )
         int prompt = trap_Cvar_VariableValue( "com_downloadPrompt" );
         
         if( prompt & DLP_SHOW ) {
-          Com_Printf("Opening download prompt...\n");
+          Com_Printf(_("Opening download prompt...\n"));
           trap_Key_SetCatcher( KEYCATCH_UI );
           Menus_ActivateByName("download_popmenu");
           trap_Cvar_Set( "com_downloadPrompt", "0" );
@@ -4629,7 +4694,7 @@ void UI_UpdateNews( qboolean begin )
     return; 
   else if( uiInfo.uiDC.realTime > uiInfo.newsInfo.refreshtime ) {
     strcpy( uiInfo.newsInfo.text[ 0 ], 
-      "^1Error: Timed out while contacting the server.");
+      _("^1Error: Timed out while contacting the server."));
     uiInfo.newsInfo.numLines = 1;
     return; 
   }
@@ -4671,3 +4736,156 @@ void UI_UpdateNews( qboolean begin )
     uiInfo.newsInfo.refreshActive = qfalse;
 }
 
+void LoadFace( const char *fileName, int pointSize, const char *name, face_t *face )
+{
+  static int engineState = 0;
+
+  if( !( engineState & 0x01 ) )
+  {
+    char t[2];
+
+    engineState |= 0x01;
+
+    trap_Cvar_VariableStringBuffer( "\\IS_GETTEXT_SUPPORTED", t, 2 );
+
+    if( t[0] == '1' )
+      engineState |= 0x02;
+  }
+
+  if( engineState & 0x02 )
+    trap_R_LoadFace( fileName, pointSize, name, face );
+}
+
+void FreeFace( face_t *face )
+{
+  static int engineState = 0;
+
+  if( !( engineState & 0x01 ) )
+  {
+    char t[2];
+
+    engineState |= 0x01;
+
+    trap_Cvar_VariableStringBuffer( "\\IS_GETTEXT_SUPPORTED", t, 2 );
+
+    if( t[0] == '1' )
+      engineState |= 0x02;
+  }
+
+  if( engineState & 0x02 )
+    trap_R_FreeFace( face );
+}
+
+void LoadGlyph( face_t *face, const char *str, int img, glyphInfo_t *glyphInfo )
+{
+  static int engineState = 0;
+
+  if( !( engineState & 0x01 ) )
+  {
+    char t[2];
+
+    engineState |= 0x01;
+
+    trap_Cvar_VariableStringBuffer( "\\IS_GETTEXT_SUPPORTED", t, 2 );
+
+    if( t[0] == '1' )
+      engineState |= 0x02;
+  }
+
+  if( engineState & 0x02 )
+    trap_R_LoadGlyph( face, str, img, glyphInfo );
+}
+
+void FreeGlyph( face_t *face, int img, glyphInfo_t *glyphInfo )
+{
+  static int engineState = 0;
+
+  if( !( engineState & 0x01 ) )
+  {
+    char t[2];
+
+    engineState |= 0x01;
+
+    trap_Cvar_VariableStringBuffer( "\\IS_GETTEXT_SUPPORTED", t, 2 );
+
+    if( t[0] == '1' )
+      engineState |= 0x02;
+  }
+
+  if( engineState & 0x02 )
+    trap_R_FreeGlyph( face, img, glyphInfo );
+}
+
+void Glyph( fontInfo_t *font, face_t *face, const char *str, glyphInfo_t *glyph )
+{
+  static int engineState = 0;
+
+  if( !( engineState & 0x01 ) )
+  {
+    char t[2];
+
+    engineState |= 0x01;
+
+    trap_Cvar_VariableStringBuffer( "\\IS_GETTEXT_SUPPORTED", t, 2 );
+
+    if( t[0] == '1' )
+      engineState |= 0x02;
+  }
+
+  if( engineState & 0x02 )
+    trap_R_Glyph( font, face, str, glyph );
+}
+
+void FreeCachedGlyphs( face_t *face )
+{
+  static int engineState = 0;
+
+  if( !( engineState & 0x01 ) )
+  {
+    char t[2];
+
+    engineState |= 0x01;
+
+    trap_Cvar_VariableStringBuffer( "\\IS_GETTEXT_SUPPORTED", t, 2 );
+
+    if( t[0] == '1' )
+      engineState |= 0x02;
+  }
+
+  if( engineState & 0x02 )
+    trap_R_FreeCachedGlyphs( face );
+}
+
+void Gettext( char *buffer, const char *msgid, int bufferLength )
+{
+  static int engineState = 0;
+
+  if( !( engineState & 0x01 ) )
+  {
+    char t[2];
+
+    engineState |= 0x01;
+
+    trap_Cvar_VariableStringBuffer( "\\IS_GETTEXT_SUPPORTED", t, 2 );
+
+    if( t[0] == '1' )
+      engineState |= 0x02;
+  }
+
+  if( !( engineState & 0x02 ) )
+    strncpy( buffer, msgid, bufferLength );
+  else
+    trap_Gettext( buffer, msgid, bufferLength );
+}
+
+char *gettext ( const char *msgid )
+{
+  static char string[8][32000];
+  static int  index = 0;
+  char        *buf = string[index++ & 7];
+
+  Gettext( buf, msgid, sizeof( *string ) );
+
+  return buf;
+}
+
diff --git a/src/ui/ui_public.h b/src/ui/ui_public.h
index f746eb3..a740e52 100644
--- a/src/ui/ui_public.h
+++ b/src/ui/ui_public.h
@@ -137,7 +137,15 @@ typedef enum
   UI_ATAN2,
   UI_SQRT,
   UI_FLOOR,
-  UI_CEIL
+  UI_CEIL,
+
+  UI_GETTEXT = 300,
+  UI_R_LOADFACE,
+  UI_R_FREEFACE,
+  UI_R_LOADGLYPH,
+  UI_R_FREEGLYPH,
+  UI_R_GLYPH,
+  UI_R_FREECACHEDGLYPHS
 }
 uiImport_t;
 
@@ -169,7 +177,7 @@ typedef enum
   //  void  UI_Shutdown( void );
 
   UI_KEY_EVENT,
-  //  void  UI_KeyEvent( int key );
+  //  void  UI_KeyEvent( const char *key );
 
   UI_MOUSE_EVENT,
   //  void  UI_MouseEvent( int dx, int dy );
diff --git a/src/ui/ui_shared.c b/src/ui/ui_shared.c
index 4f579e4..b64628f 100644
--- a/src/ui/ui_shared.c
+++ b/src/ui/ui_shared.c
@@ -28,6 +28,12 @@ Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 #define SCROLL_TIME_ADJUSTOFFSET  40
 #define SCROLL_TIME_FLOOR         20
 
+#define _(String) gettext(String)
+
+char *gettext ( const char *msgid );
+void FreeFace(face_t *face);
+void FreeCachedGlyphs(face_t *face);
+
 typedef struct scrollInfo_s
 {
   int nextScrollTime;
@@ -85,13 +91,28 @@ static ID_INLINE qboolean Item_IsListBox( itemDef_t *item );
 static void Item_ListBox_SetStartPos( itemDef_t *item, int startPos );
 void Menu_SetupKeywordHash( void );
 int BindingIDFromName( const char *name );
-qboolean Item_Bind_HandleKey( itemDef_t *item, int key, qboolean down );
+qboolean Item_Bind_HandleKey( itemDef_t *item, int key, int state );
 itemDef_t *Menu_SetPrevCursorItem( menuDef_t *menu );
 itemDef_t *Menu_SetNextCursorItem( menuDef_t *menu );
 static qboolean Menu_OverActiveItem( menuDef_t *menu, float x, float y );
 
 /*
 ===============
+UIS_Shutdown
+===============
+*/
+void UIS_Shutdown( void )
+{
+  FreeCachedGlyphs( &DC->Assets.dynFont );
+  FreeFace( &DC->Assets.dynFont );
+  FreeCachedGlyphs( &DC->Assets.smallDynFont );
+  FreeFace( &DC->Assets.smallDynFont );
+  FreeCachedGlyphs( &DC->Assets.bigDynFont );
+  FreeFace( &DC->Assets.bigDynFont );
+}
+
+/*
+===============
 UI_InstallCaptureFunc
 ===============
 */
@@ -141,9 +162,9 @@ void *UI_Alloc( int size )
     outOfMemory = qtrue;
 
     if( DC->Print )
-      DC->Print( "UI_Alloc: Failure. Out of memory!\n" );
+      DC->Print( _("UI_Alloc: Failure. Out of memory!\n") );
 
-    //DC->trap_Print(S_COLOR_YELLOW"WARNING: UI Out of Memory!\n");
+    //DC->trap_Print(_(S_COLOR_YELLOW"WARNING: UI Out of Memory!\n"));
     return NULL;
   }
 
@@ -275,16 +296,16 @@ const char *String_Alloc( const char *p )
 void String_Report( void )
 {
   float f;
-  Com_Printf( "Memory/String Pool Info\n" );
-  Com_Printf( "----------------\n" );
+  Com_Printf( _("Memory/String Pool Info\n") );
+  Com_Printf( _("----------------\n") );
   f = strPoolIndex;
   f /= STRING_POOL_SIZE;
   f *= 100;
-  Com_Printf( "String Pool is %.1f%% full, %i bytes out of %i used.\n", f, strPoolIndex, STRING_POOL_SIZE );
+  Com_Printf( _("String Pool is %.1f%% full, %i bytes out of %i used.\n"), f, strPoolIndex, STRING_POOL_SIZE );
   f = allocPoint;
   f /= MEM_POOL_SIZE;
   f *= 100;
-  Com_Printf( "Memory Pool is %.1f%% full, %i bytes out of %i used.\n", f, allocPoint, MEM_POOL_SIZE );
+  Com_Printf( _("Memory Pool is %.1f%% full, %i bytes out of %i used.\n"), f, allocPoint, MEM_POOL_SIZE );
 }
 
 /*
@@ -337,7 +358,7 @@ void PC_SourceWarning( int handle, char *format, ... )
   line = 0;
   trap_Parse_SourceFileAndLine( handle, filename, &line );
 
-  Com_Printf( S_COLOR_YELLOW "WARNING: %s, line %d: %s\n", filename, line, string );
+  Com_Printf( _(S_COLOR_YELLOW "WARNING: %s, line %d: %s\n"), filename, line, string );
 }
 
 /*
@@ -360,7 +381,7 @@ void PC_SourceError( int handle, char *format, ... )
   line = 0;
   trap_Parse_SourceFileAndLine( handle, filename, &line );
 
-  Com_Printf( S_COLOR_RED "ERROR: %s, line %d: %s\n", filename, line, string );
+  Com_Printf( _(S_COLOR_RED "ERROR: %s, line %d: %s\n"), filename, line, string );
 }
 
 /*
@@ -643,7 +664,7 @@ static qboolean PC_Expression_Parse( int handle, float *f )
           break;
 
         default:
-          Com_Error( ERR_FATAL, "Unknown operator '%c' in postfix string", op );
+          Com_Error( ERR_FATAL, _("Unknown operator '%c' in postfix string"), op );
           return qfalse;
       }
 
@@ -693,7 +714,7 @@ qboolean PC_Float_Parse( int handle, float *f )
 
   if( token.type != TT_NUMBER )
   {
-    PC_SourceError( handle, "expected float but found %s\n", token.string );
+    PC_SourceError( handle, _("expected float but found %s\n"), token.string );
     return qfalse;
   }
 
@@ -802,7 +823,7 @@ qboolean PC_Int_Parse( int handle, int *i )
 
   if( token.type != TT_NUMBER )
   {
-    PC_SourceError( handle, "expected integer but found %s\n", token.string );
+    PC_SourceError( handle, _("expected integer but found %s\n"), token.string );
     return qfalse;
   }
 
@@ -897,6 +918,23 @@ qboolean PC_String_Parse( int handle, const char **out )
 
 /*
 =================
+PC_String_Parse_
+=================
+*/
+qboolean PC_String_Parse_( int handle, const char **out )
+{
+  pc_token_t token;
+
+  if( !trap_Parse_ReadToken( handle, &token ) )
+    return qfalse;
+
+  *( out ) = String_Alloc( _(token.string) );
+
+  return qtrue;
+}
+
+/*
+=================
 PC_Script_Parse
 =================
 */
@@ -1858,6 +1896,30 @@ void Script_playLooped( itemDef_t *item, char **args )
   }
 }
 
+static int UI_UTF8Width( face_t *face, const char *str )
+{
+  if( DC->getCVarValue( "ui_ascii" ) )
+    return 1;
+
+  if( !face )
+    return 1;
+
+  return Q_UTF8Width( str );
+}
+
+glyphInfo_t *UI_Glyph( fontInfo_t *font, face_t *face, const char *str )
+{
+  static glyphInfo_t glyphs[8];
+  static int index = 0;
+  glyphInfo_t *glyph = &glyphs[index++ & 7];
+
+  if( !str || !*str || !face || UI_UTF8Width( face, str ) <= 1 )
+    return &font->glyphs[ (int)*str ];
+
+  DC->glyph( font, face, str, glyph );
+  return glyph;
+}
+
 void UI_EscapeEmoticons( char *dest, const char *src, int destsize )
 {
   int len;
@@ -1960,6 +2022,7 @@ float UI_Text_Width( const char *text, float scale, int limit )
   float       useScale;
   const char  *s = text;
   fontInfo_t  *font = &DC->Assets.textFont;
+  face_t      *face = &DC->Assets.dynFont;
   int         emoticonLen;
   qboolean    emoticonEscaped;
   float       emoticonW;
@@ -1968,9 +2031,15 @@ float UI_Text_Width( const char *text, float scale, int limit )
   float       indentWidth = 0.0f;
 
   if( scale <= DC->getCVarValue( "ui_smallFont" ) )
+  {
     font = &DC->Assets.smallFont;
+    face = &DC->Assets.smallDynFont;
+  }
   else if( scale >= DC->getCVarValue( "ui_bigFont" ) )
+  {
     font = &DC->Assets.bigFont;
+    face = &DC->Assets.bigDynFont;
+  }
 
   useScale = scale * font->glyphScale;
   emoticonW = UI_Text_Height( "[", scale, 0 ) * DC->aspectScale;
@@ -1978,7 +2047,7 @@ float UI_Text_Width( const char *text, float scale, int limit )
 
   if( text )
   {
-    len = Q_PrintStrlen( text );
+    len = Q_UTF8PrintStrlen( text );
 
     if( limit > 0 && len > limit )
       len = limit;
@@ -1988,7 +2057,7 @@ float UI_Text_Width( const char *text, float scale, int limit )
 
     while( s && *s && count < len )
     {
-      glyph = &font->glyphs[( int )*s];
+      glyph = UI_Glyph( font, face, s );
 
       if( Q_IsColorString( s ) )
       {
@@ -2017,7 +2086,7 @@ float UI_Text_Width( const char *text, float scale, int limit )
         }
       }
       out += ( glyph->xSkip * DC->aspectScale );
-      s++;
+      s += UI_UTF8Width( face, s );
       count++;
     }
   }
@@ -2033,11 +2102,18 @@ float UI_Text_Height( const char *text, float scale, int limit )
   float       useScale;
   const char  *s = text;
   fontInfo_t  *font = &DC->Assets.textFont;
+  face_t      *face = &DC->Assets.dynFont;
 
   if( scale <= DC->getCVarValue( "ui_smallFont" ) )
+  {
     font = &DC->Assets.smallFont;
+    face = &DC->Assets.smallDynFont;
+  }
   else if( scale >= DC->getCVarValue( "ui_bigFont" ) )
+  {
     font = &DC->Assets.bigFont;
+    face = &DC->Assets.bigDynFont;
+  }
 
   useScale = scale * font->glyphScale;
   max = 0;
@@ -2060,12 +2136,12 @@ float UI_Text_Height( const char *text, float scale, int limit )
       }
       else
       {
-        glyph = &font->glyphs[( int )*s];
+        glyph = UI_Glyph( font, face, s );
 
         if( max < glyph->height )
           max = glyph->height;
 
-        s++;
+        s += UI_UTF8Width( face, s );
         count++;
       }
     }
@@ -2164,27 +2240,34 @@ static void UI_Text_Paint_Generic( float x, float y, float scale, float gapAdjus
                                    int limit, float *maxX,
                                    int cursorPos, char cursor )
 {
-  const char  *s = text;
-  int         len;
-  int         count = 0;
-  vec4_t      newColor;
-  fontInfo_t  *font = &DC->Assets.textFont;
+  const char   *s = text;
+  int          len;
+  int          count = 0;
+  vec4_t       newColor;
+  fontInfo_t   *font = &DC->Assets.textFont;
+  face_t       *face = &DC->Assets.dynFont;
+  float        useScale;
+  qhandle_t    emoticonHandle = 0;
+  float        emoticonH, emoticonW;
+  qboolean     emoticonEscaped;
+  int          emoticonLen = 0;
+  int          emoticonWidth;
+  int          cursorX = -1;
   glyphInfo_t *glyph;
-  float       useScale;
-  qhandle_t   emoticonHandle = 0;
-  float       emoticonH, emoticonW;
-  qboolean    emoticonEscaped;
-  int         emoticonLen = 0;
-  int         emoticonWidth;
-  int         cursorX = -1;
 
   if( !text )
     return;
 
   if( scale <= DC->getCVarValue( "ui_smallFont" ) )
+  {
     font = &DC->Assets.smallFont;
+    face = &DC->Assets.smallDynFont;
+  }
   else if( scale >= DC->getCVarValue( "ui_bigFont" ) )
+  {
     font = &DC->Assets.bigFont;
+    face = &DC->Assets.bigDynFont;
+  }
 
   useScale = scale * font->glyphScale;
 
@@ -2200,9 +2283,9 @@ static void UI_Text_Paint_Generic( float x, float y, float scale, float gapAdjus
 
   x += UI_Parse_Indent( &s );
 
-  while( s && *s && count < len )
+  while( s && *s && s - text < len )
   {
-    glyph = &font->glyphs[ (int)*s ];
+    glyph = UI_Glyph( font, face, s );
 
     if( maxX && UI_Text_Width( s, scale, 1 ) + x > *maxX )
     {
@@ -2288,8 +2371,8 @@ static void UI_Text_Paint_Generic( float x, float y, float scale, float gapAdjus
       cursorX = x;
 
     x += ( glyph->xSkip * DC->aspectScale * useScale ) + gapAdjust;
-    s++;
-    count++;
+    count += UI_UTF8Width( face, s );
+    s += UI_UTF8Width( face, s );
 
   }
 
@@ -2866,26 +2949,29 @@ void Item_SetMouseOver( itemDef_t *item, qboolean focus )
 }
 
 
-qboolean Item_OwnerDraw_HandleKey( itemDef_t *item, int key )
+qboolean Item_OwnerDraw_HandleKey( itemDef_t *item, int key, int state )
 {
   if( item && DC->ownerDrawHandleKey )
-    return DC->ownerDrawHandleKey( item->window.ownerDraw, key );
+    return DC->ownerDrawHandleKey( item->window.ownerDraw, key, state );
 
   return qfalse;
 }
 
-qboolean Item_ListBox_HandleKey( itemDef_t *item, int key, qboolean down, qboolean force )
+qboolean Item_ListBox_HandleKey( itemDef_t *item, int key, int state, qboolean force )
 {
   listBoxDef_t *listPtr = item->typeData.list;
   int count = DC->feederCount( item->feederID );
   int viewmax;
+  qboolean sup = state & (1 << KEYEVSTATE_SUP);
+  qboolean isChar = !sup ? key & (1 << (K_CHAR_BIT - 1)) : state & (1 << KEYEVSTATE_CHAR);
+  int first = (!isChar || !sup) ? key : *Q_UTF8Unstore( key );
 
   if( force || ( Rect_ContainsPoint( &item->window.rect, DC->cursorx, DC->cursory ) &&
       item->window.flags & WINDOW_HASFOCUS ) )
   {
     viewmax = Item_ListBox_NumItemsForItemHeight( item );
 
-    switch( key )
+    switch( first )
     {
       case K_MOUSE1:
       case K_MOUSE2:
@@ -3004,14 +3090,18 @@ qboolean Item_ListBox_HandleKey( itemDef_t *item, int key, qboolean down, qboole
   return qfalse;
 }
 
-qboolean Item_ComboBox_HandleKey( itemDef_t *item, int key, qboolean down, qboolean force )
+qboolean Item_ComboBox_HandleKey( itemDef_t *item, int key, int state, qboolean force )
 {
+  qboolean sup = state & (1 << KEYEVSTATE_SUP);
+  qboolean isChar = !sup ? key & (1 << (K_CHAR_BIT - 1)) : state & (1 << KEYEVSTATE_CHAR);
+  int first = (!isChar || !sup) ? key : *Q_UTF8Unstore( key );
+
   if( g_comboBoxItem != NULL )
   {
     qboolean result;
 
     qboolean cast = Item_ComboBox_MaybeCastToListBox( item );
-    result = Item_ListBox_HandleKey( item, key, down, force );
+    result = Item_ListBox_HandleKey( item, first, state, force );
     Item_ComboBox_MaybeUnCastFromListBox( item, cast );
 
     if( !result )
@@ -3024,7 +3114,7 @@ qboolean Item_ComboBox_HandleKey( itemDef_t *item, int key, qboolean down, qbool
     if( force || ( Rect_ContainsPoint( &item->window.rect, DC->cursorx, DC->cursory ) &&
         item->window.flags & WINDOW_HASFOCUS ) )
     {
-      if( key == K_MOUSE1 || key == K_MOUSE2 )
+      if( first == K_MOUSE1 || first == K_MOUSE2 )
       {
         g_comboBoxItem = item;
 
@@ -3036,12 +3126,16 @@ qboolean Item_ComboBox_HandleKey( itemDef_t *item, int key, qboolean down, qbool
   return qfalse;
 }
 
-qboolean Item_YesNo_HandleKey( itemDef_t *item, int key )
+qboolean Item_YesNo_HandleKey( itemDef_t *item, int key, int state )
 {
+  qboolean sup = state & (1 << KEYEVSTATE_SUP);
+  qboolean isChar = !sup ? key & (1 << (K_CHAR_BIT - 1)) : state & (1 << KEYEVSTATE_CHAR);
+  int first = (!isChar || !sup) ? key : *Q_UTF8Unstore( key );
+
   if( Rect_ContainsPoint( &item->window.rect, DC->cursorx, DC->cursory ) &&
       item->window.flags & WINDOW_HASFOCUS && item->cvar )
   {
-    if( key == K_MOUSE1 || key == K_ENTER || key == K_MOUSE2 || key == K_MOUSE3 )
+    if( first == K_MOUSE1 || first == K_ENTER || first == K_MOUSE2 || first == K_MOUSE3 )
     {
       DC->setCVar( item->cvar, va( "%i", !DC->getCVarValue( item->cvar ) ) );
       return qtrue;
@@ -3124,18 +3218,21 @@ const char *Item_Multi_Setting( itemDef_t *item )
   return "";
 }
 
-qboolean Item_Cycle_HandleKey( itemDef_t *item, int key )
+qboolean Item_Cycle_HandleKey( itemDef_t *item, int key, int state )
 {
   cycleDef_t *cyclePtr = item->typeData.cycle;
   qboolean mouseOver = Rect_ContainsPoint( &item->window.rect, DC->cursorx, DC->cursory );
   int count = DC->feederCount( item->feederID );
+  qboolean sup = state & (1 << KEYEVSTATE_SUP);
+  qboolean isChar = !sup ? key & (1 << (K_CHAR_BIT - 1)) : state & (1 << KEYEVSTATE_CHAR);
+  int first = (!isChar || !sup) ? key : *Q_UTF8Unstore( key );
 
   if( cyclePtr )
   {
     if( item->window.flags & WINDOW_HASFOCUS )
     {
-      if( ( mouseOver && key == K_MOUSE1 ) ||
-          key == K_ENTER || key == K_RIGHTARROW || key == K_DOWNARROW )
+      if( ( mouseOver && first == K_MOUSE1 ) ||
+          key == K_ENTER || first == K_RIGHTARROW || first == K_DOWNARROW )
       {
         if( count > 0 )
           cyclePtr->cursorPos = ( cyclePtr->cursorPos + 1 ) % count;
@@ -3144,8 +3241,8 @@ qboolean Item_Cycle_HandleKey( itemDef_t *item, int key )
 
         return qtrue;
       }
-      else if( ( mouseOver && key == K_MOUSE2 ) ||
-               key == K_LEFTARROW || key == K_UPARROW )
+      else if( ( mouseOver && first == K_MOUSE2 ) ||
+               first == K_LEFTARROW || first == K_UPARROW )
       {
         if( count > 0 )
           cyclePtr->cursorPos = ( count + cyclePtr->cursorPos - 1 ) % count;
@@ -3160,11 +3257,14 @@ qboolean Item_Cycle_HandleKey( itemDef_t *item, int key )
   return qfalse;
 }
 
-qboolean Item_Multi_HandleKey( itemDef_t *item, int key )
+qboolean Item_Multi_HandleKey( itemDef_t *item, int key, int state )
 {
   qboolean mouseOver = Rect_ContainsPoint( &item->window.rect, DC->cursorx, DC->cursory );
   int max = Item_Multi_CountSettings( item );
   qboolean changed = qfalse;
+  qboolean sup = state & (1 << KEYEVSTATE_SUP);
+  qboolean isChar = !sup ? key & (1 << (K_CHAR_BIT - 1)) : state & (1 << KEYEVSTATE_CHAR);
+  int first = (!isChar || !sup) ? key : *Q_UTF8Unstore( key );
 
   if( item->typeData.multi )
   {
@@ -3172,14 +3272,14 @@ qboolean Item_Multi_HandleKey( itemDef_t *item, int key )
     {
       int current;
 
-      if( ( mouseOver && key == K_MOUSE1 ) ||
-          key == K_ENTER || key == K_RIGHTARROW || key == K_DOWNARROW )
+      if( ( mouseOver && first == K_MOUSE1 ) ||
+          first == K_ENTER || first == K_RIGHTARROW || first == K_DOWNARROW )
       {
         current = ( Item_Multi_FindCvarByValue( item ) + 1 ) % max;
         changed = qtrue;
       }
-      else if( ( mouseOver && key == K_MOUSE2 ) ||
-               key == K_LEFTARROW || key == K_UPARROW )
+      else if( ( mouseOver && first == K_MOUSE2 ) ||
+               first == K_LEFTARROW || first == K_UPARROW )
       {
         current = ( Item_Multi_FindCvarByValue( item ) + max - 1 ) % max;
         changed = qtrue;
@@ -3243,13 +3343,18 @@ static void Item_TextField_CalcPaintOffset( itemDef_t *item, char *buff )
   }
 }
 
-qboolean Item_TextField_HandleKey( itemDef_t *item, int key )
+qboolean Item_TextField_HandleKey( itemDef_t *item, int key, int state )
 {
   char buff[1024];
   int len;
+  face_t *face = &DC->Assets.dynFont;
   itemDef_t *newItem = NULL;
   editFieldDef_t *editPtr = item->typeData.edit;
   qboolean releaseFocus = qtrue;
+  qboolean sup = state & (1 << KEYEVSTATE_SUP);
+  qboolean isChar = !sup ? key & (1 << (K_CHAR_BIT - 1)) : state & (1 << KEYEVSTATE_CHAR);
+  int first = (!isChar || !sup) ? key : *Q_UTF8Unstore( key );
+  int width;
 
   if( item->cvar )
   {
@@ -3263,28 +3368,32 @@ qboolean Item_TextField_HandleKey( itemDef_t *item, int key )
     if( editPtr->maxChars && len > editPtr->maxChars )
       len = editPtr->maxChars;
 
-    if( key & K_CHAR_FLAG )
+    width = UI_UTF8Width( face, buff + item->cursorPos );
+
+    if( isChar )
     {
-      key &= ~K_CHAR_FLAG;
+      const char *s;
+
+      if( !sup )
+        key &= ~(1 << (K_CHAR_BIT - 1) );
 
-      if( key == 'h' - 'a' + 1 )
+      s = Q_UTF8Unstore( key );
+
+      if( first == 'h' - 'a' + 1 )
       {
         // ctrl-h is backspace
 
-        if( item->cursorPos > 0 )
+        while( item->cursorPos > 0 )
         {
+          qboolean isContinue = Q_UTF8ContByte( buff[ item->cursorPos - 1 ] );
           memmove( &buff[item->cursorPos - 1], &buff[item->cursorPos], len + 1 - item->cursorPos );
           item->cursorPos--;
+          if( !isContinue )
+            break;
         }
 
         DC->setCVar( item->cvar, buff );
       }
-      else if( key < 32 || !item->cvar )
-      {
-        // Ignore any non printable chars
-        releaseFocus = qfalse;
-        goto exit;
-      }
       else if( item->type == ITEM_TYPE_NUMERICFIELD && ( key < '0' || key > '9' ) )
       {
         // Ignore non-numeric characters
@@ -3293,6 +3402,14 @@ qboolean Item_TextField_HandleKey( itemDef_t *item, int key )
       }
       else
       {
+        width = UI_UTF8Width( face, s );
+
+        if( len + width > MAX_EDITFIELD - 1 )
+        {
+          // Reached maximum field length
+          releaseFocus = qfalse;
+          goto exit;
+        }
         if( !DC->getOverstrikeMode() )
         {
           if( ( len == MAX_EDITFIELD - 1 ) || ( editPtr->maxChars && len >= editPtr->maxChars ) )
@@ -3302,7 +3419,7 @@ qboolean Item_TextField_HandleKey( itemDef_t *item, int key )
             goto exit;
           }
 
-          memmove( &buff[item->cursorPos + 1], &buff[item->cursorPos], len + 1 - item->cursorPos );
+          memmove( &buff[item->cursorPos + width], &buff[item->cursorPos], len + 1 - item->cursorPos );
         }
         else
         {
@@ -3314,23 +3431,23 @@ qboolean Item_TextField_HandleKey( itemDef_t *item, int key )
           }
         }
 
-        buff[ item->cursorPos ] = key;
+        Com_Memcpy( buff + item->cursorPos, s, width );
 
         DC->setCVar( item->cvar, buff );
 
-        if( item->cursorPos < len + 1 )
-          item->cursorPos++;
+        if( item->cursorPos < len + width )
+          item->cursorPos += width;
       }
     }
     else
     {
-      switch( key )
+      switch( first )
       {
         case K_DEL:
         case K_KP_DEL:
-          if( item->cursorPos < len )
+          if( item->cursorPos + width <= len )
           {
-            memmove( buff + item->cursorPos, buff + item->cursorPos + 1, len - item->cursorPos );
+            memmove( buff + item->cursorPos, buff + item->cursorPos + width, len - item->cursorPos );
             DC->setCVar( item->cvar, buff );
           }
 
@@ -3338,15 +3455,19 @@ qboolean Item_TextField_HandleKey( itemDef_t *item, int key )
 
         case K_RIGHTARROW:
         case K_KP_RIGHTARROW:
-          if( item->cursorPos < len )
-            item->cursorPos++;
+          if( item->cursorPos + width <= len )
+            item->cursorPos += width;
 
           break;
 
         case K_LEFTARROW:
         case K_KP_LEFTARROW:
-          if( item->cursorPos > 0 )
+          while( item->cursorPos > 0 )
+          {
             item->cursorPos--;
+            if( !Q_UTF8ContByte( buff[ item->cursorPos ] ) )
+              break;
+          }
 
           break;
 
@@ -3360,6 +3481,11 @@ qboolean Item_TextField_HandleKey( itemDef_t *item, int key )
         case K_KP_END:
           item->cursorPos = len;
 
+          while( item->cursorPos > 0 && Q_UTF8ContByte( buff[ item->cursorPos ] ) )
+          {
+            item->cursorPos--;
+          }
+
           break;
 
         case K_INS:
@@ -3426,7 +3552,7 @@ static void _Scroll_ListBox_AutoFunc( scrollInfo_t *si )
     // need to scroll which is done by simulating a click to the item
     // this is done a bit sideways as the autoscroll "knows" that the item is a listbox
     // so it calls it directly
-    Item_ListBox_HandleKey( si->item, si->scrollKey, qtrue, qfalse );
+    Item_ListBox_HandleKey( si->item, si->scrollKey, (qtrue << KEYEVSTATE_DOWN) | (qtrue << KEYEVSTATE_SUP), qfalse );
 
     si->nextScrollTime = DC->realTime + si->adjustValue;
   }
@@ -3478,7 +3604,7 @@ static void _Scroll_ListBox_ThumbFunc( scrollInfo_t *si )
     // need to scroll which is done by simulating a click to the item
     // this is done a bit sideways as the autoscroll "knows" that the item is a listbox
     // so it calls it directly
-    Item_ListBox_HandleKey( si->item, si->scrollKey, qtrue, qfalse );
+    Item_ListBox_HandleKey( si->item, si->scrollKey, (qtrue << KEYEVSTATE_DOWN) | (qtrue << KEYEVSTATE_SUP), qfalse );
 
     si->nextScrollTime = DC->realTime + si->adjustValue;
   }
@@ -3590,15 +3716,18 @@ void Item_StopCapture( itemDef_t *item )
 {
 }
 
-qboolean Item_Slider_HandleKey( itemDef_t *item, int key, qboolean down )
+qboolean Item_Slider_HandleKey( itemDef_t *item, int key, int state )
 {
   float x, value, width;
+  qboolean sup = state & (1 << KEYEVSTATE_SUP);
+  qboolean isChar = !sup ? key & (1 << (K_CHAR_BIT - 1)) : state & (1 << KEYEVSTATE_CHAR);
+  int first = (!isChar || !sup) ? key : *Q_UTF8Unstore( key );
 
   if( item->window.flags & WINDOW_HASFOCUS && item->cvar &&
       Rect_ContainsPoint( &item->window.rect, DC->cursorx, DC->cursory ) )
   {
-    if( item->typeData.edit && ( key == K_ENTER ||
-        key == K_MOUSE1 || key == K_MOUSE2 || key == K_MOUSE3 ) )
+    if( item->typeData.edit && ( first == K_ENTER ||
+        first == K_MOUSE1 || first == K_MOUSE2 || first == K_MOUSE3 ) )
     {
       rectDef_t testRect;
       width = SLIDER_WIDTH;
@@ -3628,8 +3757,11 @@ qboolean Item_Slider_HandleKey( itemDef_t *item, int key, qboolean down )
 }
 
 
-qboolean Item_HandleKey( itemDef_t *item, int key, qboolean down )
+qboolean Item_HandleKey( itemDef_t *item, int key, int state )
 {
+  qboolean sup = state & (1 << KEYEVSTATE_SUP);
+  qboolean down = !sup ? state : state & (1 << KEYEVSTATE_DOWN);
+
   if( itemCapture )
   {
     Item_StopCapture( itemCapture );
@@ -3661,28 +3793,28 @@ qboolean Item_HandleKey( itemDef_t *item, int key, qboolean down )
       return qfalse;
 
     case ITEM_TYPE_CYCLE:
-      return Item_Cycle_HandleKey( item, key );
+      return Item_Cycle_HandleKey( item, key, state );
 
     case ITEM_TYPE_LISTBOX:
-      return Item_ListBox_HandleKey( item, key, down, qfalse );
+      return Item_ListBox_HandleKey( item, key, state, qfalse );
 
     case ITEM_TYPE_COMBOBOX:
-      return Item_ComboBox_HandleKey( item, key, down, qfalse );
+      return Item_ComboBox_HandleKey( item, key, state, qfalse );
 
     case ITEM_TYPE_YESNO:
-      return Item_YesNo_HandleKey( item, key );
+      return Item_YesNo_HandleKey( item, key, state );
 
     case ITEM_TYPE_MULTI:
-      return Item_Multi_HandleKey( item, key );
+      return Item_Multi_HandleKey( item, key, state );
 
     case ITEM_TYPE_OWNERDRAW:
-      return Item_OwnerDraw_HandleKey( item, key );
+      return Item_OwnerDraw_HandleKey( item, key, state );
 
     case ITEM_TYPE_BIND:
-      return Item_Bind_HandleKey( item, key, down );
+      return Item_Bind_HandleKey( item, key, state );
 
     case ITEM_TYPE_SLIDER:
-      return Item_Slider_HandleKey( item, key, down );
+      return Item_Slider_HandleKey( item, key, state );
 
     default:
       return qfalse;
@@ -3867,8 +3999,8 @@ qboolean Menus_ReplaceActive( menuDef_t *menu )
 
   if( menu->itemCount != active->itemCount )
   {
-    Com_Printf( S_COLOR_YELLOW
-      "WARNING: Menus_ReplaceActive: expecting %i menu items, found %i\n",
+    Com_Printf( _(S_COLOR_YELLOW
+      "WARNING: Menus_ReplaceActive: expecting %i menu items, found %i\n"),
       menu->itemCount, active->itemCount);
     return qfalse;
   }
@@ -3877,8 +4009,8 @@ qboolean Menus_ReplaceActive( menuDef_t *menu )
   {
     if( menu->items[ i ]->type != active->items[ i ]->type )
     {
-      Com_Printf( S_COLOR_YELLOW
-        "WARNING: Menus_ReplaceActive: type mismatch on item %i\n", i + 1 );
+      Com_Printf( _(S_COLOR_YELLOW
+        "WARNING: Menus_ReplaceActive: type mismatch on item %i\n"), i + 1 );
       return qfalse;
     }
   }
@@ -3932,8 +4064,11 @@ int Display_VisibleMenuCount( void )
   return count;
 }
 
-void Menus_HandleOOBClick( menuDef_t *menu, int key, qboolean down )
+void Menus_HandleOOBClick( menuDef_t *menu, int key, int state )
 {
+  qboolean sup = state & (1 << KEYEVSTATE_SUP);
+  qboolean down = !sup ? state : state & (1 << KEYEVSTATE_DOWN);
+
   if( menu )
   {
     int i;
@@ -3951,7 +4086,7 @@ void Menus_HandleOOBClick( menuDef_t *menu, int key, qboolean down )
         Menus_Close( menu );
         Menus_Activate( &Menus[i] );
         Menu_HandleMouseMove( &Menus[i], DC->cursorx, DC->cursory );
-        Menu_HandleKey( &Menus[i], key, down );
+        Menu_HandleKey( &Menus[i], key, state );
       }
     }
 
@@ -3981,24 +4116,28 @@ static rectDef_t *Item_CorrectedTextRect( itemDef_t *item )
   return &rect;
 }
 
-void Menu_HandleKey( menuDef_t *menu, int key, qboolean down )
+void Menu_HandleKey( menuDef_t *menu, int key, int state )
 {
   int i;
   itemDef_t *item = NULL;
+  qboolean sup = state & (1 << KEYEVSTATE_SUP);
+  qboolean down = !sup ? state : state & (1 << KEYEVSTATE_DOWN);
+  qboolean isChar = !sup ? key & (1 << (K_CHAR_BIT - 1)) : state & (1 << KEYEVSTATE_CHAR);
   qboolean inHandler = qfalse;
+  int first = (!isChar || !sup) ? key : *Q_UTF8Unstore( key );
 
   inHandler = qtrue;
 
   if( g_waitingForKey && down )
   {
-    Item_Bind_HandleKey( g_bindItem, key, down );
+    Item_Bind_HandleKey( g_bindItem, key, state );
     inHandler = qfalse;
     return;
   }
 
   if( g_editingField && down )
   {
-    if( !Item_TextField_HandleKey( g_editItem, key ) )
+    if( !Item_TextField_HandleKey( g_editItem, key, state ) )
     {
       g_editingField = qfalse;
       Item_RunScript( g_editItem, g_editItem->onTextEntry );
@@ -4027,7 +4166,7 @@ void Menu_HandleKey( menuDef_t *menu, int key, qboolean down )
     if( !inHandleKey && ( key == K_MOUSE1 || key == K_MOUSE2 || key == K_MOUSE3 ) )
     {
       inHandleKey = qtrue;
-      Menus_HandleOOBClick( menu, key, down );
+      Menus_HandleOOBClick( menu, key, state );
       inHandleKey = qfalse;
       inHandler = qfalse;
       return;
@@ -4048,7 +4187,7 @@ void Menu_HandleKey( menuDef_t *menu, int key, qboolean down )
 
   if( item != NULL )
   {
-    if( Item_HandleKey( item, key, down ) )
+    if( Item_HandleKey( item, key, state ) )
     {
       Item_Action( item );
       inHandler = qfalse;
@@ -4063,7 +4202,7 @@ void Menu_HandleKey( menuDef_t *menu, int key, qboolean down )
   }
 
   // default handling
-  switch( key )
+  switch( first )
   {
     case K_F12:
       if( DC->getCVarValue( "developer" ) )
@@ -4321,6 +4460,7 @@ const char *Item_Text_Wrap( const char *text, float scale, float width )
   unsigned int  i;
   float         indentWidth = 0.0f;
   float         testWidth;
+  face_t        *face = &DC->Assets.dynFont;
 
   if( strlen( text ) >= sizeof( out ) )
     return NULL;
@@ -4338,6 +4478,7 @@ const char *Item_Text_Wrap( const char *text, float scale, float width )
 
     while( testLength == 0 || UI_Text_Width( p, scale, testLength ) < testWidth )
     {
+      int      width;
       int      emoticonLen;
       qboolean emoticonEscaped;
       qboolean previousCharIsSpace = qfalse;
@@ -4364,6 +4505,12 @@ const char *Item_Text_Wrap( const char *text, float scale, float width )
         continue;
       }
 
+      if( ( width = UI_UTF8Width( face, p ) ) > 1 )
+      {
+        testLength += width;
+        continue;
+      }
+
       if( testLength > 0 && *q == INDENT_MARKER )
       {
         indentWidth = UI_Text_Width( p, scale, testLength );
@@ -4844,10 +4991,10 @@ void Item_YesNo_Paint( itemDef_t *item )
   {
     Item_Text_Paint( item );
     UI_Text_Paint( item->textRect.x + item->textRect.w + offset, item->textRect.y, item->textscale,
-                   newColor, ( value != 0 ) ? "Yes" : "No", 0, 0, item->textStyle );
+                   newColor, ( value != 0 ) ? _("Yes") : _("No"), 0, 0, item->textStyle );
   }
   else
-    UI_Text_Paint( item->textRect.x, item->textRect.y, item->textscale, newColor, ( value != 0 ) ? "Yes" : "No", 0, 0, item->textStyle );
+    UI_Text_Paint( item->textRect.x, item->textRect.y, item->textscale, newColor, ( value != 0 ) ? _("Yes") : _("No"), 0, 0, item->textStyle );
 }
 
 void Item_Multi_Paint( itemDef_t *item )
@@ -5220,14 +5367,18 @@ qboolean Display_KeyBindPending( void )
   return g_waitingForKey;
 }
 
-qboolean Item_Bind_HandleKey( itemDef_t *item, int key, qboolean down )
+qboolean Item_Bind_HandleKey( itemDef_t *item, int key, int state )
 {
   int     id;
   int     i;
+  qboolean sup = state & (1 << KEYEVSTATE_SUP);
+  qboolean down = !sup ? state : state & (1 << KEYEVSTATE_DOWN);
+  qboolean isChar = !sup ? key & (1 << (K_CHAR_BIT - 1)) : state & (1 << KEYEVSTATE_CHAR);
+  int first = (!isChar || !sup) ? key : *Q_UTF8Unstore( key );
 
   if( Rect_ContainsPoint( &item->window.rect, DC->cursorx, DC->cursory ) && !g_waitingForKey )
   {
-    if( down && ( key == K_MOUSE1 || key == K_ENTER ) )
+    if( down && ( first == K_MOUSE1 || first == K_ENTER ) )
     {
       g_waitingForKey = qtrue;
       g_bindItem = item;
@@ -5240,10 +5391,10 @@ qboolean Item_Bind_HandleKey( itemDef_t *item, int key, qboolean down )
     if( !g_waitingForKey || g_bindItem == NULL )
       return qtrue;
 
-    if( key & K_CHAR_FLAG )
+    if( isChar )
       return qtrue;
 
-    switch( key )
+    switch( first )
     {
       case K_ESCAPE:
         g_waitingForKey = qfalse;
@@ -5268,14 +5419,14 @@ qboolean Item_Bind_HandleKey( itemDef_t *item, int key, qboolean down )
     }
   }
 
-  if( key != -1 )
+  if( first != -1 )
   {
     for( i = 0; i < g_bindCount; i++ )
     {
-      if( g_bindings[i].bind2 == key )
+      if( g_bindings[i].bind2 == first )
         g_bindings[i].bind2 = -1;
 
-      if( g_bindings[i].bind1 == key )
+      if( g_bindings[i].bind1 == first )
       {
         g_bindings[i].bind1 = g_bindings[i].bind2;
         g_bindings[i].bind2 = -1;
@@ -5288,7 +5439,7 @@ qboolean Item_Bind_HandleKey( itemDef_t *item, int key, qboolean down )
 
   if( id != -1 )
   {
-    if( key == -1 )
+    if( first == -1 )
     {
       if( g_bindings[id].bind1 != -1 )
       {
@@ -5303,14 +5454,14 @@ qboolean Item_Bind_HandleKey( itemDef_t *item, int key, qboolean down )
       }
     }
     else if( g_bindings[id].bind1 == -1 )
-      g_bindings[id].bind1 = key;
-    else if( g_bindings[id].bind1 != key && g_bindings[id].bind2 == -1 )
-      g_bindings[id].bind2 = key;
+      g_bindings[id].bind1 = first;
+    else if( g_bindings[id].bind1 != first && g_bindings[id].bind2 == -1 )
+      g_bindings[id].bind2 = first;
     else
     {
       DC->setBinding( g_bindings[id].bind1, "" );
       DC->setBinding( g_bindings[id].bind2, "" );
-      g_bindings[id].bind1 = key;
+      g_bindings[id].bind1 = first;
       g_bindings[id].bind2 = -1;
     }
   }
@@ -6004,8 +6155,11 @@ menuDef_t *Menu_GetFocused( void )
   return NULL;
 }
 
-void Menu_ScrollFeeder( menuDef_t *menu, int feeder, qboolean down )
+void Menu_ScrollFeeder( menuDef_t *menu, int feeder, int state )
 {
+  qboolean sup = state & (1 << KEYEVSTATE_SUP);
+  qboolean down = !sup ? state : state & (1 << KEYEVSTATE_DOWN);
+
   if( menu )
   {
     int i;
@@ -6017,7 +6171,7 @@ void Menu_ScrollFeeder( menuDef_t *menu, int feeder, qboolean down )
       if( item->feederID == feeder )
       {
         qboolean cast = Item_ComboBox_MaybeCastToListBox( item );
-        Item_ListBox_HandleKey( item, down ? K_DOWNARROW : K_UPARROW, qtrue, qtrue );
+        Item_ListBox_HandleKey( item, down ? K_DOWNARROW : K_UPARROW, state | (qtrue << KEYEVSTATE_DOWN), qtrue );
         Item_ComboBox_MaybeUnCastFromListBox( item, cast );
 
         return;
@@ -6448,7 +6602,7 @@ qboolean ItemParse_focusSound( itemDef_t *item, int handle )
 // text <string>
 qboolean ItemParse_text( itemDef_t *item, int handle )
 {
-  if( !PC_String_Parse( handle, &item->text ) )
+  if( !PC_String_Parse_( handle, &item->text ) )
     return qfalse;
 
   return qtrue;
@@ -6588,7 +6742,7 @@ qboolean ItemParse_type( itemDef_t *item, int handle )
 {
   if( item->type != ITEM_TYPE_NONE )
   {
-    PC_SourceError( handle, "item already has a type" );
+    PC_SourceError( handle, _("item already has a type") );
     return qfalse;
   }
 
@@ -6597,7 +6751,7 @@ qboolean ItemParse_type( itemDef_t *item, int handle )
 
   if( item->type == ITEM_TYPE_NONE )
   {
-    PC_SourceError( handle, "type must not be none" );
+    PC_SourceError( handle, _("type must not be none") );
     return qfalse;
   }
 
@@ -6690,7 +6844,7 @@ qboolean ItemParse_columns( itemDef_t *item, int handle )
 
   if( item->typeData.list->numColumns > MAX_LB_COLUMNS )
   {
-    PC_SourceError( handle, "exceeded maximum allowed columns (%d)",
+    PC_SourceError( handle, _("exceeded maximum allowed columns (%d)"),
                     MAX_LB_COLUMNS );
     return qfalse;
   }
@@ -6750,7 +6904,7 @@ qboolean ItemParse_ownerdraw( itemDef_t *item, int handle )
 
   if( item->type != ITEM_TYPE_NONE && item->type != ITEM_TYPE_OWNERDRAW )
   {
-    PC_SourceError( handle, "ownerdraws cannot have an item type" );
+    PC_SourceError( handle, _("ownerdraws cannot have an item type") );
     return qfalse;
   }
 
@@ -7010,7 +7164,7 @@ qboolean ItemParse_maxFieldWidth( itemDef_t *item, int handle )
 
   if( item->typeData.edit->maxFieldWidth < MIN_FIELD_WIDTH )
   {
-    PC_SourceError( handle, "max field width must be at least %d",
+    PC_SourceError( handle, _("max field width must be at least %d"),
                     MIN_FIELD_WIDTH );
     return qfalse;
   }
@@ -7050,7 +7204,7 @@ qboolean ItemParse_cvarStrList( itemDef_t *item, int handle )
   {
     if( !trap_Parse_ReadToken( handle, &token ) )
     {
-      PC_SourceError( handle, "end of file inside menu item\n" );
+      PC_SourceError( handle, _("end of file inside menu item\n") );
       return qfalse;
     }
 
@@ -7073,7 +7227,7 @@ qboolean ItemParse_cvarStrList( itemDef_t *item, int handle )
 
       if( multiPtr->count >= MAX_MULTI_CVARS )
       {
-        PC_SourceError( handle, "cvar string list may not exceed %d cvars",
+        PC_SourceError( handle, _("cvar string list may not exceed %d cvars"),
                         MAX_MULTI_CVARS );
         return qfalse;
       }
@@ -7103,7 +7257,7 @@ qboolean ItemParse_cvarFloatList( itemDef_t *item, int handle )
   {
     if( !trap_Parse_ReadToken( handle, &token ) )
     {
-      PC_SourceError( handle, "end of file inside menu item\n" );
+      PC_SourceError( handle, _("end of file inside menu item\n") );
       return qfalse;
     }
 
@@ -7122,7 +7276,7 @@ qboolean ItemParse_cvarFloatList( itemDef_t *item, int handle )
 
     if( multiPtr->count >= MAX_MULTI_CVARS )
     {
-      PC_SourceError( handle, "cvar string list may not exceed %d cvars",
+      PC_SourceError( handle, _("cvar string list may not exceed %d cvars"),
                       MAX_MULTI_CVARS );
       return qfalse;
     }
@@ -7148,7 +7302,7 @@ qboolean ItemParse_addColorRange( itemDef_t *item, int handle )
     }
     else
     {
-      PC_SourceError( handle, "may not exceed %d color ranges",
+      PC_SourceError( handle, _("may not exceed %d color ranges"),
                       MAX_COLOR_RANGES );
       return qfalse;
     }
@@ -7324,7 +7478,7 @@ qboolean Item_Parse( int handle, itemDef_t *item )
   {
     if( !trap_Parse_ReadToken( handle, &token ) )
     {
-      PC_SourceError( handle, "end of file inside menu item\n" );
+      PC_SourceError( handle, _("end of file inside menu item\n") );
       return qfalse;
     }
 
@@ -7335,7 +7489,7 @@ qboolean Item_Parse( int handle, itemDef_t *item )
 
     if( !key )
     {
-      PC_SourceError( handle, "unknown menu item keyword %s", token.string );
+      PC_SourceError( handle, _("unknown menu item keyword %s"), token.string );
       continue;
     }
 
@@ -7347,18 +7501,18 @@ qboolean Item_Parse( int handle, itemDef_t *item )
       if( test != key->param )
       {
         if( test == TYPE_NONE )
-          PC_SourceError( handle, "menu item keyword %s requires "
-                          "type specification", token.string );
+          PC_SourceError( handle, _("menu item keyword %s requires "
+                          "type specification"), token.string );
         else
-          PC_SourceError( handle, "menu item keyword %s is incompatible with "
-                          "specified item type", token.string );
+          PC_SourceError( handle, _("menu item keyword %s is incompatible with "
+                          "specified item type"), token.string );
         continue;
       }
     }
 
     if( !key->func( item, handle ) )
     {
-      PC_SourceError( handle, "couldn't parse menu item keyword %s", token.string );
+      PC_SourceError( handle, _("couldn't parse menu item keyword %s"), token.string );
       return qfalse;
     }
   }
@@ -7409,6 +7563,22 @@ qboolean MenuParse_font( itemDef_t *item, int handle )
   return qtrue;
 }
 
+qboolean MenuParse_dynFont( itemDef_t *item, int handle )
+{
+  menuDef_t *menu = ( menuDef_t* )item;
+
+  if( !PC_String_Parse( handle, &menu->dynFont ) )
+    return qfalse;
+
+  if( !DC->Assets.dynFontRegistered )
+  {
+    DC->loadFace( menu->dynFont, 48, menu->dynFont, &DC->Assets.dynFont );
+    DC->Assets.dynFontRegistered = qtrue;
+  }
+
+  return qtrue;
+}
+
 qboolean MenuParse_name( itemDef_t *item, int handle )
 {
   menuDef_t *menu = ( menuDef_t* )item;
@@ -7743,7 +7913,7 @@ qboolean MenuParse_itemDef( itemDef_t *item, int handle )
   }
   else
   {
-    PC_SourceError( handle, "itemDefs per menu may not exceed %d",
+    PC_SourceError( handle, _("itemDefs per menu may not exceed %d"),
                     MAX_MENUITEMS );
     return qfalse;
   }
@@ -7753,6 +7923,7 @@ qboolean MenuParse_itemDef( itemDef_t *item, int handle )
 
 keywordHash_t menuParseKeywords[] = {
   {"font", MenuParse_font},
+  {"dynfont", MenuParse_dynFont},
   {"name", MenuParse_name},
   {"fullscreen", MenuParse_fullscreen},
   {"rect", MenuParse_rect},
@@ -7823,7 +7994,7 @@ qboolean Menu_Parse( int handle, menuDef_t *menu )
 
     if( !trap_Parse_ReadToken( handle, &token ) )
     {
-      PC_SourceError( handle, "end of file inside menu\n" );
+      PC_SourceError( handle, _("end of file inside menu\n") );
       return qfalse;
     }
 
@@ -7834,13 +8005,13 @@ qboolean Menu_Parse( int handle, menuDef_t *menu )
 
     if( !key )
     {
-      PC_SourceError( handle, "unknown menu keyword %s", token.string );
+      PC_SourceError( handle, _("unknown menu keyword %s"), token.string );
       continue;
     }
 
     if( !key->func( ( itemDef_t* )menu, handle ) )
     {
-      PC_SourceError( handle, "couldn't parse menu keyword %s", token.string );
+      PC_SourceError( handle, _("couldn't parse menu keyword %s"), token.string );
       return qfalse;
     }
   }
@@ -7985,7 +8156,7 @@ int Display_CursorType( int x, int y )
 }
 
 
-void Display_HandleKey( int key, qboolean down, int x, int y )
+void Display_HandleKey( int key, int state, int x, int y )
 {
   menuDef_t *menu = Display_CaptureItem( x, y );
 
@@ -7993,7 +8164,7 @@ void Display_HandleKey( int key, qboolean down, int x, int y )
     menu = Menu_GetFocused();
 
   if( menu )
-    Menu_HandleKey( menu, key, down );
+    Menu_HandleKey( menu, key, state );
 }
 
 static void Window_CacheContents( windowDef_t *window )
diff --git a/src/ui/ui_shared.h b/src/ui/ui_shared.h
index 154325d..8a8da5f 100644
--- a/src/ui/ui_shared.h
+++ b/src/ui/ui_shared.h
@@ -327,6 +327,7 @@ typedef struct
 {
   Window window;
   const char  *font;                // font
+  const char  *dynFont;             // dynFont
   qboolean fullScreen;              // covers entire screen
   int itemCount;                    // number of items;
   int fontIndex;                    //
@@ -353,6 +354,9 @@ typedef struct
   fontInfo_t textFont;
   fontInfo_t smallFont;
   fontInfo_t bigFont;
+  face_t     dynFont;
+  face_t     smallDynFont;
+  face_t     bigDynFont;
   qhandle_t cursor;
   qhandle_t gradientBar;
   qhandle_t scrollBarArrowUp;
@@ -378,6 +382,7 @@ typedef struct
   vec4_t shadowColor;
   float shadowFadeClamp;
   qboolean fontRegistered;
+  qboolean dynFontRegistered;
   emoticon_t emoticons[ MAX_EMOTICONS ];
   int emoticonCount;
 }
@@ -406,6 +411,12 @@ typedef struct
   void ( *addRefEntityToScene ) ( const refEntity_t *re );
   void ( *renderScene ) ( const refdef_t *fd );
   void ( *registerFont ) ( const char *pFontname, int pointSize, fontInfo_t *font );
+  void ( *loadFace )( const char *fileName, int pointSize, const char *name, face_t *face );
+  void ( *freeFace )( face_t *face );
+	void ( *loadGlyph )( face_t *face, const char *str, int img, glyphInfo_t *glyphInfo );
+	void ( *freeGlyph )( face_t *face, int img, glyphInfo_t *glyphInfo );
+	void ( *glyph )( fontInfo_t *font, face_t *face, const char *str, glyphInfo_t *glyph );
+  void ( *freeCachedGlyphs )( face_t *face );
   void ( *ownerDrawItem ) ( float x, float y, float w, float h, float text_x,
                             float text_y, int ownerDraw, int ownerDrawFlags,
                             int align, int textalign, int textvalign,
@@ -421,7 +432,7 @@ typedef struct
   void ( *setOverstrikeMode )( qboolean b );
   qboolean ( *getOverstrikeMode )( void );
   void ( *startLocalSound )( sfxHandle_t sfx, int channelNum );
-  qboolean ( *ownerDrawHandleKey )( int ownerDraw, int key );
+  qboolean ( *ownerDrawHandleKey )( int ownerDraw, int key, int state );
   int ( *feederCount )( int feederID );
   const char *( *feederItemText )( int feederID, int index, int column, qhandle_t *handle );
   qhandle_t ( *feederItemImage )( int feederID, int index );
@@ -464,6 +475,8 @@ typedef struct
 }
 displayContextDef_t;
 
+void UIS_Shutdown( void );
+
 const char *String_Alloc( const char *p );
 void String_Init( void );
 void String_Report( void );
@@ -473,9 +486,9 @@ void Menu_Init( menuDef_t *menu );
 void Item_Init( itemDef_t *item );
 void Menu_PostParse( menuDef_t *menu );
 menuDef_t *Menu_GetFocused( void );
-void Menu_HandleKey( menuDef_t *menu, int key, qboolean down );
+void Menu_HandleKey( menuDef_t *menu, int key, int state );
 void Menu_HandleMouseMove( menuDef_t *menu, float x, float y );
-void Menu_ScrollFeeder( menuDef_t *menu, int feeder, qboolean down );
+void Menu_ScrollFeeder( menuDef_t *menu, int feeder, int state );
 qboolean Float_Parse( char **p, float *f );
 qboolean Color_Parse( char **p, vec4_t *c );
 qboolean Int_Parse( char **p, int *i );
@@ -506,7 +519,7 @@ int Display_CursorType( int x, int y );
 qboolean Display_KeyBindPending( void );
 menuDef_t *Menus_FindByName( const char *p );
 void Menus_CloseByName( const char *p );
-void Display_HandleKey( int key, qboolean down, int x, int y );
+void Display_HandleKey( int key, int state, int x, int y );
 void LerpColor( vec4_t a, vec4_t b, vec4_t c, float t );
 void Menus_CloseAll( void );
 void Menu_Update( menuDef_t *menu );
@@ -529,6 +542,8 @@ void Controls_SetDefaults( void );
 
 void trap_R_SetClipRegion( const float *region );
 
+glyphInfo_t *UI_Glyph( fontInfo_t *font, face_t *face, const char *str );
+
 //for cg_draw.c
 void Item_Text_Wrapped_Paint( itemDef_t *item );
 const char *Item_Text_Wrap( const char *text, float scale, float width );
diff --git a/src/ui/ui_syscalls.asm b/src/ui/ui_syscalls.asm
index 1e797a9..f22910f 100644
--- a/src/ui/ui_syscalls.asm
+++ b/src/ui/ui_syscalls.asm
@@ -100,3 +100,11 @@ equ sqrt                              -107
 equ floor                             -108
 equ ceil                              -109
 
+equ trap_Gettext                      -301
+equ trap_R_LoadFace                   -302
+equ trap_R_FreeFace                   -303
+equ trap_R_LoadGlyph                  -304
+equ trap_R_FreeGlyph                  -305
+equ trap_R_Glyph                      -306
+equ trap_R_FreeCachedGlyphs           -307
+
diff --git a/src/ui/ui_syscalls.c b/src/ui/ui_syscalls.c
index 2187f18..50aad7f 100644
--- a/src/ui/ui_syscalls.c
+++ b/src/ui/ui_syscalls.c
@@ -162,6 +162,36 @@ void trap_R_RegisterFont( const char *fontName, int pointSize, fontInfo_t *font
   syscall( UI_R_REGISTERFONT, fontName, pointSize, font );
 }
 
+void trap_R_LoadFace( const char *fileName, int pointSize, const char *name, face_t *face )
+{
+  syscall( UI_R_LOADFACE, fileName, pointSize, name, face );
+}
+
+void trap_R_FreeFace( face_t *face )
+{
+  syscall( UI_R_FREEFACE, face );
+}
+
+void trap_R_LoadGlyph( face_t *face, const char *str, int img, glyphInfo_t *glyphInfo )
+{
+  syscall( UI_R_LOADGLYPH, face, str, img, glyphInfo );
+}
+
+void trap_R_FreeGlyph( face_t *face, int img, glyphInfo_t *glyphInfo )
+{
+  syscall( UI_R_FREEGLYPH, face, img, glyphInfo );
+}
+
+void trap_R_Glyph( fontInfo_t *font, face_t *face, const char *str, glyphInfo_t *glyph )
+{
+  syscall( UI_R_GLYPH, font, face, str, glyph );
+}
+
+void trap_R_FreeCachedGlyphs( face_t *face )
+{
+  syscall( UI_R_FREECACHEDGLYPHS, face );
+}
+
 qhandle_t trap_R_RegisterShaderNoMip( const char *name )
 {
   return syscall( UI_R_REGISTERSHADERNOMIP, name );
@@ -481,3 +511,8 @@ void trap_SetPbClStatus( int status )
 {
   syscall( UI_SET_PBCLSTATUS, status );
 }
+
+void trap_Gettext( char *buffer, const char *msgid, int bufferLength )
+{
+  syscall( UI_GETTEXT, buffer, msgid, bufferLength );
+}
